// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/tracing/trace.proto

#ifndef PROTOBUF_google_2ftracing_2ftrace_2eproto__INCLUDED
#define PROTOBUF_google_2ftracing_2ftrace_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "google/rpc/status.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_google_2ftracing_2ftrace_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsTraceIdImpl();
void InitDefaultsTraceId();
void InitDefaultsModuleImpl();
void InitDefaultsModule();
void InitDefaultsStackTrace_StackFrameImpl();
void InitDefaultsStackTrace_StackFrame();
void InitDefaultsStackTraceImpl();
void InitDefaultsStackTrace();
void InitDefaultsLabelValueImpl();
void InitDefaultsLabelValue();
void InitDefaultsSpan_TimeEvent_Annotation_LabelsEntry_DoNotUseImpl();
void InitDefaultsSpan_TimeEvent_Annotation_LabelsEntry_DoNotUse();
void InitDefaultsSpan_TimeEvent_AnnotationImpl();
void InitDefaultsSpan_TimeEvent_Annotation();
void InitDefaultsSpan_TimeEvent_NetworkEventImpl();
void InitDefaultsSpan_TimeEvent_NetworkEvent();
void InitDefaultsSpan_TimeEventImpl();
void InitDefaultsSpan_TimeEvent();
void InitDefaultsSpan_LinkImpl();
void InitDefaultsSpan_Link();
void InitDefaultsSpan_LabelsEntry_DoNotUseImpl();
void InitDefaultsSpan_LabelsEntry_DoNotUse();
void InitDefaultsSpanImpl();
void InitDefaultsSpan();
void InitDefaultsTraceImpl();
void InitDefaultsTrace();
inline void InitDefaults() {
  InitDefaultsTraceId();
  InitDefaultsModule();
  InitDefaultsStackTrace_StackFrame();
  InitDefaultsStackTrace();
  InitDefaultsLabelValue();
  InitDefaultsSpan_TimeEvent_Annotation_LabelsEntry_DoNotUse();
  InitDefaultsSpan_TimeEvent_Annotation();
  InitDefaultsSpan_TimeEvent_NetworkEvent();
  InitDefaultsSpan_TimeEvent();
  InitDefaultsSpan_Link();
  InitDefaultsSpan_LabelsEntry_DoNotUse();
  InitDefaultsSpan();
  InitDefaultsTrace();
}
}  // namespace protobuf_google_2ftracing_2ftrace_2eproto
namespace google {
namespace tracing {
namespace v1 {
class LabelValue;
class LabelValueDefaultTypeInternal;
extern LabelValueDefaultTypeInternal _LabelValue_default_instance_;
class Module;
class ModuleDefaultTypeInternal;
extern ModuleDefaultTypeInternal _Module_default_instance_;
class Span;
class SpanDefaultTypeInternal;
extern SpanDefaultTypeInternal _Span_default_instance_;
class Span_LabelsEntry_DoNotUse;
class Span_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Span_LabelsEntry_DoNotUseDefaultTypeInternal _Span_LabelsEntry_DoNotUse_default_instance_;
class Span_Link;
class Span_LinkDefaultTypeInternal;
extern Span_LinkDefaultTypeInternal _Span_Link_default_instance_;
class Span_TimeEvent;
class Span_TimeEventDefaultTypeInternal;
extern Span_TimeEventDefaultTypeInternal _Span_TimeEvent_default_instance_;
class Span_TimeEvent_Annotation;
class Span_TimeEvent_AnnotationDefaultTypeInternal;
extern Span_TimeEvent_AnnotationDefaultTypeInternal _Span_TimeEvent_Annotation_default_instance_;
class Span_TimeEvent_Annotation_LabelsEntry_DoNotUse;
class Span_TimeEvent_Annotation_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Span_TimeEvent_Annotation_LabelsEntry_DoNotUseDefaultTypeInternal _Span_TimeEvent_Annotation_LabelsEntry_DoNotUse_default_instance_;
class Span_TimeEvent_NetworkEvent;
class Span_TimeEvent_NetworkEventDefaultTypeInternal;
extern Span_TimeEvent_NetworkEventDefaultTypeInternal _Span_TimeEvent_NetworkEvent_default_instance_;
class StackTrace;
class StackTraceDefaultTypeInternal;
extern StackTraceDefaultTypeInternal _StackTrace_default_instance_;
class StackTrace_StackFrame;
class StackTrace_StackFrameDefaultTypeInternal;
extern StackTrace_StackFrameDefaultTypeInternal _StackTrace_StackFrame_default_instance_;
class Trace;
class TraceDefaultTypeInternal;
extern TraceDefaultTypeInternal _Trace_default_instance_;
class TraceId;
class TraceIdDefaultTypeInternal;
extern TraceIdDefaultTypeInternal _TraceId_default_instance_;
}  // namespace v1
}  // namespace tracing
}  // namespace google
namespace google {
namespace tracing {
namespace v1 {

enum Span_TimeEvent_NetworkEvent_Type {
  Span_TimeEvent_NetworkEvent_Type_UNSPECIFIED = 0,
  Span_TimeEvent_NetworkEvent_Type_SENT = 1,
  Span_TimeEvent_NetworkEvent_Type_RECV = 2,
  Span_TimeEvent_NetworkEvent_Type_Span_TimeEvent_NetworkEvent_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Span_TimeEvent_NetworkEvent_Type_Span_TimeEvent_NetworkEvent_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Span_TimeEvent_NetworkEvent_Type_IsValid(int value);
const Span_TimeEvent_NetworkEvent_Type Span_TimeEvent_NetworkEvent_Type_Type_MIN = Span_TimeEvent_NetworkEvent_Type_UNSPECIFIED;
const Span_TimeEvent_NetworkEvent_Type Span_TimeEvent_NetworkEvent_Type_Type_MAX = Span_TimeEvent_NetworkEvent_Type_RECV;
const int Span_TimeEvent_NetworkEvent_Type_Type_ARRAYSIZE = Span_TimeEvent_NetworkEvent_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Span_TimeEvent_NetworkEvent_Type_descriptor();
inline const ::std::string& Span_TimeEvent_NetworkEvent_Type_Name(Span_TimeEvent_NetworkEvent_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Span_TimeEvent_NetworkEvent_Type_descriptor(), value);
}
inline bool Span_TimeEvent_NetworkEvent_Type_Parse(
    const ::std::string& name, Span_TimeEvent_NetworkEvent_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Span_TimeEvent_NetworkEvent_Type>(
    Span_TimeEvent_NetworkEvent_Type_descriptor(), name, value);
}
enum Span_Link_Type {
  Span_Link_Type_UNSPECIFIED = 0,
  Span_Link_Type_CHILD = 1,
  Span_Link_Type_PARENT = 2,
  Span_Link_Type_Span_Link_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Span_Link_Type_Span_Link_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Span_Link_Type_IsValid(int value);
const Span_Link_Type Span_Link_Type_Type_MIN = Span_Link_Type_UNSPECIFIED;
const Span_Link_Type Span_Link_Type_Type_MAX = Span_Link_Type_PARENT;
const int Span_Link_Type_Type_ARRAYSIZE = Span_Link_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Span_Link_Type_descriptor();
inline const ::std::string& Span_Link_Type_Name(Span_Link_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Span_Link_Type_descriptor(), value);
}
inline bool Span_Link_Type_Parse(
    const ::std::string& name, Span_Link_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Span_Link_Type>(
    Span_Link_Type_descriptor(), name, value);
}
// ===================================================================

class TraceId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.TraceId) */ {
 public:
  TraceId();
  virtual ~TraceId();

  TraceId(const TraceId& from);

  inline TraceId& operator=(const TraceId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TraceId(TraceId&& from) noexcept
    : TraceId() {
    *this = ::std::move(from);
  }

  inline TraceId& operator=(TraceId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TraceId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TraceId* internal_default_instance() {
    return reinterpret_cast<const TraceId*>(
               &_TraceId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TraceId* other);
  friend void swap(TraceId& a, TraceId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TraceId* New() const PROTOBUF_FINAL { return New(NULL); }

  TraceId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TraceId& from);
  void MergeFrom(const TraceId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TraceId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hex_encoded = 1;
  void clear_hex_encoded();
  static const int kHexEncodedFieldNumber = 1;
  const ::std::string& hex_encoded() const;
  void set_hex_encoded(const ::std::string& value);
  #if LANG_CXX11
  void set_hex_encoded(::std::string&& value);
  #endif
  void set_hex_encoded(const char* value);
  void set_hex_encoded(const char* value, size_t size);
  ::std::string* mutable_hex_encoded();
  ::std::string* release_hex_encoded();
  void set_allocated_hex_encoded(::std::string* hex_encoded);

  // @@protoc_insertion_point(class_scope:google.tracing.v1.TraceId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hex_encoded_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsTraceIdImpl();
};
// -------------------------------------------------------------------

class Module : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.Module) */ {
 public:
  Module();
  virtual ~Module();

  Module(const Module& from);

  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Module(Module&& from) noexcept
    : Module() {
    *this = ::std::move(from);
  }

  inline Module& operator=(Module&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Module& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Module* internal_default_instance() {
    return reinterpret_cast<const Module*>(
               &_Module_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Module* other);
  friend void swap(Module& a, Module& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Module* New() const PROTOBUF_FINAL { return New(NULL); }

  Module* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Module& from);
  void MergeFrom(const Module& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Module* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string module = 1;
  void clear_module();
  static const int kModuleFieldNumber = 1;
  const ::std::string& module() const;
  void set_module(const ::std::string& value);
  #if LANG_CXX11
  void set_module(::std::string&& value);
  #endif
  void set_module(const char* value);
  void set_module(const char* value, size_t size);
  ::std::string* mutable_module();
  ::std::string* release_module();
  void set_allocated_module(::std::string* module);

  // string build_id = 2;
  void clear_build_id();
  static const int kBuildIdFieldNumber = 2;
  const ::std::string& build_id() const;
  void set_build_id(const ::std::string& value);
  #if LANG_CXX11
  void set_build_id(::std::string&& value);
  #endif
  void set_build_id(const char* value);
  void set_build_id(const char* value, size_t size);
  ::std::string* mutable_build_id();
  ::std::string* release_build_id();
  void set_allocated_build_id(::std::string* build_id);

  // @@protoc_insertion_point(class_scope:google.tracing.v1.Module)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr module_;
  ::google::protobuf::internal::ArenaStringPtr build_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsModuleImpl();
};
// -------------------------------------------------------------------

class StackTrace_StackFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.StackTrace.StackFrame) */ {
 public:
  StackTrace_StackFrame();
  virtual ~StackTrace_StackFrame();

  StackTrace_StackFrame(const StackTrace_StackFrame& from);

  inline StackTrace_StackFrame& operator=(const StackTrace_StackFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StackTrace_StackFrame(StackTrace_StackFrame&& from) noexcept
    : StackTrace_StackFrame() {
    *this = ::std::move(from);
  }

  inline StackTrace_StackFrame& operator=(StackTrace_StackFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StackTrace_StackFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StackTrace_StackFrame* internal_default_instance() {
    return reinterpret_cast<const StackTrace_StackFrame*>(
               &_StackTrace_StackFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(StackTrace_StackFrame* other);
  friend void swap(StackTrace_StackFrame& a, StackTrace_StackFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StackTrace_StackFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  StackTrace_StackFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StackTrace_StackFrame& from);
  void MergeFrom(const StackTrace_StackFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StackTrace_StackFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string function_name = 1;
  void clear_function_name();
  static const int kFunctionNameFieldNumber = 1;
  const ::std::string& function_name() const;
  void set_function_name(const ::std::string& value);
  #if LANG_CXX11
  void set_function_name(::std::string&& value);
  #endif
  void set_function_name(const char* value);
  void set_function_name(const char* value, size_t size);
  ::std::string* mutable_function_name();
  ::std::string* release_function_name();
  void set_allocated_function_name(::std::string* function_name);

  // string orig_function_name = 2;
  void clear_orig_function_name();
  static const int kOrigFunctionNameFieldNumber = 2;
  const ::std::string& orig_function_name() const;
  void set_orig_function_name(const ::std::string& value);
  #if LANG_CXX11
  void set_orig_function_name(::std::string&& value);
  #endif
  void set_orig_function_name(const char* value);
  void set_orig_function_name(const char* value, size_t size);
  ::std::string* mutable_orig_function_name();
  ::std::string* release_orig_function_name();
  void set_allocated_orig_function_name(::std::string* orig_function_name);

  // string file_name = 3;
  void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // string source_version = 7;
  void clear_source_version();
  static const int kSourceVersionFieldNumber = 7;
  const ::std::string& source_version() const;
  void set_source_version(const ::std::string& value);
  #if LANG_CXX11
  void set_source_version(::std::string&& value);
  #endif
  void set_source_version(const char* value);
  void set_source_version(const char* value, size_t size);
  ::std::string* mutable_source_version();
  ::std::string* release_source_version();
  void set_allocated_source_version(::std::string* source_version);

  // .google.tracing.v1.Module load_module = 6;
  bool has_load_module() const;
  void clear_load_module();
  static const int kLoadModuleFieldNumber = 6;
  const ::google::tracing::v1::Module& load_module() const;
  ::google::tracing::v1::Module* release_load_module();
  ::google::tracing::v1::Module* mutable_load_module();
  void set_allocated_load_module(::google::tracing::v1::Module* load_module);

  // int64 line_number = 4;
  void clear_line_number();
  static const int kLineNumberFieldNumber = 4;
  ::google::protobuf::int64 line_number() const;
  void set_line_number(::google::protobuf::int64 value);

  // int64 column_number = 5;
  void clear_column_number();
  static const int kColumnNumberFieldNumber = 5;
  ::google::protobuf::int64 column_number() const;
  void set_column_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:google.tracing.v1.StackTrace.StackFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr function_name_;
  ::google::protobuf::internal::ArenaStringPtr orig_function_name_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::internal::ArenaStringPtr source_version_;
  ::google::tracing::v1::Module* load_module_;
  ::google::protobuf::int64 line_number_;
  ::google::protobuf::int64 column_number_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsStackTrace_StackFrameImpl();
};
// -------------------------------------------------------------------

class StackTrace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.StackTrace) */ {
 public:
  StackTrace();
  virtual ~StackTrace();

  StackTrace(const StackTrace& from);

  inline StackTrace& operator=(const StackTrace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StackTrace(StackTrace&& from) noexcept
    : StackTrace() {
    *this = ::std::move(from);
  }

  inline StackTrace& operator=(StackTrace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StackTrace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StackTrace* internal_default_instance() {
    return reinterpret_cast<const StackTrace*>(
               &_StackTrace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(StackTrace* other);
  friend void swap(StackTrace& a, StackTrace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StackTrace* New() const PROTOBUF_FINAL { return New(NULL); }

  StackTrace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StackTrace& from);
  void MergeFrom(const StackTrace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StackTrace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef StackTrace_StackFrame StackFrame;

  // accessors -------------------------------------------------------

  // repeated .google.tracing.v1.StackTrace.StackFrame stack_frame = 1;
  int stack_frame_size() const;
  void clear_stack_frame();
  static const int kStackFrameFieldNumber = 1;
  const ::google::tracing::v1::StackTrace_StackFrame& stack_frame(int index) const;
  ::google::tracing::v1::StackTrace_StackFrame* mutable_stack_frame(int index);
  ::google::tracing::v1::StackTrace_StackFrame* add_stack_frame();
  ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::StackTrace_StackFrame >*
      mutable_stack_frame();
  const ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::StackTrace_StackFrame >&
      stack_frame() const;

  // uint64 stack_trace_hash_id = 2;
  void clear_stack_trace_hash_id();
  static const int kStackTraceHashIdFieldNumber = 2;
  ::google::protobuf::uint64 stack_trace_hash_id() const;
  void set_stack_trace_hash_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:google.tracing.v1.StackTrace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::StackTrace_StackFrame > stack_frame_;
  ::google::protobuf::uint64 stack_trace_hash_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsStackTraceImpl();
};
// -------------------------------------------------------------------

class LabelValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.LabelValue) */ {
 public:
  LabelValue();
  virtual ~LabelValue();

  LabelValue(const LabelValue& from);

  inline LabelValue& operator=(const LabelValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LabelValue(LabelValue&& from) noexcept
    : LabelValue() {
    *this = ::std::move(from);
  }

  inline LabelValue& operator=(LabelValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LabelValue& default_instance();

  enum ValueCase {
    kStringValue = 1,
    kIntValue = 2,
    kBoolValue = 3,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LabelValue* internal_default_instance() {
    return reinterpret_cast<const LabelValue*>(
               &_LabelValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LabelValue* other);
  friend void swap(LabelValue& a, LabelValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LabelValue* New() const PROTOBUF_FINAL { return New(NULL); }

  LabelValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LabelValue& from);
  void MergeFrom(const LabelValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LabelValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string string_value = 1;
  private:
  bool has_string_value() const;
  public:
  void clear_string_value();
  static const int kStringValueFieldNumber = 1;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  #if LANG_CXX11
  void set_string_value(::std::string&& value);
  #endif
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // int64 int_value = 2;
  private:
  bool has_int_value() const;
  public:
  void clear_int_value();
  static const int kIntValueFieldNumber = 2;
  ::google::protobuf::int64 int_value() const;
  void set_int_value(::google::protobuf::int64 value);

  // bool bool_value = 3;
  private:
  bool has_bool_value() const;
  public:
  void clear_bool_value();
  static const int kBoolValueFieldNumber = 3;
  bool bool_value() const;
  void set_bool_value(bool value);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:google.tracing.v1.LabelValue)
 private:
  void set_has_string_value();
  void set_has_int_value();
  void set_has_bool_value();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::internal::ArenaStringPtr string_value_;
    ::google::protobuf::int64 int_value_;
    bool bool_value_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsLabelValueImpl();
};
// -------------------------------------------------------------------

class Span_TimeEvent_Annotation_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Span_TimeEvent_Annotation_LabelsEntry_DoNotUse, 
    ::std::string, ::google::tracing::v1::LabelValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Span_TimeEvent_Annotation_LabelsEntry_DoNotUse, 
    ::std::string, ::google::tracing::v1::LabelValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Span_TimeEvent_Annotation_LabelsEntry_DoNotUse();
  Span_TimeEvent_Annotation_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Span_TimeEvent_Annotation_LabelsEntry_DoNotUse& other);
  static const Span_TimeEvent_Annotation_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Span_TimeEvent_Annotation_LabelsEntry_DoNotUse*>(&_Span_TimeEvent_Annotation_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Span_TimeEvent_Annotation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.Span.TimeEvent.Annotation) */ {
 public:
  Span_TimeEvent_Annotation();
  virtual ~Span_TimeEvent_Annotation();

  Span_TimeEvent_Annotation(const Span_TimeEvent_Annotation& from);

  inline Span_TimeEvent_Annotation& operator=(const Span_TimeEvent_Annotation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span_TimeEvent_Annotation(Span_TimeEvent_Annotation&& from) noexcept
    : Span_TimeEvent_Annotation() {
    *this = ::std::move(from);
  }

  inline Span_TimeEvent_Annotation& operator=(Span_TimeEvent_Annotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Span_TimeEvent_Annotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Span_TimeEvent_Annotation* internal_default_instance() {
    return reinterpret_cast<const Span_TimeEvent_Annotation*>(
               &_Span_TimeEvent_Annotation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Span_TimeEvent_Annotation* other);
  friend void swap(Span_TimeEvent_Annotation& a, Span_TimeEvent_Annotation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span_TimeEvent_Annotation* New() const PROTOBUF_FINAL { return New(NULL); }

  Span_TimeEvent_Annotation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Span_TimeEvent_Annotation& from);
  void MergeFrom(const Span_TimeEvent_Annotation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Span_TimeEvent_Annotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .google.tracing.v1.LabelValue> labels = 2;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::google::tracing::v1::LabelValue >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::google::tracing::v1::LabelValue >*
      mutable_labels();

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:google.tracing.v1.Span.TimeEvent.Annotation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Span_TimeEvent_Annotation_LabelsEntry_DoNotUse,
      ::std::string, ::google::tracing::v1::LabelValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > labels_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsSpan_TimeEvent_AnnotationImpl();
};
// -------------------------------------------------------------------

class Span_TimeEvent_NetworkEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.Span.TimeEvent.NetworkEvent) */ {
 public:
  Span_TimeEvent_NetworkEvent();
  virtual ~Span_TimeEvent_NetworkEvent();

  Span_TimeEvent_NetworkEvent(const Span_TimeEvent_NetworkEvent& from);

  inline Span_TimeEvent_NetworkEvent& operator=(const Span_TimeEvent_NetworkEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span_TimeEvent_NetworkEvent(Span_TimeEvent_NetworkEvent&& from) noexcept
    : Span_TimeEvent_NetworkEvent() {
    *this = ::std::move(from);
  }

  inline Span_TimeEvent_NetworkEvent& operator=(Span_TimeEvent_NetworkEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Span_TimeEvent_NetworkEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Span_TimeEvent_NetworkEvent* internal_default_instance() {
    return reinterpret_cast<const Span_TimeEvent_NetworkEvent*>(
               &_Span_TimeEvent_NetworkEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Span_TimeEvent_NetworkEvent* other);
  friend void swap(Span_TimeEvent_NetworkEvent& a, Span_TimeEvent_NetworkEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span_TimeEvent_NetworkEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  Span_TimeEvent_NetworkEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Span_TimeEvent_NetworkEvent& from);
  void MergeFrom(const Span_TimeEvent_NetworkEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Span_TimeEvent_NetworkEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Span_TimeEvent_NetworkEvent_Type Type;
  static const Type UNSPECIFIED =
    Span_TimeEvent_NetworkEvent_Type_UNSPECIFIED;
  static const Type SENT =
    Span_TimeEvent_NetworkEvent_Type_SENT;
  static const Type RECV =
    Span_TimeEvent_NetworkEvent_Type_RECV;
  static inline bool Type_IsValid(int value) {
    return Span_TimeEvent_NetworkEvent_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Span_TimeEvent_NetworkEvent_Type_Type_MIN;
  static const Type Type_MAX =
    Span_TimeEvent_NetworkEvent_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Span_TimeEvent_NetworkEvent_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Span_TimeEvent_NetworkEvent_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Span_TimeEvent_NetworkEvent_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Span_TimeEvent_NetworkEvent_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.protobuf.Timestamp kernel_time = 1;
  bool has_kernel_time() const;
  void clear_kernel_time();
  static const int kKernelTimeFieldNumber = 1;
  const ::google::protobuf::Timestamp& kernel_time() const;
  ::google::protobuf::Timestamp* release_kernel_time();
  ::google::protobuf::Timestamp* mutable_kernel_time();
  void set_allocated_kernel_time(::google::protobuf::Timestamp* kernel_time);

  // uint64 message_id = 3;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 3;
  ::google::protobuf::uint64 message_id() const;
  void set_message_id(::google::protobuf::uint64 value);

  // uint64 message_size = 4;
  void clear_message_size();
  static const int kMessageSizeFieldNumber = 4;
  ::google::protobuf::uint64 message_size() const;
  void set_message_size(::google::protobuf::uint64 value);

  // .google.tracing.v1.Span.TimeEvent.NetworkEvent.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::tracing::v1::Span_TimeEvent_NetworkEvent_Type type() const;
  void set_type(::google::tracing::v1::Span_TimeEvent_NetworkEvent_Type value);

  // @@protoc_insertion_point(class_scope:google.tracing.v1.Span.TimeEvent.NetworkEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Timestamp* kernel_time_;
  ::google::protobuf::uint64 message_id_;
  ::google::protobuf::uint64 message_size_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsSpan_TimeEvent_NetworkEventImpl();
};
// -------------------------------------------------------------------

class Span_TimeEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.Span.TimeEvent) */ {
 public:
  Span_TimeEvent();
  virtual ~Span_TimeEvent();

  Span_TimeEvent(const Span_TimeEvent& from);

  inline Span_TimeEvent& operator=(const Span_TimeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span_TimeEvent(Span_TimeEvent&& from) noexcept
    : Span_TimeEvent() {
    *this = ::std::move(from);
  }

  inline Span_TimeEvent& operator=(Span_TimeEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Span_TimeEvent& default_instance();

  enum ValueCase {
    kAnnotation = 2,
    kNetworkEvent = 3,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Span_TimeEvent* internal_default_instance() {
    return reinterpret_cast<const Span_TimeEvent*>(
               &_Span_TimeEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Span_TimeEvent* other);
  friend void swap(Span_TimeEvent& a, Span_TimeEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span_TimeEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  Span_TimeEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Span_TimeEvent& from);
  void MergeFrom(const Span_TimeEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Span_TimeEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Span_TimeEvent_Annotation Annotation;
  typedef Span_TimeEvent_NetworkEvent NetworkEvent;

  // accessors -------------------------------------------------------

  // .google.protobuf.Timestamp local_time = 1;
  bool has_local_time() const;
  void clear_local_time();
  static const int kLocalTimeFieldNumber = 1;
  const ::google::protobuf::Timestamp& local_time() const;
  ::google::protobuf::Timestamp* release_local_time();
  ::google::protobuf::Timestamp* mutable_local_time();
  void set_allocated_local_time(::google::protobuf::Timestamp* local_time);

  // .google.tracing.v1.Span.TimeEvent.Annotation annotation = 2;
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 2;
  const ::google::tracing::v1::Span_TimeEvent_Annotation& annotation() const;
  ::google::tracing::v1::Span_TimeEvent_Annotation* release_annotation();
  ::google::tracing::v1::Span_TimeEvent_Annotation* mutable_annotation();
  void set_allocated_annotation(::google::tracing::v1::Span_TimeEvent_Annotation* annotation);

  // .google.tracing.v1.Span.TimeEvent.NetworkEvent network_event = 3;
  bool has_network_event() const;
  void clear_network_event();
  static const int kNetworkEventFieldNumber = 3;
  const ::google::tracing::v1::Span_TimeEvent_NetworkEvent& network_event() const;
  ::google::tracing::v1::Span_TimeEvent_NetworkEvent* release_network_event();
  ::google::tracing::v1::Span_TimeEvent_NetworkEvent* mutable_network_event();
  void set_allocated_network_event(::google::tracing::v1::Span_TimeEvent_NetworkEvent* network_event);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:google.tracing.v1.Span.TimeEvent)
 private:
  void set_has_annotation();
  void set_has_network_event();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Timestamp* local_time_;
  union ValueUnion {
    ValueUnion() {}
    ::google::tracing::v1::Span_TimeEvent_Annotation* annotation_;
    ::google::tracing::v1::Span_TimeEvent_NetworkEvent* network_event_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsSpan_TimeEventImpl();
};
// -------------------------------------------------------------------

class Span_Link : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.Span.Link) */ {
 public:
  Span_Link();
  virtual ~Span_Link();

  Span_Link(const Span_Link& from);

  inline Span_Link& operator=(const Span_Link& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span_Link(Span_Link&& from) noexcept
    : Span_Link() {
    *this = ::std::move(from);
  }

  inline Span_Link& operator=(Span_Link&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Span_Link& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Span_Link* internal_default_instance() {
    return reinterpret_cast<const Span_Link*>(
               &_Span_Link_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Span_Link* other);
  friend void swap(Span_Link& a, Span_Link& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span_Link* New() const PROTOBUF_FINAL { return New(NULL); }

  Span_Link* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Span_Link& from);
  void MergeFrom(const Span_Link& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Span_Link* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Span_Link_Type Type;
  static const Type UNSPECIFIED =
    Span_Link_Type_UNSPECIFIED;
  static const Type CHILD =
    Span_Link_Type_CHILD;
  static const Type PARENT =
    Span_Link_Type_PARENT;
  static inline bool Type_IsValid(int value) {
    return Span_Link_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Span_Link_Type_Type_MIN;
  static const Type Type_MAX =
    Span_Link_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Span_Link_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Span_Link_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Span_Link_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Span_Link_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.tracing.v1.TraceId trace_id = 1;
  bool has_trace_id() const;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 1;
  const ::google::tracing::v1::TraceId& trace_id() const;
  ::google::tracing::v1::TraceId* release_trace_id();
  ::google::tracing::v1::TraceId* mutable_trace_id();
  void set_allocated_trace_id(::google::tracing::v1::TraceId* trace_id);

  // fixed64 span_id = 2;
  void clear_span_id();
  static const int kSpanIdFieldNumber = 2;
  ::google::protobuf::uint64 span_id() const;
  void set_span_id(::google::protobuf::uint64 value);

  // .google.tracing.v1.Span.Link.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::tracing::v1::Span_Link_Type type() const;
  void set_type(::google::tracing::v1::Span_Link_Type value);

  // @@protoc_insertion_point(class_scope:google.tracing.v1.Span.Link)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::tracing::v1::TraceId* trace_id_;
  ::google::protobuf::uint64 span_id_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsSpan_LinkImpl();
};
// -------------------------------------------------------------------

class Span_LabelsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Span_LabelsEntry_DoNotUse, 
    ::std::string, ::google::tracing::v1::LabelValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Span_LabelsEntry_DoNotUse, 
    ::std::string, ::google::tracing::v1::LabelValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Span_LabelsEntry_DoNotUse();
  Span_LabelsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Span_LabelsEntry_DoNotUse& other);
  static const Span_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Span_LabelsEntry_DoNotUse*>(&_Span_LabelsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Span : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.Span) */ {
 public:
  Span();
  virtual ~Span();

  Span(const Span& from);

  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span(Span&& from) noexcept
    : Span() {
    *this = ::std::move(from);
  }

  inline Span& operator=(Span&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Span& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Span* internal_default_instance() {
    return reinterpret_cast<const Span*>(
               &_Span_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Span* other);
  friend void swap(Span& a, Span& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span* New() const PROTOBUF_FINAL { return New(NULL); }

  Span* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Span& from);
  void MergeFrom(const Span& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Span* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Span_TimeEvent TimeEvent;
  typedef Span_Link Link;

  // accessors -------------------------------------------------------

  // map<string, .google.tracing.v1.LabelValue> labels = 6;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::google::tracing::v1::LabelValue >&
      labels() const;
  ::google::protobuf::Map< ::std::string, ::google::tracing::v1::LabelValue >*
      mutable_labels();

  // repeated .google.tracing.v1.Span.TimeEvent time_events = 8;
  int time_events_size() const;
  void clear_time_events();
  static const int kTimeEventsFieldNumber = 8;
  const ::google::tracing::v1::Span_TimeEvent& time_events(int index) const;
  ::google::tracing::v1::Span_TimeEvent* mutable_time_events(int index);
  ::google::tracing::v1::Span_TimeEvent* add_time_events();
  ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_TimeEvent >*
      mutable_time_events();
  const ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_TimeEvent >&
      time_events() const;

  // repeated .google.tracing.v1.Span.Link links = 9;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 9;
  const ::google::tracing::v1::Span_Link& links(int index) const;
  ::google::tracing::v1::Span_Link* mutable_links(int index);
  ::google::tracing::v1::Span_Link* add_links();
  ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_Link >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_Link >&
      links() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .google.protobuf.Timestamp local_start_time = 4;
  bool has_local_start_time() const;
  void clear_local_start_time();
  static const int kLocalStartTimeFieldNumber = 4;
  const ::google::protobuf::Timestamp& local_start_time() const;
  ::google::protobuf::Timestamp* release_local_start_time();
  ::google::protobuf::Timestamp* mutable_local_start_time();
  void set_allocated_local_start_time(::google::protobuf::Timestamp* local_start_time);

  // .google.protobuf.Timestamp local_end_time = 5;
  bool has_local_end_time() const;
  void clear_local_end_time();
  static const int kLocalEndTimeFieldNumber = 5;
  const ::google::protobuf::Timestamp& local_end_time() const;
  ::google::protobuf::Timestamp* release_local_end_time();
  ::google::protobuf::Timestamp* mutable_local_end_time();
  void set_allocated_local_end_time(::google::protobuf::Timestamp* local_end_time);

  // .google.tracing.v1.StackTrace stack_trace = 7;
  bool has_stack_trace() const;
  void clear_stack_trace();
  static const int kStackTraceFieldNumber = 7;
  const ::google::tracing::v1::StackTrace& stack_trace() const;
  ::google::tracing::v1::StackTrace* release_stack_trace();
  ::google::tracing::v1::StackTrace* mutable_stack_trace();
  void set_allocated_stack_trace(::google::tracing::v1::StackTrace* stack_trace);

  // .google.rpc.Status status = 10;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 10;
  const ::google::rpc::Status& status() const;
  ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);

  // fixed64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // fixed64 parent_id = 3;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 3;
  ::google::protobuf::uint64 parent_id() const;
  void set_parent_id(::google::protobuf::uint64 value);

  // bool has_remote_parent = 11;
  void clear_has_remote_parent();
  static const int kHasRemoteParentFieldNumber = 11;
  bool has_remote_parent() const;
  void set_has_remote_parent(bool value);

  // @@protoc_insertion_point(class_scope:google.tracing.v1.Span)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Span_LabelsEntry_DoNotUse,
      ::std::string, ::google::tracing::v1::LabelValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > labels_;
  ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_TimeEvent > time_events_;
  ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_Link > links_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::Timestamp* local_start_time_;
  ::google::protobuf::Timestamp* local_end_time_;
  ::google::tracing::v1::StackTrace* stack_trace_;
  ::google::rpc::Status* status_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 parent_id_;
  bool has_remote_parent_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsSpanImpl();
};
// -------------------------------------------------------------------

class Trace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.tracing.v1.Trace) */ {
 public:
  Trace();
  virtual ~Trace();

  Trace(const Trace& from);

  inline Trace& operator=(const Trace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trace(Trace&& from) noexcept
    : Trace() {
    *this = ::std::move(from);
  }

  inline Trace& operator=(Trace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trace* internal_default_instance() {
    return reinterpret_cast<const Trace*>(
               &_Trace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Trace* other);
  friend void swap(Trace& a, Trace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trace* New() const PROTOBUF_FINAL { return New(NULL); }

  Trace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Trace& from);
  void MergeFrom(const Trace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Trace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.tracing.v1.Span spans = 2;
  int spans_size() const;
  void clear_spans();
  static const int kSpansFieldNumber = 2;
  const ::google::tracing::v1::Span& spans(int index) const;
  ::google::tracing::v1::Span* mutable_spans(int index);
  ::google::tracing::v1::Span* add_spans();
  ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span >*
      mutable_spans();
  const ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span >&
      spans() const;

  // .google.tracing.v1.TraceId trace_id = 1;
  bool has_trace_id() const;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 1;
  const ::google::tracing::v1::TraceId& trace_id() const;
  ::google::tracing::v1::TraceId* release_trace_id();
  ::google::tracing::v1::TraceId* mutable_trace_id();
  void set_allocated_trace_id(::google::tracing::v1::TraceId* trace_id);

  // @@protoc_insertion_point(class_scope:google.tracing.v1.Trace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span > spans_;
  ::google::tracing::v1::TraceId* trace_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2ftracing_2ftrace_2eproto::TableStruct;
  friend void ::protobuf_google_2ftracing_2ftrace_2eproto::InitDefaultsTraceImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TraceId

// string hex_encoded = 1;
inline void TraceId::clear_hex_encoded() {
  hex_encoded_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TraceId::hex_encoded() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.TraceId.hex_encoded)
  return hex_encoded_.GetNoArena();
}
inline void TraceId::set_hex_encoded(const ::std::string& value) {
  
  hex_encoded_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.TraceId.hex_encoded)
}
#if LANG_CXX11
inline void TraceId::set_hex_encoded(::std::string&& value) {
  
  hex_encoded_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.TraceId.hex_encoded)
}
#endif
inline void TraceId::set_hex_encoded(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hex_encoded_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.TraceId.hex_encoded)
}
inline void TraceId::set_hex_encoded(const char* value, size_t size) {
  
  hex_encoded_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.TraceId.hex_encoded)
}
inline ::std::string* TraceId::mutable_hex_encoded() {
  
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.TraceId.hex_encoded)
  return hex_encoded_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceId::release_hex_encoded() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.TraceId.hex_encoded)
  
  return hex_encoded_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceId::set_allocated_hex_encoded(::std::string* hex_encoded) {
  if (hex_encoded != NULL) {
    
  } else {
    
  }
  hex_encoded_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hex_encoded);
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.TraceId.hex_encoded)
}

// -------------------------------------------------------------------

// Module

// string module = 1;
inline void Module::clear_module() {
  module_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Module::module() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Module.module)
  return module_.GetNoArena();
}
inline void Module::set_module(const ::std::string& value) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.Module.module)
}
#if LANG_CXX11
inline void Module::set_module(::std::string&& value) {
  
  module_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.Module.module)
}
#endif
inline void Module::set_module(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.Module.module)
}
inline void Module::set_module(const char* value, size_t size) {
  
  module_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.Module.module)
}
inline ::std::string* Module::mutable_module() {
  
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Module.module)
  return module_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Module::release_module() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Module.module)
  
  return module_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Module::set_allocated_module(::std::string* module) {
  if (module != NULL) {
    
  } else {
    
  }
  module_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module);
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Module.module)
}

// string build_id = 2;
inline void Module::clear_build_id() {
  build_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Module::build_id() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Module.build_id)
  return build_id_.GetNoArena();
}
inline void Module::set_build_id(const ::std::string& value) {
  
  build_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.Module.build_id)
}
#if LANG_CXX11
inline void Module::set_build_id(::std::string&& value) {
  
  build_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.Module.build_id)
}
#endif
inline void Module::set_build_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  build_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.Module.build_id)
}
inline void Module::set_build_id(const char* value, size_t size) {
  
  build_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.Module.build_id)
}
inline ::std::string* Module::mutable_build_id() {
  
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Module.build_id)
  return build_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Module::release_build_id() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Module.build_id)
  
  return build_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Module::set_allocated_build_id(::std::string* build_id) {
  if (build_id != NULL) {
    
  } else {
    
  }
  build_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_id);
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Module.build_id)
}

// -------------------------------------------------------------------

// StackTrace_StackFrame

// string function_name = 1;
inline void StackTrace_StackFrame::clear_function_name() {
  function_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StackTrace_StackFrame::function_name() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.StackTrace.StackFrame.function_name)
  return function_name_.GetNoArena();
}
inline void StackTrace_StackFrame::set_function_name(const ::std::string& value) {
  
  function_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.StackTrace.StackFrame.function_name)
}
#if LANG_CXX11
inline void StackTrace_StackFrame::set_function_name(::std::string&& value) {
  
  function_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.StackTrace.StackFrame.function_name)
}
#endif
inline void StackTrace_StackFrame::set_function_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  function_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.StackTrace.StackFrame.function_name)
}
inline void StackTrace_StackFrame::set_function_name(const char* value, size_t size) {
  
  function_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.StackTrace.StackFrame.function_name)
}
inline ::std::string* StackTrace_StackFrame::mutable_function_name() {
  
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.StackTrace.StackFrame.function_name)
  return function_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StackTrace_StackFrame::release_function_name() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.StackTrace.StackFrame.function_name)
  
  return function_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StackTrace_StackFrame::set_allocated_function_name(::std::string* function_name) {
  if (function_name != NULL) {
    
  } else {
    
  }
  function_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), function_name);
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.StackTrace.StackFrame.function_name)
}

// string orig_function_name = 2;
inline void StackTrace_StackFrame::clear_orig_function_name() {
  orig_function_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StackTrace_StackFrame::orig_function_name() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.StackTrace.StackFrame.orig_function_name)
  return orig_function_name_.GetNoArena();
}
inline void StackTrace_StackFrame::set_orig_function_name(const ::std::string& value) {
  
  orig_function_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.StackTrace.StackFrame.orig_function_name)
}
#if LANG_CXX11
inline void StackTrace_StackFrame::set_orig_function_name(::std::string&& value) {
  
  orig_function_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.StackTrace.StackFrame.orig_function_name)
}
#endif
inline void StackTrace_StackFrame::set_orig_function_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  orig_function_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.StackTrace.StackFrame.orig_function_name)
}
inline void StackTrace_StackFrame::set_orig_function_name(const char* value, size_t size) {
  
  orig_function_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.StackTrace.StackFrame.orig_function_name)
}
inline ::std::string* StackTrace_StackFrame::mutable_orig_function_name() {
  
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.StackTrace.StackFrame.orig_function_name)
  return orig_function_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StackTrace_StackFrame::release_orig_function_name() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.StackTrace.StackFrame.orig_function_name)
  
  return orig_function_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StackTrace_StackFrame::set_allocated_orig_function_name(::std::string* orig_function_name) {
  if (orig_function_name != NULL) {
    
  } else {
    
  }
  orig_function_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), orig_function_name);
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.StackTrace.StackFrame.orig_function_name)
}

// string file_name = 3;
inline void StackTrace_StackFrame::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StackTrace_StackFrame::file_name() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.StackTrace.StackFrame.file_name)
  return file_name_.GetNoArena();
}
inline void StackTrace_StackFrame::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.StackTrace.StackFrame.file_name)
}
#if LANG_CXX11
inline void StackTrace_StackFrame::set_file_name(::std::string&& value) {
  
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.StackTrace.StackFrame.file_name)
}
#endif
inline void StackTrace_StackFrame::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.StackTrace.StackFrame.file_name)
}
inline void StackTrace_StackFrame::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.StackTrace.StackFrame.file_name)
}
inline ::std::string* StackTrace_StackFrame::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.StackTrace.StackFrame.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StackTrace_StackFrame::release_file_name() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.StackTrace.StackFrame.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StackTrace_StackFrame::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.StackTrace.StackFrame.file_name)
}

// int64 line_number = 4;
inline void StackTrace_StackFrame::clear_line_number() {
  line_number_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 StackTrace_StackFrame::line_number() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.StackTrace.StackFrame.line_number)
  return line_number_;
}
inline void StackTrace_StackFrame::set_line_number(::google::protobuf::int64 value) {
  
  line_number_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.StackTrace.StackFrame.line_number)
}

// int64 column_number = 5;
inline void StackTrace_StackFrame::clear_column_number() {
  column_number_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 StackTrace_StackFrame::column_number() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.StackTrace.StackFrame.column_number)
  return column_number_;
}
inline void StackTrace_StackFrame::set_column_number(::google::protobuf::int64 value) {
  
  column_number_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.StackTrace.StackFrame.column_number)
}

// .google.tracing.v1.Module load_module = 6;
inline bool StackTrace_StackFrame::has_load_module() const {
  return this != internal_default_instance() && load_module_ != NULL;
}
inline void StackTrace_StackFrame::clear_load_module() {
  if (GetArenaNoVirtual() == NULL && load_module_ != NULL) {
    delete load_module_;
  }
  load_module_ = NULL;
}
inline const ::google::tracing::v1::Module& StackTrace_StackFrame::load_module() const {
  const ::google::tracing::v1::Module* p = load_module_;
  // @@protoc_insertion_point(field_get:google.tracing.v1.StackTrace.StackFrame.load_module)
  return p != NULL ? *p : *reinterpret_cast<const ::google::tracing::v1::Module*>(
      &::google::tracing::v1::_Module_default_instance_);
}
inline ::google::tracing::v1::Module* StackTrace_StackFrame::release_load_module() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.StackTrace.StackFrame.load_module)
  
  ::google::tracing::v1::Module* temp = load_module_;
  load_module_ = NULL;
  return temp;
}
inline ::google::tracing::v1::Module* StackTrace_StackFrame::mutable_load_module() {
  
  if (load_module_ == NULL) {
    load_module_ = new ::google::tracing::v1::Module;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.StackTrace.StackFrame.load_module)
  return load_module_;
}
inline void StackTrace_StackFrame::set_allocated_load_module(::google::tracing::v1::Module* load_module) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete load_module_;
  }
  if (load_module) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      load_module = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, load_module, submessage_arena);
    }
    
  } else {
    
  }
  load_module_ = load_module;
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.StackTrace.StackFrame.load_module)
}

// string source_version = 7;
inline void StackTrace_StackFrame::clear_source_version() {
  source_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StackTrace_StackFrame::source_version() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.StackTrace.StackFrame.source_version)
  return source_version_.GetNoArena();
}
inline void StackTrace_StackFrame::set_source_version(const ::std::string& value) {
  
  source_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.StackTrace.StackFrame.source_version)
}
#if LANG_CXX11
inline void StackTrace_StackFrame::set_source_version(::std::string&& value) {
  
  source_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.StackTrace.StackFrame.source_version)
}
#endif
inline void StackTrace_StackFrame::set_source_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.StackTrace.StackFrame.source_version)
}
inline void StackTrace_StackFrame::set_source_version(const char* value, size_t size) {
  
  source_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.StackTrace.StackFrame.source_version)
}
inline ::std::string* StackTrace_StackFrame::mutable_source_version() {
  
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.StackTrace.StackFrame.source_version)
  return source_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StackTrace_StackFrame::release_source_version() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.StackTrace.StackFrame.source_version)
  
  return source_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StackTrace_StackFrame::set_allocated_source_version(::std::string* source_version) {
  if (source_version != NULL) {
    
  } else {
    
  }
  source_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_version);
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.StackTrace.StackFrame.source_version)
}

// -------------------------------------------------------------------

// StackTrace

// repeated .google.tracing.v1.StackTrace.StackFrame stack_frame = 1;
inline int StackTrace::stack_frame_size() const {
  return stack_frame_.size();
}
inline void StackTrace::clear_stack_frame() {
  stack_frame_.Clear();
}
inline const ::google::tracing::v1::StackTrace_StackFrame& StackTrace::stack_frame(int index) const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.StackTrace.stack_frame)
  return stack_frame_.Get(index);
}
inline ::google::tracing::v1::StackTrace_StackFrame* StackTrace::mutable_stack_frame(int index) {
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.StackTrace.stack_frame)
  return stack_frame_.Mutable(index);
}
inline ::google::tracing::v1::StackTrace_StackFrame* StackTrace::add_stack_frame() {
  // @@protoc_insertion_point(field_add:google.tracing.v1.StackTrace.stack_frame)
  return stack_frame_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::StackTrace_StackFrame >*
StackTrace::mutable_stack_frame() {
  // @@protoc_insertion_point(field_mutable_list:google.tracing.v1.StackTrace.stack_frame)
  return &stack_frame_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::StackTrace_StackFrame >&
StackTrace::stack_frame() const {
  // @@protoc_insertion_point(field_list:google.tracing.v1.StackTrace.stack_frame)
  return stack_frame_;
}

// uint64 stack_trace_hash_id = 2;
inline void StackTrace::clear_stack_trace_hash_id() {
  stack_trace_hash_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StackTrace::stack_trace_hash_id() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.StackTrace.stack_trace_hash_id)
  return stack_trace_hash_id_;
}
inline void StackTrace::set_stack_trace_hash_id(::google::protobuf::uint64 value) {
  
  stack_trace_hash_id_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.StackTrace.stack_trace_hash_id)
}

// -------------------------------------------------------------------

// LabelValue

// string string_value = 1;
inline bool LabelValue::has_string_value() const {
  return value_case() == kStringValue;
}
inline void LabelValue::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void LabelValue::clear_string_value() {
  if (has_string_value()) {
    value_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& LabelValue::string_value() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.LabelValue.string_value)
  if (has_string_value()) {
    return value_.string_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void LabelValue::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.tracing.v1.LabelValue.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.LabelValue.string_value)
}
#if LANG_CXX11
inline void LabelValue::set_string_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.tracing.v1.LabelValue.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.LabelValue.string_value)
}
#endif
inline void LabelValue::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.LabelValue.string_value)
}
inline void LabelValue::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.LabelValue.string_value)
}
inline ::std::string* LabelValue::mutable_string_value() {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.LabelValue.string_value)
  return value_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LabelValue::release_string_value() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.LabelValue.string_value)
  if (has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void LabelValue::set_allocated_string_value(::std::string* string_value) {
  if (!has_string_value()) {
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (string_value != NULL) {
    set_has_string_value();
    value_.string_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.LabelValue.string_value)
}

// int64 int_value = 2;
inline bool LabelValue::has_int_value() const {
  return value_case() == kIntValue;
}
inline void LabelValue::set_has_int_value() {
  _oneof_case_[0] = kIntValue;
}
inline void LabelValue::clear_int_value() {
  if (has_int_value()) {
    value_.int_value_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 LabelValue::int_value() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.LabelValue.int_value)
  if (has_int_value()) {
    return value_.int_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void LabelValue::set_int_value(::google::protobuf::int64 value) {
  if (!has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  value_.int_value_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.LabelValue.int_value)
}

// bool bool_value = 3;
inline bool LabelValue::has_bool_value() const {
  return value_case() == kBoolValue;
}
inline void LabelValue::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void LabelValue::clear_bool_value() {
  if (has_bool_value()) {
    value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool LabelValue::bool_value() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.LabelValue.bool_value)
  if (has_bool_value()) {
    return value_.bool_value_;
  }
  return false;
}
inline void LabelValue::set_bool_value(bool value) {
  if (!has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  value_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.LabelValue.bool_value)
}

inline bool LabelValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void LabelValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline LabelValue::ValueCase LabelValue::value_case() const {
  return LabelValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Span_TimeEvent_Annotation

// string description = 1;
inline void Span_TimeEvent_Annotation::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span_TimeEvent_Annotation::description() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.TimeEvent.Annotation.description)
  return description_.GetNoArena();
}
inline void Span_TimeEvent_Annotation::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.TimeEvent.Annotation.description)
}
#if LANG_CXX11
inline void Span_TimeEvent_Annotation::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.Span.TimeEvent.Annotation.description)
}
#endif
inline void Span_TimeEvent_Annotation::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.Span.TimeEvent.Annotation.description)
}
inline void Span_TimeEvent_Annotation::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.Span.TimeEvent.Annotation.description)
}
inline ::std::string* Span_TimeEvent_Annotation::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.TimeEvent.Annotation.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span_TimeEvent_Annotation::release_description() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.TimeEvent.Annotation.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span_TimeEvent_Annotation::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Span.TimeEvent.Annotation.description)
}

// map<string, .google.tracing.v1.LabelValue> labels = 2;
inline int Span_TimeEvent_Annotation::labels_size() const {
  return labels_.size();
}
inline void Span_TimeEvent_Annotation::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::tracing::v1::LabelValue >&
Span_TimeEvent_Annotation::labels() const {
  // @@protoc_insertion_point(field_map:google.tracing.v1.Span.TimeEvent.Annotation.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::tracing::v1::LabelValue >*
Span_TimeEvent_Annotation::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:google.tracing.v1.Span.TimeEvent.Annotation.labels)
  return labels_.MutableMap();
}

// -------------------------------------------------------------------

// Span_TimeEvent_NetworkEvent

// .google.protobuf.Timestamp kernel_time = 1;
inline bool Span_TimeEvent_NetworkEvent::has_kernel_time() const {
  return this != internal_default_instance() && kernel_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Span_TimeEvent_NetworkEvent::kernel_time() const {
  const ::google::protobuf::Timestamp* p = kernel_time_;
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.TimeEvent.NetworkEvent.kernel_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Span_TimeEvent_NetworkEvent::release_kernel_time() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.TimeEvent.NetworkEvent.kernel_time)
  
  ::google::protobuf::Timestamp* temp = kernel_time_;
  kernel_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Span_TimeEvent_NetworkEvent::mutable_kernel_time() {
  
  if (kernel_time_ == NULL) {
    kernel_time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.TimeEvent.NetworkEvent.kernel_time)
  return kernel_time_;
}
inline void Span_TimeEvent_NetworkEvent::set_allocated_kernel_time(::google::protobuf::Timestamp* kernel_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(kernel_time_);
  }
  if (kernel_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(kernel_time)->GetArena();
    if (message_arena != submessage_arena) {
      kernel_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kernel_time, submessage_arena);
    }
    
  } else {
    
  }
  kernel_time_ = kernel_time;
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Span.TimeEvent.NetworkEvent.kernel_time)
}

// .google.tracing.v1.Span.TimeEvent.NetworkEvent.Type type = 2;
inline void Span_TimeEvent_NetworkEvent::clear_type() {
  type_ = 0;
}
inline ::google::tracing::v1::Span_TimeEvent_NetworkEvent_Type Span_TimeEvent_NetworkEvent::type() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.TimeEvent.NetworkEvent.type)
  return static_cast< ::google::tracing::v1::Span_TimeEvent_NetworkEvent_Type >(type_);
}
inline void Span_TimeEvent_NetworkEvent::set_type(::google::tracing::v1::Span_TimeEvent_NetworkEvent_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.TimeEvent.NetworkEvent.type)
}

// uint64 message_id = 3;
inline void Span_TimeEvent_NetworkEvent::clear_message_id() {
  message_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span_TimeEvent_NetworkEvent::message_id() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.TimeEvent.NetworkEvent.message_id)
  return message_id_;
}
inline void Span_TimeEvent_NetworkEvent::set_message_id(::google::protobuf::uint64 value) {
  
  message_id_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.TimeEvent.NetworkEvent.message_id)
}

// uint64 message_size = 4;
inline void Span_TimeEvent_NetworkEvent::clear_message_size() {
  message_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span_TimeEvent_NetworkEvent::message_size() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.TimeEvent.NetworkEvent.message_size)
  return message_size_;
}
inline void Span_TimeEvent_NetworkEvent::set_message_size(::google::protobuf::uint64 value) {
  
  message_size_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.TimeEvent.NetworkEvent.message_size)
}

// -------------------------------------------------------------------

// Span_TimeEvent

// .google.protobuf.Timestamp local_time = 1;
inline bool Span_TimeEvent::has_local_time() const {
  return this != internal_default_instance() && local_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Span_TimeEvent::local_time() const {
  const ::google::protobuf::Timestamp* p = local_time_;
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.TimeEvent.local_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Span_TimeEvent::release_local_time() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.TimeEvent.local_time)
  
  ::google::protobuf::Timestamp* temp = local_time_;
  local_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Span_TimeEvent::mutable_local_time() {
  
  if (local_time_ == NULL) {
    local_time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.TimeEvent.local_time)
  return local_time_;
}
inline void Span_TimeEvent::set_allocated_local_time(::google::protobuf::Timestamp* local_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(local_time_);
  }
  if (local_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(local_time)->GetArena();
    if (message_arena != submessage_arena) {
      local_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_time, submessage_arena);
    }
    
  } else {
    
  }
  local_time_ = local_time;
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Span.TimeEvent.local_time)
}

// .google.tracing.v1.Span.TimeEvent.Annotation annotation = 2;
inline bool Span_TimeEvent::has_annotation() const {
  return value_case() == kAnnotation;
}
inline void Span_TimeEvent::set_has_annotation() {
  _oneof_case_[0] = kAnnotation;
}
inline void Span_TimeEvent::clear_annotation() {
  if (has_annotation()) {
    delete value_.annotation_;
    clear_has_value();
  }
}
inline ::google::tracing::v1::Span_TimeEvent_Annotation* Span_TimeEvent::release_annotation() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.TimeEvent.annotation)
  if (has_annotation()) {
    clear_has_value();
      ::google::tracing::v1::Span_TimeEvent_Annotation* temp = value_.annotation_;
    value_.annotation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::tracing::v1::Span_TimeEvent_Annotation& Span_TimeEvent::annotation() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.TimeEvent.annotation)
  return has_annotation()
      ? *value_.annotation_
      : *reinterpret_cast< ::google::tracing::v1::Span_TimeEvent_Annotation*>(&::google::tracing::v1::_Span_TimeEvent_Annotation_default_instance_);
}
inline ::google::tracing::v1::Span_TimeEvent_Annotation* Span_TimeEvent::mutable_annotation() {
  if (!has_annotation()) {
    clear_value();
    set_has_annotation();
    value_.annotation_ = new ::google::tracing::v1::Span_TimeEvent_Annotation;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.TimeEvent.annotation)
  return value_.annotation_;
}

// .google.tracing.v1.Span.TimeEvent.NetworkEvent network_event = 3;
inline bool Span_TimeEvent::has_network_event() const {
  return value_case() == kNetworkEvent;
}
inline void Span_TimeEvent::set_has_network_event() {
  _oneof_case_[0] = kNetworkEvent;
}
inline void Span_TimeEvent::clear_network_event() {
  if (has_network_event()) {
    delete value_.network_event_;
    clear_has_value();
  }
}
inline ::google::tracing::v1::Span_TimeEvent_NetworkEvent* Span_TimeEvent::release_network_event() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.TimeEvent.network_event)
  if (has_network_event()) {
    clear_has_value();
      ::google::tracing::v1::Span_TimeEvent_NetworkEvent* temp = value_.network_event_;
    value_.network_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::tracing::v1::Span_TimeEvent_NetworkEvent& Span_TimeEvent::network_event() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.TimeEvent.network_event)
  return has_network_event()
      ? *value_.network_event_
      : *reinterpret_cast< ::google::tracing::v1::Span_TimeEvent_NetworkEvent*>(&::google::tracing::v1::_Span_TimeEvent_NetworkEvent_default_instance_);
}
inline ::google::tracing::v1::Span_TimeEvent_NetworkEvent* Span_TimeEvent::mutable_network_event() {
  if (!has_network_event()) {
    clear_value();
    set_has_network_event();
    value_.network_event_ = new ::google::tracing::v1::Span_TimeEvent_NetworkEvent;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.TimeEvent.network_event)
  return value_.network_event_;
}

inline bool Span_TimeEvent::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Span_TimeEvent::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Span_TimeEvent::ValueCase Span_TimeEvent::value_case() const {
  return Span_TimeEvent::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Span_Link

// .google.tracing.v1.TraceId trace_id = 1;
inline bool Span_Link::has_trace_id() const {
  return this != internal_default_instance() && trace_id_ != NULL;
}
inline void Span_Link::clear_trace_id() {
  if (GetArenaNoVirtual() == NULL && trace_id_ != NULL) {
    delete trace_id_;
  }
  trace_id_ = NULL;
}
inline const ::google::tracing::v1::TraceId& Span_Link::trace_id() const {
  const ::google::tracing::v1::TraceId* p = trace_id_;
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.Link.trace_id)
  return p != NULL ? *p : *reinterpret_cast<const ::google::tracing::v1::TraceId*>(
      &::google::tracing::v1::_TraceId_default_instance_);
}
inline ::google::tracing::v1::TraceId* Span_Link::release_trace_id() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.Link.trace_id)
  
  ::google::tracing::v1::TraceId* temp = trace_id_;
  trace_id_ = NULL;
  return temp;
}
inline ::google::tracing::v1::TraceId* Span_Link::mutable_trace_id() {
  
  if (trace_id_ == NULL) {
    trace_id_ = new ::google::tracing::v1::TraceId;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.Link.trace_id)
  return trace_id_;
}
inline void Span_Link::set_allocated_trace_id(::google::tracing::v1::TraceId* trace_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trace_id_;
  }
  if (trace_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trace_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trace_id, submessage_arena);
    }
    
  } else {
    
  }
  trace_id_ = trace_id;
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Span.Link.trace_id)
}

// fixed64 span_id = 2;
inline void Span_Link::clear_span_id() {
  span_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span_Link::span_id() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.Link.span_id)
  return span_id_;
}
inline void Span_Link::set_span_id(::google::protobuf::uint64 value) {
  
  span_id_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.Link.span_id)
}

// .google.tracing.v1.Span.Link.Type type = 3;
inline void Span_Link::clear_type() {
  type_ = 0;
}
inline ::google::tracing::v1::Span_Link_Type Span_Link::type() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.Link.type)
  return static_cast< ::google::tracing::v1::Span_Link_Type >(type_);
}
inline void Span_Link::set_type(::google::tracing::v1::Span_Link_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.Link.type)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Span

// fixed64 id = 1;
inline void Span::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span::id() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.id)
  return id_;
}
inline void Span::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.id)
}

// string name = 2;
inline void Span::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span::name() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.name)
  return name_.GetNoArena();
}
inline void Span::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.name)
}
#if LANG_CXX11
inline void Span::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.tracing.v1.Span.name)
}
#endif
inline void Span::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.tracing.v1.Span.name)
}
inline void Span::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.tracing.v1.Span.name)
}
inline ::std::string* Span::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_name() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Span.name)
}

// fixed64 parent_id = 3;
inline void Span::clear_parent_id() {
  parent_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span::parent_id() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.parent_id)
  return parent_id_;
}
inline void Span::set_parent_id(::google::protobuf::uint64 value) {
  
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.parent_id)
}

// .google.protobuf.Timestamp local_start_time = 4;
inline bool Span::has_local_start_time() const {
  return this != internal_default_instance() && local_start_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Span::local_start_time() const {
  const ::google::protobuf::Timestamp* p = local_start_time_;
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.local_start_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Span::release_local_start_time() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.local_start_time)
  
  ::google::protobuf::Timestamp* temp = local_start_time_;
  local_start_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Span::mutable_local_start_time() {
  
  if (local_start_time_ == NULL) {
    local_start_time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.local_start_time)
  return local_start_time_;
}
inline void Span::set_allocated_local_start_time(::google::protobuf::Timestamp* local_start_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(local_start_time_);
  }
  if (local_start_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(local_start_time)->GetArena();
    if (message_arena != submessage_arena) {
      local_start_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_start_time, submessage_arena);
    }
    
  } else {
    
  }
  local_start_time_ = local_start_time;
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Span.local_start_time)
}

// .google.protobuf.Timestamp local_end_time = 5;
inline bool Span::has_local_end_time() const {
  return this != internal_default_instance() && local_end_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& Span::local_end_time() const {
  const ::google::protobuf::Timestamp* p = local_end_time_;
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.local_end_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Span::release_local_end_time() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.local_end_time)
  
  ::google::protobuf::Timestamp* temp = local_end_time_;
  local_end_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Span::mutable_local_end_time() {
  
  if (local_end_time_ == NULL) {
    local_end_time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.local_end_time)
  return local_end_time_;
}
inline void Span::set_allocated_local_end_time(::google::protobuf::Timestamp* local_end_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(local_end_time_);
  }
  if (local_end_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(local_end_time)->GetArena();
    if (message_arena != submessage_arena) {
      local_end_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_end_time, submessage_arena);
    }
    
  } else {
    
  }
  local_end_time_ = local_end_time;
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Span.local_end_time)
}

// map<string, .google.tracing.v1.LabelValue> labels = 6;
inline int Span::labels_size() const {
  return labels_.size();
}
inline void Span::clear_labels() {
  labels_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::tracing::v1::LabelValue >&
Span::labels() const {
  // @@protoc_insertion_point(field_map:google.tracing.v1.Span.labels)
  return labels_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::tracing::v1::LabelValue >*
Span::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:google.tracing.v1.Span.labels)
  return labels_.MutableMap();
}

// .google.tracing.v1.StackTrace stack_trace = 7;
inline bool Span::has_stack_trace() const {
  return this != internal_default_instance() && stack_trace_ != NULL;
}
inline void Span::clear_stack_trace() {
  if (GetArenaNoVirtual() == NULL && stack_trace_ != NULL) {
    delete stack_trace_;
  }
  stack_trace_ = NULL;
}
inline const ::google::tracing::v1::StackTrace& Span::stack_trace() const {
  const ::google::tracing::v1::StackTrace* p = stack_trace_;
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.stack_trace)
  return p != NULL ? *p : *reinterpret_cast<const ::google::tracing::v1::StackTrace*>(
      &::google::tracing::v1::_StackTrace_default_instance_);
}
inline ::google::tracing::v1::StackTrace* Span::release_stack_trace() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.stack_trace)
  
  ::google::tracing::v1::StackTrace* temp = stack_trace_;
  stack_trace_ = NULL;
  return temp;
}
inline ::google::tracing::v1::StackTrace* Span::mutable_stack_trace() {
  
  if (stack_trace_ == NULL) {
    stack_trace_ = new ::google::tracing::v1::StackTrace;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.stack_trace)
  return stack_trace_;
}
inline void Span::set_allocated_stack_trace(::google::tracing::v1::StackTrace* stack_trace) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stack_trace_;
  }
  if (stack_trace) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stack_trace = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stack_trace, submessage_arena);
    }
    
  } else {
    
  }
  stack_trace_ = stack_trace;
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Span.stack_trace)
}

// repeated .google.tracing.v1.Span.TimeEvent time_events = 8;
inline int Span::time_events_size() const {
  return time_events_.size();
}
inline void Span::clear_time_events() {
  time_events_.Clear();
}
inline const ::google::tracing::v1::Span_TimeEvent& Span::time_events(int index) const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.time_events)
  return time_events_.Get(index);
}
inline ::google::tracing::v1::Span_TimeEvent* Span::mutable_time_events(int index) {
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.time_events)
  return time_events_.Mutable(index);
}
inline ::google::tracing::v1::Span_TimeEvent* Span::add_time_events() {
  // @@protoc_insertion_point(field_add:google.tracing.v1.Span.time_events)
  return time_events_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_TimeEvent >*
Span::mutable_time_events() {
  // @@protoc_insertion_point(field_mutable_list:google.tracing.v1.Span.time_events)
  return &time_events_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_TimeEvent >&
Span::time_events() const {
  // @@protoc_insertion_point(field_list:google.tracing.v1.Span.time_events)
  return time_events_;
}

// repeated .google.tracing.v1.Span.Link links = 9;
inline int Span::links_size() const {
  return links_.size();
}
inline void Span::clear_links() {
  links_.Clear();
}
inline const ::google::tracing::v1::Span_Link& Span::links(int index) const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.links)
  return links_.Get(index);
}
inline ::google::tracing::v1::Span_Link* Span::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.links)
  return links_.Mutable(index);
}
inline ::google::tracing::v1::Span_Link* Span::add_links() {
  // @@protoc_insertion_point(field_add:google.tracing.v1.Span.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_Link >*
Span::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:google.tracing.v1.Span.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span_Link >&
Span::links() const {
  // @@protoc_insertion_point(field_list:google.tracing.v1.Span.links)
  return links_;
}

// .google.rpc.Status status = 10;
inline bool Span::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline const ::google::rpc::Status& Span::status() const {
  const ::google::rpc::Status* p = status_;
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.status)
  return p != NULL ? *p : *reinterpret_cast<const ::google::rpc::Status*>(
      &::google::rpc::_Status_default_instance_);
}
inline ::google::rpc::Status* Span::release_status() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Span.status)
  
  ::google::rpc::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::google::rpc::Status* Span::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::google::rpc::Status;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Span.status)
  return status_;
}
inline void Span::set_allocated_status(::google::rpc::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Span.status)
}

// bool has_remote_parent = 11;
inline void Span::clear_has_remote_parent() {
  has_remote_parent_ = false;
}
inline bool Span::has_remote_parent() const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Span.has_remote_parent)
  return has_remote_parent_;
}
inline void Span::set_has_remote_parent(bool value) {
  
  has_remote_parent_ = value;
  // @@protoc_insertion_point(field_set:google.tracing.v1.Span.has_remote_parent)
}

// -------------------------------------------------------------------

// Trace

// .google.tracing.v1.TraceId trace_id = 1;
inline bool Trace::has_trace_id() const {
  return this != internal_default_instance() && trace_id_ != NULL;
}
inline void Trace::clear_trace_id() {
  if (GetArenaNoVirtual() == NULL && trace_id_ != NULL) {
    delete trace_id_;
  }
  trace_id_ = NULL;
}
inline const ::google::tracing::v1::TraceId& Trace::trace_id() const {
  const ::google::tracing::v1::TraceId* p = trace_id_;
  // @@protoc_insertion_point(field_get:google.tracing.v1.Trace.trace_id)
  return p != NULL ? *p : *reinterpret_cast<const ::google::tracing::v1::TraceId*>(
      &::google::tracing::v1::_TraceId_default_instance_);
}
inline ::google::tracing::v1::TraceId* Trace::release_trace_id() {
  // @@protoc_insertion_point(field_release:google.tracing.v1.Trace.trace_id)
  
  ::google::tracing::v1::TraceId* temp = trace_id_;
  trace_id_ = NULL;
  return temp;
}
inline ::google::tracing::v1::TraceId* Trace::mutable_trace_id() {
  
  if (trace_id_ == NULL) {
    trace_id_ = new ::google::tracing::v1::TraceId;
  }
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Trace.trace_id)
  return trace_id_;
}
inline void Trace::set_allocated_trace_id(::google::tracing::v1::TraceId* trace_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trace_id_;
  }
  if (trace_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trace_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trace_id, submessage_arena);
    }
    
  } else {
    
  }
  trace_id_ = trace_id;
  // @@protoc_insertion_point(field_set_allocated:google.tracing.v1.Trace.trace_id)
}

// repeated .google.tracing.v1.Span spans = 2;
inline int Trace::spans_size() const {
  return spans_.size();
}
inline void Trace::clear_spans() {
  spans_.Clear();
}
inline const ::google::tracing::v1::Span& Trace::spans(int index) const {
  // @@protoc_insertion_point(field_get:google.tracing.v1.Trace.spans)
  return spans_.Get(index);
}
inline ::google::tracing::v1::Span* Trace::mutable_spans(int index) {
  // @@protoc_insertion_point(field_mutable:google.tracing.v1.Trace.spans)
  return spans_.Mutable(index);
}
inline ::google::tracing::v1::Span* Trace::add_spans() {
  // @@protoc_insertion_point(field_add:google.tracing.v1.Trace.spans)
  return spans_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span >*
Trace::mutable_spans() {
  // @@protoc_insertion_point(field_mutable_list:google.tracing.v1.Trace.spans)
  return &spans_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::tracing::v1::Span >&
Trace::spans() const {
  // @@protoc_insertion_point(field_list:google.tracing.v1.Trace.spans)
  return spans_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace tracing
}  // namespace google

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::google::tracing::v1::Span_TimeEvent_NetworkEvent_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::tracing::v1::Span_TimeEvent_NetworkEvent_Type>() {
  return ::google::tracing::v1::Span_TimeEvent_NetworkEvent_Type_descriptor();
}
template <> struct is_proto_enum< ::google::tracing::v1::Span_Link_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::tracing::v1::Span_Link_Type>() {
  return ::google::tracing::v1::Span_Link_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_google_2ftracing_2ftrace_2eproto__INCLUDED
