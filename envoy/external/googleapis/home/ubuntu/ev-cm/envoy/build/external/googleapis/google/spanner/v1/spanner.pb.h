// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/spanner/v1/spanner.proto

#ifndef PROTOBUF_google_2fspanner_2fv1_2fspanner_2eproto__INCLUDED
#define PROTOBUF_google_2fspanner_2fv1_2fspanner_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/api/auth.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "google/spanner/v1/keys.pb.h"
#include "google/spanner/v1/mutation.pb.h"
#include "google/spanner/v1/result_set.pb.h"
#include "google/spanner/v1/transaction.pb.h"
#include "google/spanner/v1/type.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_google_2fspanner_2fv1_2fspanner_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsCreateSessionRequestImpl();
void InitDefaultsCreateSessionRequest();
void InitDefaultsSessionImpl();
void InitDefaultsSession();
void InitDefaultsGetSessionRequestImpl();
void InitDefaultsGetSessionRequest();
void InitDefaultsDeleteSessionRequestImpl();
void InitDefaultsDeleteSessionRequest();
void InitDefaultsExecuteSqlRequest_ParamTypesEntry_DoNotUseImpl();
void InitDefaultsExecuteSqlRequest_ParamTypesEntry_DoNotUse();
void InitDefaultsExecuteSqlRequestImpl();
void InitDefaultsExecuteSqlRequest();
void InitDefaultsReadRequestImpl();
void InitDefaultsReadRequest();
void InitDefaultsBeginTransactionRequestImpl();
void InitDefaultsBeginTransactionRequest();
void InitDefaultsCommitRequestImpl();
void InitDefaultsCommitRequest();
void InitDefaultsCommitResponseImpl();
void InitDefaultsCommitResponse();
void InitDefaultsRollbackRequestImpl();
void InitDefaultsRollbackRequest();
inline void InitDefaults() {
  InitDefaultsCreateSessionRequest();
  InitDefaultsSession();
  InitDefaultsGetSessionRequest();
  InitDefaultsDeleteSessionRequest();
  InitDefaultsExecuteSqlRequest_ParamTypesEntry_DoNotUse();
  InitDefaultsExecuteSqlRequest();
  InitDefaultsReadRequest();
  InitDefaultsBeginTransactionRequest();
  InitDefaultsCommitRequest();
  InitDefaultsCommitResponse();
  InitDefaultsRollbackRequest();
}
}  // namespace protobuf_google_2fspanner_2fv1_2fspanner_2eproto
namespace google {
namespace spanner {
namespace v1 {
class BeginTransactionRequest;
class BeginTransactionRequestDefaultTypeInternal;
extern BeginTransactionRequestDefaultTypeInternal _BeginTransactionRequest_default_instance_;
class CommitRequest;
class CommitRequestDefaultTypeInternal;
extern CommitRequestDefaultTypeInternal _CommitRequest_default_instance_;
class CommitResponse;
class CommitResponseDefaultTypeInternal;
extern CommitResponseDefaultTypeInternal _CommitResponse_default_instance_;
class CreateSessionRequest;
class CreateSessionRequestDefaultTypeInternal;
extern CreateSessionRequestDefaultTypeInternal _CreateSessionRequest_default_instance_;
class DeleteSessionRequest;
class DeleteSessionRequestDefaultTypeInternal;
extern DeleteSessionRequestDefaultTypeInternal _DeleteSessionRequest_default_instance_;
class ExecuteSqlRequest;
class ExecuteSqlRequestDefaultTypeInternal;
extern ExecuteSqlRequestDefaultTypeInternal _ExecuteSqlRequest_default_instance_;
class ExecuteSqlRequest_ParamTypesEntry_DoNotUse;
class ExecuteSqlRequest_ParamTypesEntry_DoNotUseDefaultTypeInternal;
extern ExecuteSqlRequest_ParamTypesEntry_DoNotUseDefaultTypeInternal _ExecuteSqlRequest_ParamTypesEntry_DoNotUse_default_instance_;
class GetSessionRequest;
class GetSessionRequestDefaultTypeInternal;
extern GetSessionRequestDefaultTypeInternal _GetSessionRequest_default_instance_;
class ReadRequest;
class ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class RollbackRequest;
class RollbackRequestDefaultTypeInternal;
extern RollbackRequestDefaultTypeInternal _RollbackRequest_default_instance_;
class Session;
class SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
}  // namespace v1
}  // namespace spanner
}  // namespace google
namespace google {
namespace spanner {
namespace v1 {

enum ExecuteSqlRequest_QueryMode {
  ExecuteSqlRequest_QueryMode_NORMAL = 0,
  ExecuteSqlRequest_QueryMode_PLAN = 1,
  ExecuteSqlRequest_QueryMode_PROFILE = 2,
  ExecuteSqlRequest_QueryMode_ExecuteSqlRequest_QueryMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExecuteSqlRequest_QueryMode_ExecuteSqlRequest_QueryMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExecuteSqlRequest_QueryMode_IsValid(int value);
const ExecuteSqlRequest_QueryMode ExecuteSqlRequest_QueryMode_QueryMode_MIN = ExecuteSqlRequest_QueryMode_NORMAL;
const ExecuteSqlRequest_QueryMode ExecuteSqlRequest_QueryMode_QueryMode_MAX = ExecuteSqlRequest_QueryMode_PROFILE;
const int ExecuteSqlRequest_QueryMode_QueryMode_ARRAYSIZE = ExecuteSqlRequest_QueryMode_QueryMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecuteSqlRequest_QueryMode_descriptor();
inline const ::std::string& ExecuteSqlRequest_QueryMode_Name(ExecuteSqlRequest_QueryMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecuteSqlRequest_QueryMode_descriptor(), value);
}
inline bool ExecuteSqlRequest_QueryMode_Parse(
    const ::std::string& name, ExecuteSqlRequest_QueryMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecuteSqlRequest_QueryMode>(
    ExecuteSqlRequest_QueryMode_descriptor(), name, value);
}
// ===================================================================

class CreateSessionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.CreateSessionRequest) */ {
 public:
  CreateSessionRequest();
  virtual ~CreateSessionRequest();

  CreateSessionRequest(const CreateSessionRequest& from);

  inline CreateSessionRequest& operator=(const CreateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateSessionRequest(CreateSessionRequest&& from) noexcept
    : CreateSessionRequest() {
    *this = ::std::move(from);
  }

  inline CreateSessionRequest& operator=(CreateSessionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateSessionRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSessionRequest*>(
               &_CreateSessionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CreateSessionRequest* other);
  friend void swap(CreateSessionRequest& a, CreateSessionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateSessionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateSessionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateSessionRequest& from);
  void MergeFrom(const CreateSessionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateSessionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string database = 1;
  void clear_database();
  static const int kDatabaseFieldNumber = 1;
  const ::std::string& database() const;
  void set_database(const ::std::string& value);
  #if LANG_CXX11
  void set_database(::std::string&& value);
  #endif
  void set_database(const char* value);
  void set_database(const char* value, size_t size);
  ::std::string* mutable_database();
  ::std::string* release_database();
  void set_allocated_database(::std::string* database);

  // @@protoc_insertion_point(class_scope:google.spanner.v1.CreateSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr database_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsCreateSessionRequestImpl();
};
// -------------------------------------------------------------------

class Session : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.Session) */ {
 public:
  Session();
  virtual ~Session();

  Session(const Session& from);

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(Session&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Session& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Session* other);
  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Session* New() const PROTOBUF_FINAL { return New(NULL); }

  Session* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Session* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:google.spanner.v1.Session)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsSessionImpl();
};
// -------------------------------------------------------------------

class GetSessionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.GetSessionRequest) */ {
 public:
  GetSessionRequest();
  virtual ~GetSessionRequest();

  GetSessionRequest(const GetSessionRequest& from);

  inline GetSessionRequest& operator=(const GetSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSessionRequest(GetSessionRequest&& from) noexcept
    : GetSessionRequest() {
    *this = ::std::move(from);
  }

  inline GetSessionRequest& operator=(GetSessionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSessionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSessionRequest* internal_default_instance() {
    return reinterpret_cast<const GetSessionRequest*>(
               &_GetSessionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GetSessionRequest* other);
  friend void swap(GetSessionRequest& a, GetSessionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSessionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetSessionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetSessionRequest& from);
  void MergeFrom(const GetSessionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetSessionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:google.spanner.v1.GetSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsGetSessionRequestImpl();
};
// -------------------------------------------------------------------

class DeleteSessionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.DeleteSessionRequest) */ {
 public:
  DeleteSessionRequest();
  virtual ~DeleteSessionRequest();

  DeleteSessionRequest(const DeleteSessionRequest& from);

  inline DeleteSessionRequest& operator=(const DeleteSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteSessionRequest(DeleteSessionRequest&& from) noexcept
    : DeleteSessionRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSessionRequest& operator=(DeleteSessionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteSessionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteSessionRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSessionRequest*>(
               &_DeleteSessionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DeleteSessionRequest* other);
  friend void swap(DeleteSessionRequest& a, DeleteSessionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteSessionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteSessionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteSessionRequest& from);
  void MergeFrom(const DeleteSessionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteSessionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:google.spanner.v1.DeleteSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsDeleteSessionRequestImpl();
};
// -------------------------------------------------------------------

class ExecuteSqlRequest_ParamTypesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ExecuteSqlRequest_ParamTypesEntry_DoNotUse, 
    ::std::string, ::google::spanner::v1::Type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ExecuteSqlRequest_ParamTypesEntry_DoNotUse, 
    ::std::string, ::google::spanner::v1::Type,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ExecuteSqlRequest_ParamTypesEntry_DoNotUse();
  ExecuteSqlRequest_ParamTypesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ExecuteSqlRequest_ParamTypesEntry_DoNotUse& other);
  static const ExecuteSqlRequest_ParamTypesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ExecuteSqlRequest_ParamTypesEntry_DoNotUse*>(&_ExecuteSqlRequest_ParamTypesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ExecuteSqlRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ExecuteSqlRequest) */ {
 public:
  ExecuteSqlRequest();
  virtual ~ExecuteSqlRequest();

  ExecuteSqlRequest(const ExecuteSqlRequest& from);

  inline ExecuteSqlRequest& operator=(const ExecuteSqlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteSqlRequest(ExecuteSqlRequest&& from) noexcept
    : ExecuteSqlRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteSqlRequest& operator=(ExecuteSqlRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteSqlRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteSqlRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteSqlRequest*>(
               &_ExecuteSqlRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ExecuteSqlRequest* other);
  friend void swap(ExecuteSqlRequest& a, ExecuteSqlRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteSqlRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ExecuteSqlRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExecuteSqlRequest& from);
  void MergeFrom(const ExecuteSqlRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExecuteSqlRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  typedef ExecuteSqlRequest_QueryMode QueryMode;
  static const QueryMode NORMAL =
    ExecuteSqlRequest_QueryMode_NORMAL;
  static const QueryMode PLAN =
    ExecuteSqlRequest_QueryMode_PLAN;
  static const QueryMode PROFILE =
    ExecuteSqlRequest_QueryMode_PROFILE;
  static inline bool QueryMode_IsValid(int value) {
    return ExecuteSqlRequest_QueryMode_IsValid(value);
  }
  static const QueryMode QueryMode_MIN =
    ExecuteSqlRequest_QueryMode_QueryMode_MIN;
  static const QueryMode QueryMode_MAX =
    ExecuteSqlRequest_QueryMode_QueryMode_MAX;
  static const int QueryMode_ARRAYSIZE =
    ExecuteSqlRequest_QueryMode_QueryMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QueryMode_descriptor() {
    return ExecuteSqlRequest_QueryMode_descriptor();
  }
  static inline const ::std::string& QueryMode_Name(QueryMode value) {
    return ExecuteSqlRequest_QueryMode_Name(value);
  }
  static inline bool QueryMode_Parse(const ::std::string& name,
      QueryMode* value) {
    return ExecuteSqlRequest_QueryMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // map<string, .google.spanner.v1.Type> param_types = 5;
  int param_types_size() const;
  void clear_param_types();
  static const int kParamTypesFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::google::spanner::v1::Type >&
      param_types() const;
  ::google::protobuf::Map< ::std::string, ::google::spanner::v1::Type >*
      mutable_param_types();

  // string session = 1;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  const ::std::string& session() const;
  void set_session(const ::std::string& value);
  #if LANG_CXX11
  void set_session(::std::string&& value);
  #endif
  void set_session(const char* value);
  void set_session(const char* value, size_t size);
  ::std::string* mutable_session();
  ::std::string* release_session();
  void set_allocated_session(::std::string* session);

  // string sql = 3;
  void clear_sql();
  static const int kSqlFieldNumber = 3;
  const ::std::string& sql() const;
  void set_sql(const ::std::string& value);
  #if LANG_CXX11
  void set_sql(::std::string&& value);
  #endif
  void set_sql(const char* value);
  void set_sql(const char* value, size_t size);
  ::std::string* mutable_sql();
  ::std::string* release_sql();
  void set_allocated_sql(::std::string* sql);

  // bytes resume_token = 6;
  void clear_resume_token();
  static const int kResumeTokenFieldNumber = 6;
  const ::std::string& resume_token() const;
  void set_resume_token(const ::std::string& value);
  #if LANG_CXX11
  void set_resume_token(::std::string&& value);
  #endif
  void set_resume_token(const char* value);
  void set_resume_token(const void* value, size_t size);
  ::std::string* mutable_resume_token();
  ::std::string* release_resume_token();
  void set_allocated_resume_token(::std::string* resume_token);

  // .google.spanner.v1.TransactionSelector transaction = 2;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 2;
  const ::google::spanner::v1::TransactionSelector& transaction() const;
  ::google::spanner::v1::TransactionSelector* release_transaction();
  ::google::spanner::v1::TransactionSelector* mutable_transaction();
  void set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction);

  // .google.protobuf.Struct params = 4;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 4;
  const ::google::protobuf::Struct& params() const;
  ::google::protobuf::Struct* release_params();
  ::google::protobuf::Struct* mutable_params();
  void set_allocated_params(::google::protobuf::Struct* params);

  // .google.spanner.v1.ExecuteSqlRequest.QueryMode query_mode = 7;
  void clear_query_mode();
  static const int kQueryModeFieldNumber = 7;
  ::google::spanner::v1::ExecuteSqlRequest_QueryMode query_mode() const;
  void set_query_mode(::google::spanner::v1::ExecuteSqlRequest_QueryMode value);

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ExecuteSqlRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ExecuteSqlRequest_ParamTypesEntry_DoNotUse,
      ::std::string, ::google::spanner::v1::Type,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > param_types_;
  ::google::protobuf::internal::ArenaStringPtr session_;
  ::google::protobuf::internal::ArenaStringPtr sql_;
  ::google::protobuf::internal::ArenaStringPtr resume_token_;
  ::google::spanner::v1::TransactionSelector* transaction_;
  ::google::protobuf::Struct* params_;
  int query_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsExecuteSqlRequestImpl();
};
// -------------------------------------------------------------------

class ReadRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.ReadRequest) */ {
 public:
  ReadRequest();
  virtual ~ReadRequest();

  ReadRequest(const ReadRequest& from);

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ReadRequest* other);
  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ReadRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReadRequest& from);
  void MergeFrom(const ReadRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReadRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string columns = 5;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 5;
  const ::std::string& columns(int index) const;
  ::std::string* mutable_columns(int index);
  void set_columns(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_columns(int index, ::std::string&& value);
  #endif
  void set_columns(int index, const char* value);
  void set_columns(int index, const char* value, size_t size);
  ::std::string* add_columns();
  void add_columns(const ::std::string& value);
  #if LANG_CXX11
  void add_columns(::std::string&& value);
  #endif
  void add_columns(const char* value);
  void add_columns(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& columns() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_columns();

  // string session = 1;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  const ::std::string& session() const;
  void set_session(const ::std::string& value);
  #if LANG_CXX11
  void set_session(::std::string&& value);
  #endif
  void set_session(const char* value);
  void set_session(const char* value, size_t size);
  ::std::string* mutable_session();
  ::std::string* release_session();
  void set_allocated_session(::std::string* session);

  // string table = 3;
  void clear_table();
  static const int kTableFieldNumber = 3;
  const ::std::string& table() const;
  void set_table(const ::std::string& value);
  #if LANG_CXX11
  void set_table(::std::string&& value);
  #endif
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  ::std::string* mutable_table();
  ::std::string* release_table();
  void set_allocated_table(::std::string* table);

  // string index = 4;
  void clear_index();
  static const int kIndexFieldNumber = 4;
  const ::std::string& index() const;
  void set_index(const ::std::string& value);
  #if LANG_CXX11
  void set_index(::std::string&& value);
  #endif
  void set_index(const char* value);
  void set_index(const char* value, size_t size);
  ::std::string* mutable_index();
  ::std::string* release_index();
  void set_allocated_index(::std::string* index);

  // bytes resume_token = 9;
  void clear_resume_token();
  static const int kResumeTokenFieldNumber = 9;
  const ::std::string& resume_token() const;
  void set_resume_token(const ::std::string& value);
  #if LANG_CXX11
  void set_resume_token(::std::string&& value);
  #endif
  void set_resume_token(const char* value);
  void set_resume_token(const void* value, size_t size);
  ::std::string* mutable_resume_token();
  ::std::string* release_resume_token();
  void set_allocated_resume_token(::std::string* resume_token);

  // .google.spanner.v1.TransactionSelector transaction = 2;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 2;
  const ::google::spanner::v1::TransactionSelector& transaction() const;
  ::google::spanner::v1::TransactionSelector* release_transaction();
  ::google::spanner::v1::TransactionSelector* mutable_transaction();
  void set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction);

  // .google.spanner.v1.KeySet key_set = 6;
  bool has_key_set() const;
  void clear_key_set();
  static const int kKeySetFieldNumber = 6;
  const ::google::spanner::v1::KeySet& key_set() const;
  ::google::spanner::v1::KeySet* release_key_set();
  ::google::spanner::v1::KeySet* mutable_key_set();
  void set_allocated_key_set(::google::spanner::v1::KeySet* key_set);

  // int64 limit = 8;
  void clear_limit();
  static const int kLimitFieldNumber = 8;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:google.spanner.v1.ReadRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> columns_;
  ::google::protobuf::internal::ArenaStringPtr session_;
  ::google::protobuf::internal::ArenaStringPtr table_;
  ::google::protobuf::internal::ArenaStringPtr index_;
  ::google::protobuf::internal::ArenaStringPtr resume_token_;
  ::google::spanner::v1::TransactionSelector* transaction_;
  ::google::spanner::v1::KeySet* key_set_;
  ::google::protobuf::int64 limit_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsReadRequestImpl();
};
// -------------------------------------------------------------------

class BeginTransactionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.BeginTransactionRequest) */ {
 public:
  BeginTransactionRequest();
  virtual ~BeginTransactionRequest();

  BeginTransactionRequest(const BeginTransactionRequest& from);

  inline BeginTransactionRequest& operator=(const BeginTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BeginTransactionRequest(BeginTransactionRequest&& from) noexcept
    : BeginTransactionRequest() {
    *this = ::std::move(from);
  }

  inline BeginTransactionRequest& operator=(BeginTransactionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BeginTransactionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BeginTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const BeginTransactionRequest*>(
               &_BeginTransactionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(BeginTransactionRequest* other);
  friend void swap(BeginTransactionRequest& a, BeginTransactionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BeginTransactionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BeginTransactionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BeginTransactionRequest& from);
  void MergeFrom(const BeginTransactionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BeginTransactionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session = 1;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  const ::std::string& session() const;
  void set_session(const ::std::string& value);
  #if LANG_CXX11
  void set_session(::std::string&& value);
  #endif
  void set_session(const char* value);
  void set_session(const char* value, size_t size);
  ::std::string* mutable_session();
  ::std::string* release_session();
  void set_allocated_session(::std::string* session);

  // .google.spanner.v1.TransactionOptions options = 2;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  const ::google::spanner::v1::TransactionOptions& options() const;
  ::google::spanner::v1::TransactionOptions* release_options();
  ::google::spanner::v1::TransactionOptions* mutable_options();
  void set_allocated_options(::google::spanner::v1::TransactionOptions* options);

  // @@protoc_insertion_point(class_scope:google.spanner.v1.BeginTransactionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_;
  ::google::spanner::v1::TransactionOptions* options_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsBeginTransactionRequestImpl();
};
// -------------------------------------------------------------------

class CommitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.CommitRequest) */ {
 public:
  CommitRequest();
  virtual ~CommitRequest();

  CommitRequest(const CommitRequest& from);

  inline CommitRequest& operator=(const CommitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommitRequest(CommitRequest&& from) noexcept
    : CommitRequest() {
    *this = ::std::move(from);
  }

  inline CommitRequest& operator=(CommitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommitRequest& default_instance();

  enum TransactionCase {
    kTransactionId = 2,
    kSingleUseTransaction = 3,
    TRANSACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommitRequest* internal_default_instance() {
    return reinterpret_cast<const CommitRequest*>(
               &_CommitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CommitRequest* other);
  friend void swap(CommitRequest& a, CommitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CommitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommitRequest& from);
  void MergeFrom(const CommitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.spanner.v1.Mutation mutations = 4;
  int mutations_size() const;
  void clear_mutations();
  static const int kMutationsFieldNumber = 4;
  const ::google::spanner::v1::Mutation& mutations(int index) const;
  ::google::spanner::v1::Mutation* mutable_mutations(int index);
  ::google::spanner::v1::Mutation* add_mutations();
  ::google::protobuf::RepeatedPtrField< ::google::spanner::v1::Mutation >*
      mutable_mutations();
  const ::google::protobuf::RepeatedPtrField< ::google::spanner::v1::Mutation >&
      mutations() const;

  // string session = 1;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  const ::std::string& session() const;
  void set_session(const ::std::string& value);
  #if LANG_CXX11
  void set_session(::std::string&& value);
  #endif
  void set_session(const char* value);
  void set_session(const char* value, size_t size);
  ::std::string* mutable_session();
  ::std::string* release_session();
  void set_allocated_session(::std::string* session);

  // bytes transaction_id = 2;
  private:
  bool has_transaction_id() const;
  public:
  void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 2;
  const ::std::string& transaction_id() const;
  void set_transaction_id(const ::std::string& value);
  #if LANG_CXX11
  void set_transaction_id(::std::string&& value);
  #endif
  void set_transaction_id(const char* value);
  void set_transaction_id(const void* value, size_t size);
  ::std::string* mutable_transaction_id();
  ::std::string* release_transaction_id();
  void set_allocated_transaction_id(::std::string* transaction_id);

  // .google.spanner.v1.TransactionOptions single_use_transaction = 3;
  bool has_single_use_transaction() const;
  void clear_single_use_transaction();
  static const int kSingleUseTransactionFieldNumber = 3;
  const ::google::spanner::v1::TransactionOptions& single_use_transaction() const;
  ::google::spanner::v1::TransactionOptions* release_single_use_transaction();
  ::google::spanner::v1::TransactionOptions* mutable_single_use_transaction();
  void set_allocated_single_use_transaction(::google::spanner::v1::TransactionOptions* single_use_transaction);

  TransactionCase transaction_case() const;
  // @@protoc_insertion_point(class_scope:google.spanner.v1.CommitRequest)
 private:
  void set_has_transaction_id();
  void set_has_single_use_transaction();

  inline bool has_transaction() const;
  void clear_transaction();
  inline void clear_has_transaction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::spanner::v1::Mutation > mutations_;
  ::google::protobuf::internal::ArenaStringPtr session_;
  union TransactionUnion {
    TransactionUnion() {}
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    ::google::spanner::v1::TransactionOptions* single_use_transaction_;
  } transaction_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsCommitRequestImpl();
};
// -------------------------------------------------------------------

class CommitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.CommitResponse) */ {
 public:
  CommitResponse();
  virtual ~CommitResponse();

  CommitResponse(const CommitResponse& from);

  inline CommitResponse& operator=(const CommitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommitResponse(CommitResponse&& from) noexcept
    : CommitResponse() {
    *this = ::std::move(from);
  }

  inline CommitResponse& operator=(CommitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommitResponse* internal_default_instance() {
    return reinterpret_cast<const CommitResponse*>(
               &_CommitResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CommitResponse* other);
  friend void swap(CommitResponse& a, CommitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommitResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CommitResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CommitResponse& from);
  void MergeFrom(const CommitResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CommitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Timestamp commit_timestamp = 1;
  bool has_commit_timestamp() const;
  void clear_commit_timestamp();
  static const int kCommitTimestampFieldNumber = 1;
  const ::google::protobuf::Timestamp& commit_timestamp() const;
  ::google::protobuf::Timestamp* release_commit_timestamp();
  ::google::protobuf::Timestamp* mutable_commit_timestamp();
  void set_allocated_commit_timestamp(::google::protobuf::Timestamp* commit_timestamp);

  // @@protoc_insertion_point(class_scope:google.spanner.v1.CommitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Timestamp* commit_timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsCommitResponseImpl();
};
// -------------------------------------------------------------------

class RollbackRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.spanner.v1.RollbackRequest) */ {
 public:
  RollbackRequest();
  virtual ~RollbackRequest();

  RollbackRequest(const RollbackRequest& from);

  inline RollbackRequest& operator=(const RollbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RollbackRequest(RollbackRequest&& from) noexcept
    : RollbackRequest() {
    *this = ::std::move(from);
  }

  inline RollbackRequest& operator=(RollbackRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RollbackRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RollbackRequest* internal_default_instance() {
    return reinterpret_cast<const RollbackRequest*>(
               &_RollbackRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RollbackRequest* other);
  friend void swap(RollbackRequest& a, RollbackRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RollbackRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RollbackRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RollbackRequest& from);
  void MergeFrom(const RollbackRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RollbackRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session = 1;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  const ::std::string& session() const;
  void set_session(const ::std::string& value);
  #if LANG_CXX11
  void set_session(::std::string&& value);
  #endif
  void set_session(const char* value);
  void set_session(const char* value, size_t size);
  ::std::string* mutable_session();
  ::std::string* release_session();
  void set_allocated_session(::std::string* session);

  // bytes transaction_id = 2;
  void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 2;
  const ::std::string& transaction_id() const;
  void set_transaction_id(const ::std::string& value);
  #if LANG_CXX11
  void set_transaction_id(::std::string&& value);
  #endif
  void set_transaction_id(const char* value);
  void set_transaction_id(const void* value, size_t size);
  ::std::string* mutable_transaction_id();
  ::std::string* release_transaction_id();
  void set_allocated_transaction_id(::std::string* transaction_id);

  // @@protoc_insertion_point(class_scope:google.spanner.v1.RollbackRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_;
  ::google::protobuf::internal::ArenaStringPtr transaction_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::TableStruct;
  friend void ::protobuf_google_2fspanner_2fv1_2fspanner_2eproto::InitDefaultsRollbackRequestImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateSessionRequest

// string database = 1;
inline void CreateSessionRequest::clear_database() {
  database_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateSessionRequest::database() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CreateSessionRequest.database)
  return database_.GetNoArena();
}
inline void CreateSessionRequest::set_database(const ::std::string& value) {
  
  database_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.CreateSessionRequest.database)
}
#if LANG_CXX11
inline void CreateSessionRequest::set_database(::std::string&& value) {
  
  database_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.CreateSessionRequest.database)
}
#endif
inline void CreateSessionRequest::set_database(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  database_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.CreateSessionRequest.database)
}
inline void CreateSessionRequest::set_database(const char* value, size_t size) {
  
  database_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.CreateSessionRequest.database)
}
inline ::std::string* CreateSessionRequest::mutable_database() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CreateSessionRequest.database)
  return database_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateSessionRequest::release_database() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CreateSessionRequest.database)
  
  return database_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateSessionRequest::set_allocated_database(::std::string* database) {
  if (database != NULL) {
    
  } else {
    
  }
  database_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), database);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.CreateSessionRequest.database)
}

// -------------------------------------------------------------------

// Session

// string name = 1;
inline void Session::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.Session.name)
  return name_.GetNoArena();
}
inline void Session::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.Session.name)
}
#if LANG_CXX11
inline void Session::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.Session.name)
}
#endif
inline void Session::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.Session.name)
}
inline void Session::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.Session.name)
}
inline ::std::string* Session::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.Session.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.Session.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.Session.name)
}

// -------------------------------------------------------------------

// GetSessionRequest

// string name = 1;
inline void GetSessionRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetSessionRequest::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.GetSessionRequest.name)
  return name_.GetNoArena();
}
inline void GetSessionRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.GetSessionRequest.name)
}
#if LANG_CXX11
inline void GetSessionRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.GetSessionRequest.name)
}
#endif
inline void GetSessionRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.GetSessionRequest.name)
}
inline void GetSessionRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.GetSessionRequest.name)
}
inline ::std::string* GetSessionRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.GetSessionRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSessionRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.GetSessionRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSessionRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.GetSessionRequest.name)
}

// -------------------------------------------------------------------

// DeleteSessionRequest

// string name = 1;
inline void DeleteSessionRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteSessionRequest::name() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.DeleteSessionRequest.name)
  return name_.GetNoArena();
}
inline void DeleteSessionRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.DeleteSessionRequest.name)
}
#if LANG_CXX11
inline void DeleteSessionRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.DeleteSessionRequest.name)
}
#endif
inline void DeleteSessionRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.DeleteSessionRequest.name)
}
inline void DeleteSessionRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.DeleteSessionRequest.name)
}
inline ::std::string* DeleteSessionRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.DeleteSessionRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteSessionRequest::release_name() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.DeleteSessionRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteSessionRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.DeleteSessionRequest.name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExecuteSqlRequest

// string session = 1;
inline void ExecuteSqlRequest::clear_session() {
  session_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecuteSqlRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.session)
  return session_.GetNoArena();
}
inline void ExecuteSqlRequest::set_session(const ::std::string& value) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.session)
}
#if LANG_CXX11
inline void ExecuteSqlRequest::set_session(::std::string&& value) {
  
  session_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.ExecuteSqlRequest.session)
}
#endif
inline void ExecuteSqlRequest::set_session(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.ExecuteSqlRequest.session)
}
inline void ExecuteSqlRequest::set_session(const char* value, size_t size) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.ExecuteSqlRequest.session)
}
inline ::std::string* ExecuteSqlRequest::mutable_session() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.session)
  return session_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecuteSqlRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.session)
  
  return session_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecuteSqlRequest::set_allocated_session(::std::string* session) {
  if (session != NULL) {
    
  } else {
    
  }
  session_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.session)
}

// .google.spanner.v1.TransactionSelector transaction = 2;
inline bool ExecuteSqlRequest::has_transaction() const {
  return this != internal_default_instance() && transaction_ != NULL;
}
inline const ::google::spanner::v1::TransactionSelector& ExecuteSqlRequest::transaction() const {
  const ::google::spanner::v1::TransactionSelector* p = transaction_;
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.transaction)
  return p != NULL ? *p : *reinterpret_cast<const ::google::spanner::v1::TransactionSelector*>(
      &::google::spanner::v1::_TransactionSelector_default_instance_);
}
inline ::google::spanner::v1::TransactionSelector* ExecuteSqlRequest::release_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.transaction)
  
  ::google::spanner::v1::TransactionSelector* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* ExecuteSqlRequest::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::google::spanner::v1::TransactionSelector;
  }
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.transaction)
  return transaction_;
}
inline void ExecuteSqlRequest::set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.transaction)
}

// string sql = 3;
inline void ExecuteSqlRequest::clear_sql() {
  sql_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecuteSqlRequest::sql() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.sql)
  return sql_.GetNoArena();
}
inline void ExecuteSqlRequest::set_sql(const ::std::string& value) {
  
  sql_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.sql)
}
#if LANG_CXX11
inline void ExecuteSqlRequest::set_sql(::std::string&& value) {
  
  sql_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.ExecuteSqlRequest.sql)
}
#endif
inline void ExecuteSqlRequest::set_sql(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sql_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.ExecuteSqlRequest.sql)
}
inline void ExecuteSqlRequest::set_sql(const char* value, size_t size) {
  
  sql_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.ExecuteSqlRequest.sql)
}
inline ::std::string* ExecuteSqlRequest::mutable_sql() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.sql)
  return sql_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecuteSqlRequest::release_sql() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.sql)
  
  return sql_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecuteSqlRequest::set_allocated_sql(::std::string* sql) {
  if (sql != NULL) {
    
  } else {
    
  }
  sql_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sql);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.sql)
}

// .google.protobuf.Struct params = 4;
inline bool ExecuteSqlRequest::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline const ::google::protobuf::Struct& ExecuteSqlRequest::params() const {
  const ::google::protobuf::Struct* p = params_;
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.params)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* ExecuteSqlRequest::release_params() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.params)
  
  ::google::protobuf::Struct* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::google::protobuf::Struct* ExecuteSqlRequest::mutable_params() {
  
  if (params_ == NULL) {
    params_ = new ::google::protobuf::Struct;
  }
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.params)
  return params_;
}
inline void ExecuteSqlRequest::set_allocated_params(::google::protobuf::Struct* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(params_);
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(params)->GetArena();
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.params)
}

// map<string, .google.spanner.v1.Type> param_types = 5;
inline int ExecuteSqlRequest::param_types_size() const {
  return param_types_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::google::spanner::v1::Type >&
ExecuteSqlRequest::param_types() const {
  // @@protoc_insertion_point(field_map:google.spanner.v1.ExecuteSqlRequest.param_types)
  return param_types_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::spanner::v1::Type >*
ExecuteSqlRequest::mutable_param_types() {
  // @@protoc_insertion_point(field_mutable_map:google.spanner.v1.ExecuteSqlRequest.param_types)
  return param_types_.MutableMap();
}

// bytes resume_token = 6;
inline void ExecuteSqlRequest::clear_resume_token() {
  resume_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExecuteSqlRequest::resume_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.resume_token)
  return resume_token_.GetNoArena();
}
inline void ExecuteSqlRequest::set_resume_token(const ::std::string& value) {
  
  resume_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.resume_token)
}
#if LANG_CXX11
inline void ExecuteSqlRequest::set_resume_token(::std::string&& value) {
  
  resume_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.ExecuteSqlRequest.resume_token)
}
#endif
inline void ExecuteSqlRequest::set_resume_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  resume_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.ExecuteSqlRequest.resume_token)
}
inline void ExecuteSqlRequest::set_resume_token(const void* value, size_t size) {
  
  resume_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.ExecuteSqlRequest.resume_token)
}
inline ::std::string* ExecuteSqlRequest::mutable_resume_token() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ExecuteSqlRequest.resume_token)
  return resume_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExecuteSqlRequest::release_resume_token() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ExecuteSqlRequest.resume_token)
  
  return resume_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExecuteSqlRequest::set_allocated_resume_token(::std::string* resume_token) {
  if (resume_token != NULL) {
    
  } else {
    
  }
  resume_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resume_token);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ExecuteSqlRequest.resume_token)
}

// .google.spanner.v1.ExecuteSqlRequest.QueryMode query_mode = 7;
inline void ExecuteSqlRequest::clear_query_mode() {
  query_mode_ = 0;
}
inline ::google::spanner::v1::ExecuteSqlRequest_QueryMode ExecuteSqlRequest::query_mode() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ExecuteSqlRequest.query_mode)
  return static_cast< ::google::spanner::v1::ExecuteSqlRequest_QueryMode >(query_mode_);
}
inline void ExecuteSqlRequest::set_query_mode(::google::spanner::v1::ExecuteSqlRequest_QueryMode value) {
  
  query_mode_ = value;
  // @@protoc_insertion_point(field_set:google.spanner.v1.ExecuteSqlRequest.query_mode)
}

// -------------------------------------------------------------------

// ReadRequest

// string session = 1;
inline void ReadRequest::clear_session() {
  session_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.session)
  return session_.GetNoArena();
}
inline void ReadRequest::set_session(const ::std::string& value) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.session)
}
#if LANG_CXX11
inline void ReadRequest::set_session(::std::string&& value) {
  
  session_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.ReadRequest.session)
}
#endif
inline void ReadRequest::set_session(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.ReadRequest.session)
}
inline void ReadRequest::set_session(const char* value, size_t size) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.ReadRequest.session)
}
inline ::std::string* ReadRequest::mutable_session() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.session)
  return session_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.session)
  
  return session_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadRequest::set_allocated_session(::std::string* session) {
  if (session != NULL) {
    
  } else {
    
  }
  session_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.session)
}

// .google.spanner.v1.TransactionSelector transaction = 2;
inline bool ReadRequest::has_transaction() const {
  return this != internal_default_instance() && transaction_ != NULL;
}
inline const ::google::spanner::v1::TransactionSelector& ReadRequest::transaction() const {
  const ::google::spanner::v1::TransactionSelector* p = transaction_;
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.transaction)
  return p != NULL ? *p : *reinterpret_cast<const ::google::spanner::v1::TransactionSelector*>(
      &::google::spanner::v1::_TransactionSelector_default_instance_);
}
inline ::google::spanner::v1::TransactionSelector* ReadRequest::release_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.transaction)
  
  ::google::spanner::v1::TransactionSelector* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline ::google::spanner::v1::TransactionSelector* ReadRequest::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::google::spanner::v1::TransactionSelector;
  }
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.transaction)
  return transaction_;
}
inline void ReadRequest::set_allocated_transaction(::google::spanner::v1::TransactionSelector* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(transaction_);
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.transaction)
}

// string table = 3;
inline void ReadRequest::clear_table() {
  table_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadRequest::table() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.table)
  return table_.GetNoArena();
}
inline void ReadRequest::set_table(const ::std::string& value) {
  
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.table)
}
#if LANG_CXX11
inline void ReadRequest::set_table(::std::string&& value) {
  
  table_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.ReadRequest.table)
}
#endif
inline void ReadRequest::set_table(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.ReadRequest.table)
}
inline void ReadRequest::set_table(const char* value, size_t size) {
  
  table_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.ReadRequest.table)
}
inline ::std::string* ReadRequest::mutable_table() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.table)
  return table_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRequest::release_table() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.table)
  
  return table_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadRequest::set_allocated_table(::std::string* table) {
  if (table != NULL) {
    
  } else {
    
  }
  table_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.table)
}

// string index = 4;
inline void ReadRequest::clear_index() {
  index_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadRequest::index() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.index)
  return index_.GetNoArena();
}
inline void ReadRequest::set_index(const ::std::string& value) {
  
  index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.index)
}
#if LANG_CXX11
inline void ReadRequest::set_index(::std::string&& value) {
  
  index_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.ReadRequest.index)
}
#endif
inline void ReadRequest::set_index(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.ReadRequest.index)
}
inline void ReadRequest::set_index(const char* value, size_t size) {
  
  index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.ReadRequest.index)
}
inline ::std::string* ReadRequest::mutable_index() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.index)
  return index_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRequest::release_index() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.index)
  
  return index_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadRequest::set_allocated_index(::std::string* index) {
  if (index != NULL) {
    
  } else {
    
  }
  index_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), index);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.index)
}

// repeated string columns = 5;
inline int ReadRequest::columns_size() const {
  return columns_.size();
}
inline void ReadRequest::clear_columns() {
  columns_.Clear();
}
inline const ::std::string& ReadRequest::columns(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.columns)
  return columns_.Get(index);
}
inline ::std::string* ReadRequest::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.columns)
  return columns_.Mutable(index);
}
inline void ReadRequest::set_columns(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.columns)
  columns_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ReadRequest::set_columns(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.columns)
  columns_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ReadRequest::set_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.ReadRequest.columns)
}
inline void ReadRequest::set_columns(int index, const char* value, size_t size) {
  columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.ReadRequest.columns)
}
inline ::std::string* ReadRequest::add_columns() {
  // @@protoc_insertion_point(field_add_mutable:google.spanner.v1.ReadRequest.columns)
  return columns_.Add();
}
inline void ReadRequest::add_columns(const ::std::string& value) {
  columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:google.spanner.v1.ReadRequest.columns)
}
#if LANG_CXX11
inline void ReadRequest::add_columns(::std::string&& value) {
  columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:google.spanner.v1.ReadRequest.columns)
}
#endif
inline void ReadRequest::add_columns(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:google.spanner.v1.ReadRequest.columns)
}
inline void ReadRequest::add_columns(const char* value, size_t size) {
  columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:google.spanner.v1.ReadRequest.columns)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReadRequest::columns() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.ReadRequest.columns)
  return columns_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReadRequest::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.ReadRequest.columns)
  return &columns_;
}

// .google.spanner.v1.KeySet key_set = 6;
inline bool ReadRequest::has_key_set() const {
  return this != internal_default_instance() && key_set_ != NULL;
}
inline const ::google::spanner::v1::KeySet& ReadRequest::key_set() const {
  const ::google::spanner::v1::KeySet* p = key_set_;
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.key_set)
  return p != NULL ? *p : *reinterpret_cast<const ::google::spanner::v1::KeySet*>(
      &::google::spanner::v1::_KeySet_default_instance_);
}
inline ::google::spanner::v1::KeySet* ReadRequest::release_key_set() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.key_set)
  
  ::google::spanner::v1::KeySet* temp = key_set_;
  key_set_ = NULL;
  return temp;
}
inline ::google::spanner::v1::KeySet* ReadRequest::mutable_key_set() {
  
  if (key_set_ == NULL) {
    key_set_ = new ::google::spanner::v1::KeySet;
  }
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.key_set)
  return key_set_;
}
inline void ReadRequest::set_allocated_key_set(::google::spanner::v1::KeySet* key_set) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_set_);
  }
  if (key_set) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key_set = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key_set, submessage_arena);
    }
    
  } else {
    
  }
  key_set_ = key_set;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.key_set)
}

// int64 limit = 8;
inline void ReadRequest::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReadRequest::limit() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.limit)
  return limit_;
}
inline void ReadRequest::set_limit(::google::protobuf::int64 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.limit)
}

// bytes resume_token = 9;
inline void ReadRequest::clear_resume_token() {
  resume_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadRequest::resume_token() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.ReadRequest.resume_token)
  return resume_token_.GetNoArena();
}
inline void ReadRequest::set_resume_token(const ::std::string& value) {
  
  resume_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.ReadRequest.resume_token)
}
#if LANG_CXX11
inline void ReadRequest::set_resume_token(::std::string&& value) {
  
  resume_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.ReadRequest.resume_token)
}
#endif
inline void ReadRequest::set_resume_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  resume_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.ReadRequest.resume_token)
}
inline void ReadRequest::set_resume_token(const void* value, size_t size) {
  
  resume_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.ReadRequest.resume_token)
}
inline ::std::string* ReadRequest::mutable_resume_token() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.ReadRequest.resume_token)
  return resume_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRequest::release_resume_token() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.ReadRequest.resume_token)
  
  return resume_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadRequest::set_allocated_resume_token(::std::string* resume_token) {
  if (resume_token != NULL) {
    
  } else {
    
  }
  resume_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resume_token);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.ReadRequest.resume_token)
}

// -------------------------------------------------------------------

// BeginTransactionRequest

// string session = 1;
inline void BeginTransactionRequest::clear_session() {
  session_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BeginTransactionRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.BeginTransactionRequest.session)
  return session_.GetNoArena();
}
inline void BeginTransactionRequest::set_session(const ::std::string& value) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.BeginTransactionRequest.session)
}
#if LANG_CXX11
inline void BeginTransactionRequest::set_session(::std::string&& value) {
  
  session_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.BeginTransactionRequest.session)
}
#endif
inline void BeginTransactionRequest::set_session(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.BeginTransactionRequest.session)
}
inline void BeginTransactionRequest::set_session(const char* value, size_t size) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.BeginTransactionRequest.session)
}
inline ::std::string* BeginTransactionRequest::mutable_session() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.BeginTransactionRequest.session)
  return session_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BeginTransactionRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.BeginTransactionRequest.session)
  
  return session_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BeginTransactionRequest::set_allocated_session(::std::string* session) {
  if (session != NULL) {
    
  } else {
    
  }
  session_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.BeginTransactionRequest.session)
}

// .google.spanner.v1.TransactionOptions options = 2;
inline bool BeginTransactionRequest::has_options() const {
  return this != internal_default_instance() && options_ != NULL;
}
inline const ::google::spanner::v1::TransactionOptions& BeginTransactionRequest::options() const {
  const ::google::spanner::v1::TransactionOptions* p = options_;
  // @@protoc_insertion_point(field_get:google.spanner.v1.BeginTransactionRequest.options)
  return p != NULL ? *p : *reinterpret_cast<const ::google::spanner::v1::TransactionOptions*>(
      &::google::spanner::v1::_TransactionOptions_default_instance_);
}
inline ::google::spanner::v1::TransactionOptions* BeginTransactionRequest::release_options() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.BeginTransactionRequest.options)
  
  ::google::spanner::v1::TransactionOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::google::spanner::v1::TransactionOptions* BeginTransactionRequest::mutable_options() {
  
  if (options_ == NULL) {
    options_ = new ::google::spanner::v1::TransactionOptions;
  }
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.BeginTransactionRequest.options)
  return options_;
}
inline void BeginTransactionRequest::set_allocated_options(::google::spanner::v1::TransactionOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(options_);
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.BeginTransactionRequest.options)
}

// -------------------------------------------------------------------

// CommitRequest

// string session = 1;
inline void CommitRequest::clear_session() {
  session_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CommitRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.session)
  return session_.GetNoArena();
}
inline void CommitRequest::set_session(const ::std::string& value) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.CommitRequest.session)
}
#if LANG_CXX11
inline void CommitRequest::set_session(::std::string&& value) {
  
  session_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.CommitRequest.session)
}
#endif
inline void CommitRequest::set_session(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.CommitRequest.session)
}
inline void CommitRequest::set_session(const char* value, size_t size) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.CommitRequest.session)
}
inline ::std::string* CommitRequest::mutable_session() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitRequest.session)
  return session_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommitRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CommitRequest.session)
  
  return session_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommitRequest::set_allocated_session(::std::string* session) {
  if (session != NULL) {
    
  } else {
    
  }
  session_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.CommitRequest.session)
}

// bytes transaction_id = 2;
inline bool CommitRequest::has_transaction_id() const {
  return transaction_case() == kTransactionId;
}
inline void CommitRequest::set_has_transaction_id() {
  _oneof_case_[0] = kTransactionId;
}
inline void CommitRequest::clear_transaction_id() {
  if (has_transaction_id()) {
    transaction_.transaction_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_transaction();
  }
}
inline const ::std::string& CommitRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.transaction_id)
  if (has_transaction_id()) {
    return transaction_.transaction_id_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void CommitRequest::set_transaction_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.spanner.v1.CommitRequest.transaction_id)
  if (!has_transaction_id()) {
    clear_transaction();
    set_has_transaction_id();
    transaction_.transaction_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  transaction_.transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.CommitRequest.transaction_id)
}
#if LANG_CXX11
inline void CommitRequest::set_transaction_id(::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.spanner.v1.CommitRequest.transaction_id)
  if (!has_transaction_id()) {
    clear_transaction();
    set_has_transaction_id();
    transaction_.transaction_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  transaction_.transaction_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.CommitRequest.transaction_id)
}
#endif
inline void CommitRequest::set_transaction_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_transaction_id()) {
    clear_transaction();
    set_has_transaction_id();
    transaction_.transaction_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  transaction_.transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.CommitRequest.transaction_id)
}
inline void CommitRequest::set_transaction_id(const void* value, size_t size) {
  if (!has_transaction_id()) {
    clear_transaction();
    set_has_transaction_id();
    transaction_.transaction_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  transaction_.transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.CommitRequest.transaction_id)
}
inline ::std::string* CommitRequest::mutable_transaction_id() {
  if (!has_transaction_id()) {
    clear_transaction();
    set_has_transaction_id();
    transaction_.transaction_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitRequest.transaction_id)
  return transaction_.transaction_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommitRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CommitRequest.transaction_id)
  if (has_transaction_id()) {
    clear_has_transaction();
    return transaction_.transaction_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void CommitRequest::set_allocated_transaction_id(::std::string* transaction_id) {
  if (!has_transaction_id()) {
    transaction_.transaction_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_transaction();
  if (transaction_id != NULL) {
    set_has_transaction_id();
    transaction_.transaction_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        transaction_id);
  }
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.CommitRequest.transaction_id)
}

// .google.spanner.v1.TransactionOptions single_use_transaction = 3;
inline bool CommitRequest::has_single_use_transaction() const {
  return transaction_case() == kSingleUseTransaction;
}
inline void CommitRequest::set_has_single_use_transaction() {
  _oneof_case_[0] = kSingleUseTransaction;
}
inline ::google::spanner::v1::TransactionOptions* CommitRequest::release_single_use_transaction() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CommitRequest.single_use_transaction)
  if (has_single_use_transaction()) {
    clear_has_transaction();
      ::google::spanner::v1::TransactionOptions* temp = transaction_.single_use_transaction_;
    transaction_.single_use_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::spanner::v1::TransactionOptions& CommitRequest::single_use_transaction() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.single_use_transaction)
  return has_single_use_transaction()
      ? *transaction_.single_use_transaction_
      : *reinterpret_cast< ::google::spanner::v1::TransactionOptions*>(&::google::spanner::v1::_TransactionOptions_default_instance_);
}
inline ::google::spanner::v1::TransactionOptions* CommitRequest::mutable_single_use_transaction() {
  if (!has_single_use_transaction()) {
    clear_transaction();
    set_has_single_use_transaction();
    transaction_.single_use_transaction_ = new ::google::spanner::v1::TransactionOptions;
  }
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitRequest.single_use_transaction)
  return transaction_.single_use_transaction_;
}

// repeated .google.spanner.v1.Mutation mutations = 4;
inline int CommitRequest::mutations_size() const {
  return mutations_.size();
}
inline const ::google::spanner::v1::Mutation& CommitRequest::mutations(int index) const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitRequest.mutations)
  return mutations_.Get(index);
}
inline ::google::spanner::v1::Mutation* CommitRequest::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitRequest.mutations)
  return mutations_.Mutable(index);
}
inline ::google::spanner::v1::Mutation* CommitRequest::add_mutations() {
  // @@protoc_insertion_point(field_add:google.spanner.v1.CommitRequest.mutations)
  return mutations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::spanner::v1::Mutation >*
CommitRequest::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:google.spanner.v1.CommitRequest.mutations)
  return &mutations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::spanner::v1::Mutation >&
CommitRequest::mutations() const {
  // @@protoc_insertion_point(field_list:google.spanner.v1.CommitRequest.mutations)
  return mutations_;
}

inline bool CommitRequest::has_transaction() const {
  return transaction_case() != TRANSACTION_NOT_SET;
}
inline void CommitRequest::clear_has_transaction() {
  _oneof_case_[0] = TRANSACTION_NOT_SET;
}
inline CommitRequest::TransactionCase CommitRequest::transaction_case() const {
  return CommitRequest::TransactionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CommitResponse

// .google.protobuf.Timestamp commit_timestamp = 1;
inline bool CommitResponse::has_commit_timestamp() const {
  return this != internal_default_instance() && commit_timestamp_ != NULL;
}
inline const ::google::protobuf::Timestamp& CommitResponse::commit_timestamp() const {
  const ::google::protobuf::Timestamp* p = commit_timestamp_;
  // @@protoc_insertion_point(field_get:google.spanner.v1.CommitResponse.commit_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* CommitResponse::release_commit_timestamp() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.CommitResponse.commit_timestamp)
  
  ::google::protobuf::Timestamp* temp = commit_timestamp_;
  commit_timestamp_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* CommitResponse::mutable_commit_timestamp() {
  
  if (commit_timestamp_ == NULL) {
    commit_timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.CommitResponse.commit_timestamp)
  return commit_timestamp_;
}
inline void CommitResponse::set_allocated_commit_timestamp(::google::protobuf::Timestamp* commit_timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(commit_timestamp_);
  }
  if (commit_timestamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(commit_timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      commit_timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, commit_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  commit_timestamp_ = commit_timestamp;
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.CommitResponse.commit_timestamp)
}

// -------------------------------------------------------------------

// RollbackRequest

// string session = 1;
inline void RollbackRequest::clear_session() {
  session_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RollbackRequest::session() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.RollbackRequest.session)
  return session_.GetNoArena();
}
inline void RollbackRequest::set_session(const ::std::string& value) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.RollbackRequest.session)
}
#if LANG_CXX11
inline void RollbackRequest::set_session(::std::string&& value) {
  
  session_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.RollbackRequest.session)
}
#endif
inline void RollbackRequest::set_session(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.RollbackRequest.session)
}
inline void RollbackRequest::set_session(const char* value, size_t size) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.RollbackRequest.session)
}
inline ::std::string* RollbackRequest::mutable_session() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.RollbackRequest.session)
  return session_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RollbackRequest::release_session() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.RollbackRequest.session)
  
  return session_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RollbackRequest::set_allocated_session(::std::string* session) {
  if (session != NULL) {
    
  } else {
    
  }
  session_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.RollbackRequest.session)
}

// bytes transaction_id = 2;
inline void RollbackRequest::clear_transaction_id() {
  transaction_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RollbackRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:google.spanner.v1.RollbackRequest.transaction_id)
  return transaction_id_.GetNoArena();
}
inline void RollbackRequest::set_transaction_id(const ::std::string& value) {
  
  transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.spanner.v1.RollbackRequest.transaction_id)
}
#if LANG_CXX11
inline void RollbackRequest::set_transaction_id(::std::string&& value) {
  
  transaction_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.spanner.v1.RollbackRequest.transaction_id)
}
#endif
inline void RollbackRequest::set_transaction_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.spanner.v1.RollbackRequest.transaction_id)
}
inline void RollbackRequest::set_transaction_id(const void* value, size_t size) {
  
  transaction_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.spanner.v1.RollbackRequest.transaction_id)
}
inline ::std::string* RollbackRequest::mutable_transaction_id() {
  
  // @@protoc_insertion_point(field_mutable:google.spanner.v1.RollbackRequest.transaction_id)
  return transaction_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RollbackRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:google.spanner.v1.RollbackRequest.transaction_id)
  
  return transaction_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RollbackRequest::set_allocated_transaction_id(::std::string* transaction_id) {
  if (transaction_id != NULL) {
    
  } else {
    
  }
  transaction_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transaction_id);
  // @@protoc_insertion_point(field_set_allocated:google.spanner.v1.RollbackRequest.transaction_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace spanner
}  // namespace google

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::google::spanner::v1::ExecuteSqlRequest_QueryMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::spanner::v1::ExecuteSqlRequest_QueryMode>() {
  return ::google::spanner::v1::ExecuteSqlRequest_QueryMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_google_2fspanner_2fv1_2fspanner_2eproto__INCLUDED
