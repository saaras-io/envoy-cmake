// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: google/devtools/remoteexecution/v1test/remote_execution.proto
// Original file comments:
// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
#ifndef GRPC_google_2fdevtools_2fremoteexecution_2fv1test_2fremote_5fexecution_2eproto__INCLUDED
#define GRPC_google_2fdevtools_2fremoteexecution_2fv1test_2fremote_5fexecution_2eproto__INCLUDED

#include "google/devtools/remoteexecution/v1test/remote_execution.pb.h"

#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace google {
namespace devtools {
namespace remoteexecution {
namespace v1test {

// The Remote Execution API is used to execute an
// [Action][google.devtools.remoteexecution.v1test.Action] on the remote
// workers.
//
// As with other services in the Remote Execution API, any call may return an
// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
// information about when the client should retry the request; clients SHOULD
// respect the information provided.
class Execution final {
 public:
  static constexpr char const* service_full_name() {
    return "google.devtools.remoteexecution.v1test.Execution";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Execute an action remotely.
    //
    // In order to execute an action, the client must first upload all of the
    // inputs, as well as the
    // [Command][google.devtools.remoteexecution.v1test.Command] to run, into the
    // [ContentAddressableStorage][google.devtools.remoteexecution.v1test.ContentAddressableStorage].
    // It then calls `Execute` with an
    // [Action][google.devtools.remoteexecution.v1test.Action] referring to them.
    // The server will run the action and eventually return the result.
    //
    // The input `Action`'s fields MUST meet the various canonicalization
    // requirements specified in the documentation for their types so that it has
    // the same digest as other logically equivalent `Action`s. The server MAY
    // enforce the requirements and return errors if a non-canonical input is
    // received. It MAY also proceed without verifying some or all of the
    // requirements, such as for performance reasons. If the server does not
    // verify the requirement, then it will treat the `Action` as distinct from
    // another logically equivalent action if they hash differently.
    //
    // Returns a [google.longrunning.Operation][google.longrunning.Operation]
    // describing the resulting execution, with eventual `response`
    // [ExecuteResponse][google.devtools.remoteexecution.v1test.ExecuteResponse].
    // The `metadata` on the operation is of type
    // [ExecuteOperationMetadata][google.devtools.remoteexecution.v1test.ExecuteOperationMetadata].
    //
    // To query the operation, you can use the
    // [Operations API][google.longrunning.Operations.GetOperation]. If you wish
    // to allow the server to stream operations updates, rather than requiring
    // client polling, you can use the
    // [Watcher API][google.watcher.v1.Watcher.Watch] with the Operation's `name`
    // as the `target`.
    //
    // When using the Watcher API, the initial `data` will be the `Operation` at
    // the time of the request. Updates will be provided periodically by the
    // server until the `Operation` completes, at which point the response message
    // will (assuming no error) be at `data.response`.
    //
    // The server NEED NOT implement other methods or functionality of the
    // Operation and Watcher APIs.
    //
    // Errors discovered during creation of the `Operation` will be reported
    // as gRPC Status errors, while errors that occurred while running the
    // action will be reported in the `status` field of the `ExecuteResponse`. The
    // server MUST NOT set the `error` field of the `Operation` proto.
    // The possible errors include:
    // * `INVALID_ARGUMENT`: One or more arguments are invalid.
    // * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
    //   action requested, such as a missing input or command or no worker being
    //   available. The client may be able to fix the errors and retry.
    // * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
    //   the action.
    // * `UNAVAILABLE`: Due to a transient condition, such as all workers being
    //   occupied (and the server does not support a queue), the action could not
    //   be started. The client should retry.
    // * `INTERNAL`: An internal error occurred in the execution engine or the
    //   worker.
    // * `DEADLINE_EXCEEDED`: The execution timed out.
    //
    // In the case of a missing input or command, the server SHOULD additionally
    // send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
    // where, for each requested blob not present in the CAS, there is a
    // `Violation` with a `type` of `MISSING` and a `subject` of
    // `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
    virtual ::grpc::Status Execute(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::google::longrunning::Operation* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::longrunning::Operation>> AsyncExecute(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::longrunning::Operation>>(AsyncExecuteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::longrunning::Operation>> PrepareAsyncExecute(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::longrunning::Operation>>(PrepareAsyncExecuteRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::longrunning::Operation>* AsyncExecuteRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::longrunning::Operation>* PrepareAsyncExecuteRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Execute(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::google::longrunning::Operation* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::longrunning::Operation>> AsyncExecute(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::longrunning::Operation>>(AsyncExecuteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::longrunning::Operation>> PrepareAsyncExecute(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::longrunning::Operation>>(PrepareAsyncExecuteRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::google::longrunning::Operation>* AsyncExecuteRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::longrunning::Operation>* PrepareAsyncExecuteRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Execute_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Execute an action remotely.
    //
    // In order to execute an action, the client must first upload all of the
    // inputs, as well as the
    // [Command][google.devtools.remoteexecution.v1test.Command] to run, into the
    // [ContentAddressableStorage][google.devtools.remoteexecution.v1test.ContentAddressableStorage].
    // It then calls `Execute` with an
    // [Action][google.devtools.remoteexecution.v1test.Action] referring to them.
    // The server will run the action and eventually return the result.
    //
    // The input `Action`'s fields MUST meet the various canonicalization
    // requirements specified in the documentation for their types so that it has
    // the same digest as other logically equivalent `Action`s. The server MAY
    // enforce the requirements and return errors if a non-canonical input is
    // received. It MAY also proceed without verifying some or all of the
    // requirements, such as for performance reasons. If the server does not
    // verify the requirement, then it will treat the `Action` as distinct from
    // another logically equivalent action if they hash differently.
    //
    // Returns a [google.longrunning.Operation][google.longrunning.Operation]
    // describing the resulting execution, with eventual `response`
    // [ExecuteResponse][google.devtools.remoteexecution.v1test.ExecuteResponse].
    // The `metadata` on the operation is of type
    // [ExecuteOperationMetadata][google.devtools.remoteexecution.v1test.ExecuteOperationMetadata].
    //
    // To query the operation, you can use the
    // [Operations API][google.longrunning.Operations.GetOperation]. If you wish
    // to allow the server to stream operations updates, rather than requiring
    // client polling, you can use the
    // [Watcher API][google.watcher.v1.Watcher.Watch] with the Operation's `name`
    // as the `target`.
    //
    // When using the Watcher API, the initial `data` will be the `Operation` at
    // the time of the request. Updates will be provided periodically by the
    // server until the `Operation` completes, at which point the response message
    // will (assuming no error) be at `data.response`.
    //
    // The server NEED NOT implement other methods or functionality of the
    // Operation and Watcher APIs.
    //
    // Errors discovered during creation of the `Operation` will be reported
    // as gRPC Status errors, while errors that occurred while running the
    // action will be reported in the `status` field of the `ExecuteResponse`. The
    // server MUST NOT set the `error` field of the `Operation` proto.
    // The possible errors include:
    // * `INVALID_ARGUMENT`: One or more arguments are invalid.
    // * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
    //   action requested, such as a missing input or command or no worker being
    //   available. The client may be able to fix the errors and retry.
    // * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
    //   the action.
    // * `UNAVAILABLE`: Due to a transient condition, such as all workers being
    //   occupied (and the server does not support a queue), the action could not
    //   be started. The client should retry.
    // * `INTERNAL`: An internal error occurred in the execution engine or the
    //   worker.
    // * `DEADLINE_EXCEEDED`: The execution timed out.
    //
    // In the case of a missing input or command, the server SHOULD additionally
    // send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
    // where, for each requested blob not present in the CAS, there is a
    // `Violation` with a `type` of `MISSING` and a `subject` of
    // `"blobs/{hash}/{size}"` indicating the digest of the missing blob.
    virtual ::grpc::Status Execute(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest* request, ::google::longrunning::Operation* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Execute() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest* request, ::google::longrunning::Operation* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecute(::grpc::ServerContext* context, ::google::devtools::remoteexecution::v1test::ExecuteRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::longrunning::Operation>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Execute<Service > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Execute() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest* request, ::google::longrunning::Operation* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Execute() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::google::devtools::remoteexecution::v1test::ExecuteRequest, ::google::longrunning::Operation>(std::bind(&WithStreamedUnaryMethod_Execute<BaseClass>::StreamedExecute, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Execute(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::ExecuteRequest* request, ::google::longrunning::Operation* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::devtools::remoteexecution::v1test::ExecuteRequest,::google::longrunning::Operation>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Execute<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Execute<Service > StreamedService;
};

// The action cache API is used to query whether a given action has already been
// performed and, if so, retrieve its result. Unlike the
// [ContentAddressableStorage][google.devtools.remoteexecution.v1test.ContentAddressableStorage],
// which addresses blobs by their own content, the action cache addresses the
// [ActionResult][google.devtools.remoteexecution.v1test.ActionResult] by a
// digest of the encoded [Action][google.devtools.remoteexecution.v1test.Action]
// which produced them.
//
// The lifetime of entries in the action cache is implementation-specific, but
// the server SHOULD assume that more recently used entries are more likely to
// be used again. Additionally, action cache implementations SHOULD ensure that
// any blobs referenced in the
// [ContentAddressableStorage][google.devtools.remoteexecution.v1test.ContentAddressableStorage]
// are still valid when returning a result.
//
// As with other services in the Remote Execution API, any call may return an
// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
// information about when the client should retry the request; clients SHOULD
// respect the information provided.
class ActionCache final {
 public:
  static constexpr char const* service_full_name() {
    return "google.devtools.remoteexecution.v1test.ActionCache";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Retrieve a cached execution result.
    //
    // Errors:
    // * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
    virtual ::grpc::Status GetActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::google::devtools::remoteexecution::v1test::ActionResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>> AsyncGetActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>>(AsyncGetActionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>> PrepareAsyncGetActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>>(PrepareAsyncGetActionResultRaw(context, request, cq));
    }
    // Upload a new execution result.
    //
    // This method is intended for servers which implement the distributed cache
    // independently of the
    // [Execution][google.devtools.remoteexecution.v1test.Execution] API. As a
    // result, it is OPTIONAL for servers to implement.
    //
    // Errors:
    // * `NOT_IMPLEMENTED`: This method is not supported by the server.
    // * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
    //   entry to the cache.
    virtual ::grpc::Status UpdateActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::google::devtools::remoteexecution::v1test::ActionResult* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>> AsyncUpdateActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>>(AsyncUpdateActionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>> PrepareAsyncUpdateActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>>(PrepareAsyncUpdateActionResultRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>* AsyncGetActionResultRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>* PrepareAsyncGetActionResultRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>* AsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::ActionResult>* PrepareAsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::google::devtools::remoteexecution::v1test::ActionResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>> AsyncGetActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>>(AsyncGetActionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>> PrepareAsyncGetActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>>(PrepareAsyncGetActionResultRaw(context, request, cq));
    }
    ::grpc::Status UpdateActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::google::devtools::remoteexecution::v1test::ActionResult* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>> AsyncUpdateActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>>(AsyncUpdateActionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>> PrepareAsyncUpdateActionResult(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>>(PrepareAsyncUpdateActionResultRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>* AsyncGetActionResultRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>* PrepareAsyncGetActionResultRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>* AsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::ActionResult>* PrepareAsyncUpdateActionResultRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetActionResult_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateActionResult_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Retrieve a cached execution result.
    //
    // Errors:
    // * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
    virtual ::grpc::Status GetActionResult(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest* request, ::google::devtools::remoteexecution::v1test::ActionResult* response);
    // Upload a new execution result.
    //
    // This method is intended for servers which implement the distributed cache
    // independently of the
    // [Execution][google.devtools.remoteexecution.v1test.Execution] API. As a
    // result, it is OPTIONAL for servers to implement.
    //
    // Errors:
    // * `NOT_IMPLEMENTED`: This method is not supported by the server.
    // * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
    //   entry to the cache.
    virtual ::grpc::Status UpdateActionResult(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest* request, ::google::devtools::remoteexecution::v1test::ActionResult* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetActionResult() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResult(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest* request, ::google::devtools::remoteexecution::v1test::ActionResult* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActionResult(::grpc::ServerContext* context, ::google::devtools::remoteexecution::v1test::GetActionResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::devtools::remoteexecution::v1test::ActionResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateActionResult() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_UpdateActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateActionResult(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest* request, ::google::devtools::remoteexecution::v1test::ActionResult* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateActionResult(::grpc::ServerContext* context, ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::devtools::remoteexecution::v1test::ActionResult>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetActionResult<WithAsyncMethod_UpdateActionResult<Service > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_GetActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetActionResult() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActionResult(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest* request, ::google::devtools::remoteexecution::v1test::ActionResult* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateActionResult() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_UpdateActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateActionResult(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest* request, ::google::devtools::remoteexecution::v1test::ActionResult* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetActionResult() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::google::devtools::remoteexecution::v1test::GetActionResultRequest, ::google::devtools::remoteexecution::v1test::ActionResult>(std::bind(&WithStreamedUnaryMethod_GetActionResult<BaseClass>::StreamedGetActionResult, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActionResult(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::GetActionResultRequest* request, ::google::devtools::remoteexecution::v1test::ActionResult* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActionResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::devtools::remoteexecution::v1test::GetActionResultRequest,::google::devtools::remoteexecution::v1test::ActionResult>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateActionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateActionResult() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest, ::google::devtools::remoteexecution::v1test::ActionResult>(std::bind(&WithStreamedUnaryMethod_UpdateActionResult<BaseClass>::StreamedUpdateActionResult, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateActionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateActionResult(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest* request, ::google::devtools::remoteexecution::v1test::ActionResult* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateActionResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::devtools::remoteexecution::v1test::UpdateActionResultRequest,::google::devtools::remoteexecution::v1test::ActionResult>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetActionResult<WithStreamedUnaryMethod_UpdateActionResult<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetActionResult<WithStreamedUnaryMethod_UpdateActionResult<Service > > StreamedService;
};

// The CAS (content-addressable storage) is used to store the inputs to and
// outputs from the execution service. Each piece of content is addressed by the
// digest of its binary data.
//
// Most of the binary data stored in the CAS is opaque to the execution engine,
// and is only used as a communication medium. In order to build an
// [Action][google.devtools.remoteexecution.v1test.Action],
// however, the client will need to also upload the
// [Command][google.devtools.remoteexecution.v1test.Command] and input root
// [Directory][google.devtools.remoteexecution.v1test.Directory] for the Action.
// The Command and Directory messages must be marshalled to wire format and then
// uploaded under the hash as with any other piece of content. In practice, the
// input root directory is likely to refer to other Directories in its
// hierarchy, which must also each be uploaded on their own.
//
// For small file uploads the client should group them together and call
// [BatchUpdateBlobs][google.devtools.remoteexecution.v1test.ContentAddressableStorage.BatchUpdateBlobs]
// on chunks of no more than 10 MiB. For large uploads, the client must use the
// [Write method][google.bytestream.ByteStream.Write] of the ByteStream API. The
// `resource_name` is `{instance_name}/uploads/{uuid}/blobs/{hash}/{size}`,
// where `instance_name` is as described in the next paragraph, `uuid` is a
// version 4 UUID generated by the client, and `hash` and `size` are the
// [Digest][google.devtools.remoteexecution.v1test.Digest] of the blob. The
// `uuid` is used only to avoid collisions when multiple clients try to upload
// the same file (or the same client tries to upload the file multiple times at
// once on different threads), so the client MAY reuse the `uuid` for uploading
// different blobs. The `resource_name` may optionally have a trailing filename
// (or other metadata) for a client to use if it is storing URLs, as in
// `{instance}/uploads/{uuid}/blobs/{hash}/{size}/foo/bar/baz.cc`. Anything
// after the `size` is ignored.
//
// A single server MAY support multiple instances of the execution system, each
// with their own workers, storage, cache, etc. The exact relationship between
// instances is up to the server. If the server does, then the `instance_name`
// is an identifier, possibly containing multiple path segments, used to
// distinguish between the various instances on the server, in a manner defined
// by the server. For servers which do not support multiple instances, then the
// `instance_name` is the empty path and the leading slash is omitted, so that
// the `resource_name` becomes `uploads/{uuid}/blobs/{hash}/{size}`.
//
// When attempting an upload, if another client has already completed the upload
// (which may occur in the middle of a single upload if another client uploads
// the same blob concurrently), the request will terminate immediately with
// a response whose `committed_size` is the full size of the uploaded file
// (regardless of how much data was transmitted by the client). If the client
// completes the upload but the
// [Digest][google.devtools.remoteexecution.v1test.Digest] does not match, an
// `INVALID_ARGUMENT` error will be returned. In either case, the client should
// not attempt to retry the upload.
//
// For downloading blobs, the client must use the
// [Read method][google.bytestream.ByteStream.Read] of the ByteStream API, with
// a `resource_name` of `"{instance_name}/blobs/{hash}/{size}"`, where
// `instance_name` is the instance name (see above), and `hash` and `size` are
// the [Digest][google.devtools.remoteexecution.v1test.Digest] of the blob.
//
// The lifetime of entries in the CAS is implementation specific, but it SHOULD
// be long enough to allow for newly-added and recently looked-up entries to be
// used in subsequent calls (e.g. to
// [Execute][google.devtools.remoteexecution.v1test.Execution.Execute]).
//
// As with other services in the Remote Execution API, any call may return an
// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
// information about when the client should retry the request; clients SHOULD
// respect the information provided.
class ContentAddressableStorage final {
 public:
  static constexpr char const* service_full_name() {
    return "google.devtools.remoteexecution.v1test.ContentAddressableStorage";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Determine if blobs are present in the CAS.
    //
    // Clients can use this API before uploading blobs to determine which ones are
    // already present in the CAS and do not need to be uploaded again.
    //
    // There are no method-specific errors.
    virtual ::grpc::Status FindMissingBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>> AsyncFindMissingBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>>(AsyncFindMissingBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>> PrepareAsyncFindMissingBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>>(PrepareAsyncFindMissingBlobsRaw(context, request, cq));
    }
    // Upload many blobs at once.
    //
    // The client MUST NOT upload blobs with a combined total size of more than 10
    // MiB using this API. Such requests should either be split into smaller
    // chunks or uploaded using the
    // [ByteStream API][google.bytestream.ByteStream], as appropriate.
    //
    // This request is equivalent to calling [UpdateBlob][] on each individual
    // blob, in parallel. The requests may succeed or fail independently.
    //
    // Errors:
    // * `INVALID_ARGUMENT`: The client attempted to upload more than 10 MiB of
    //   data.
    //
    // Individual requests may return the following errors, additionally:
    // * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
    // * `INVALID_ARGUMENT`: The
    // [Digest][google.devtools.remoteexecution.v1test.Digest] does not match the
    // provided data.
    virtual ::grpc::Status BatchUpdateBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>> AsyncBatchUpdateBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>>(AsyncBatchUpdateBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>> PrepareAsyncBatchUpdateBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>>(PrepareAsyncBatchUpdateBlobsRaw(context, request, cq));
    }
    // DEPRECATED: This method is deprecated and should no longer be used.
    virtual ::grpc::Status GetTree(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::google::devtools::remoteexecution::v1test::GetTreeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::GetTreeResponse>> AsyncGetTree(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::GetTreeResponse>>(AsyncGetTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::GetTreeResponse>> PrepareAsyncGetTree(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::GetTreeResponse>>(PrepareAsyncGetTreeRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>* AsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>* PrepareAsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>* AsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>* PrepareAsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::GetTreeResponse>* AsyncGetTreeRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::devtools::remoteexecution::v1test::GetTreeResponse>* PrepareAsyncGetTreeRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status FindMissingBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>> AsyncFindMissingBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>>(AsyncFindMissingBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>> PrepareAsyncFindMissingBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>>(PrepareAsyncFindMissingBlobsRaw(context, request, cq));
    }
    ::grpc::Status BatchUpdateBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>> AsyncBatchUpdateBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>>(AsyncBatchUpdateBlobsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>> PrepareAsyncBatchUpdateBlobs(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>>(PrepareAsyncBatchUpdateBlobsRaw(context, request, cq));
    }
    ::grpc::Status GetTree(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::google::devtools::remoteexecution::v1test::GetTreeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::GetTreeResponse>> AsyncGetTree(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::GetTreeResponse>>(AsyncGetTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::GetTreeResponse>> PrepareAsyncGetTree(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::GetTreeResponse>>(PrepareAsyncGetTreeRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>* AsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>* PrepareAsyncFindMissingBlobsRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>* AsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>* PrepareAsyncBatchUpdateBlobsRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::GetTreeResponse>* AsyncGetTreeRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::devtools::remoteexecution::v1test::GetTreeResponse>* PrepareAsyncGetTreeRaw(::grpc::ClientContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_FindMissingBlobs_;
    const ::grpc::internal::RpcMethod rpcmethod_BatchUpdateBlobs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTree_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Determine if blobs are present in the CAS.
    //
    // Clients can use this API before uploading blobs to determine which ones are
    // already present in the CAS and do not need to be uploaded again.
    //
    // There are no method-specific errors.
    virtual ::grpc::Status FindMissingBlobs(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest* request, ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse* response);
    // Upload many blobs at once.
    //
    // The client MUST NOT upload blobs with a combined total size of more than 10
    // MiB using this API. Such requests should either be split into smaller
    // chunks or uploaded using the
    // [ByteStream API][google.bytestream.ByteStream], as appropriate.
    //
    // This request is equivalent to calling [UpdateBlob][] on each individual
    // blob, in parallel. The requests may succeed or fail independently.
    //
    // Errors:
    // * `INVALID_ARGUMENT`: The client attempted to upload more than 10 MiB of
    //   data.
    //
    // Individual requests may return the following errors, additionally:
    // * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
    // * `INVALID_ARGUMENT`: The
    // [Digest][google.devtools.remoteexecution.v1test.Digest] does not match the
    // provided data.
    virtual ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest* request, ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse* response);
    // DEPRECATED: This method is deprecated and should no longer be used.
    virtual ::grpc::Status GetTree(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest* request, ::google::devtools::remoteexecution::v1test::GetTreeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_FindMissingBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_FindMissingBlobs() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_FindMissingBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMissingBlobs(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest* request, ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindMissingBlobs(::grpc::ServerContext* context, ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BatchUpdateBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_BatchUpdateBlobs() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_BatchUpdateBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest* request, ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatchUpdateBlobs(::grpc::ServerContext* context, ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetTree() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTree(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest* request, ::google::devtools::remoteexecution::v1test::GetTreeResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTree(::grpc::ServerContext* context, ::google::devtools::remoteexecution::v1test::GetTreeRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::devtools::remoteexecution::v1test::GetTreeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_FindMissingBlobs<WithAsyncMethod_BatchUpdateBlobs<WithAsyncMethod_GetTree<Service > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_FindMissingBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_FindMissingBlobs() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_FindMissingBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindMissingBlobs(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest* request, ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BatchUpdateBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_BatchUpdateBlobs() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_BatchUpdateBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest* request, ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetTree() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTree(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest* request, ::google::devtools::remoteexecution::v1test::GetTreeResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FindMissingBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_FindMissingBlobs() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest, ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>(std::bind(&WithStreamedUnaryMethod_FindMissingBlobs<BaseClass>::StreamedFindMissingBlobs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FindMissingBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindMissingBlobs(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest* request, ::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFindMissingBlobs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::devtools::remoteexecution::v1test::FindMissingBlobsRequest,::google::devtools::remoteexecution::v1test::FindMissingBlobsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BatchUpdateBlobs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_BatchUpdateBlobs() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest, ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>(std::bind(&WithStreamedUnaryMethod_BatchUpdateBlobs<BaseClass>::StreamedBatchUpdateBlobs, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_BatchUpdateBlobs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BatchUpdateBlobs(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest* request, ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBatchUpdateBlobs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::devtools::remoteexecution::v1test::BatchUpdateBlobsRequest,::google::devtools::remoteexecution::v1test::BatchUpdateBlobsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetTree() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::google::devtools::remoteexecution::v1test::GetTreeRequest, ::google::devtools::remoteexecution::v1test::GetTreeResponse>(std::bind(&WithStreamedUnaryMethod_GetTree<BaseClass>::StreamedGetTree, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTree(::grpc::ServerContext* context, const ::google::devtools::remoteexecution::v1test::GetTreeRequest* request, ::google::devtools::remoteexecution::v1test::GetTreeResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTree(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::devtools::remoteexecution::v1test::GetTreeRequest,::google::devtools::remoteexecution::v1test::GetTreeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_FindMissingBlobs<WithStreamedUnaryMethod_BatchUpdateBlobs<WithStreamedUnaryMethod_GetTree<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_FindMissingBlobs<WithStreamedUnaryMethod_BatchUpdateBlobs<WithStreamedUnaryMethod_GetTree<Service > > > StreamedService;
};

}  // namespace v1test
}  // namespace remoteexecution
}  // namespace devtools
}  // namespace google


#endif  // GRPC_google_2fdevtools_2fremoteexecution_2fv1test_2fremote_5fexecution_2eproto__INCLUDED
