// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/language/v1beta2/language_service.proto

#ifndef PROTOBUF_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto__INCLUDED
#define PROTOBUF_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "google/longrunning/operations.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "google/rpc/status.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[24];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDocumentImpl();
void InitDefaultsDocument();
void InitDefaultsSentenceImpl();
void InitDefaultsSentence();
void InitDefaultsEntity_MetadataEntry_DoNotUseImpl();
void InitDefaultsEntity_MetadataEntry_DoNotUse();
void InitDefaultsEntityImpl();
void InitDefaultsEntity();
void InitDefaultsTokenImpl();
void InitDefaultsToken();
void InitDefaultsSentimentImpl();
void InitDefaultsSentiment();
void InitDefaultsPartOfSpeechImpl();
void InitDefaultsPartOfSpeech();
void InitDefaultsDependencyEdgeImpl();
void InitDefaultsDependencyEdge();
void InitDefaultsEntityMentionImpl();
void InitDefaultsEntityMention();
void InitDefaultsTextSpanImpl();
void InitDefaultsTextSpan();
void InitDefaultsClassificationCategoryImpl();
void InitDefaultsClassificationCategory();
void InitDefaultsAnalyzeSentimentRequestImpl();
void InitDefaultsAnalyzeSentimentRequest();
void InitDefaultsAnalyzeSentimentResponseImpl();
void InitDefaultsAnalyzeSentimentResponse();
void InitDefaultsAnalyzeEntitySentimentRequestImpl();
void InitDefaultsAnalyzeEntitySentimentRequest();
void InitDefaultsAnalyzeEntitySentimentResponseImpl();
void InitDefaultsAnalyzeEntitySentimentResponse();
void InitDefaultsAnalyzeEntitiesRequestImpl();
void InitDefaultsAnalyzeEntitiesRequest();
void InitDefaultsAnalyzeEntitiesResponseImpl();
void InitDefaultsAnalyzeEntitiesResponse();
void InitDefaultsAnalyzeSyntaxRequestImpl();
void InitDefaultsAnalyzeSyntaxRequest();
void InitDefaultsAnalyzeSyntaxResponseImpl();
void InitDefaultsAnalyzeSyntaxResponse();
void InitDefaultsClassifyTextRequestImpl();
void InitDefaultsClassifyTextRequest();
void InitDefaultsClassifyTextResponseImpl();
void InitDefaultsClassifyTextResponse();
void InitDefaultsAnnotateTextRequest_FeaturesImpl();
void InitDefaultsAnnotateTextRequest_Features();
void InitDefaultsAnnotateTextRequestImpl();
void InitDefaultsAnnotateTextRequest();
void InitDefaultsAnnotateTextResponseImpl();
void InitDefaultsAnnotateTextResponse();
inline void InitDefaults() {
  InitDefaultsDocument();
  InitDefaultsSentence();
  InitDefaultsEntity_MetadataEntry_DoNotUse();
  InitDefaultsEntity();
  InitDefaultsToken();
  InitDefaultsSentiment();
  InitDefaultsPartOfSpeech();
  InitDefaultsDependencyEdge();
  InitDefaultsEntityMention();
  InitDefaultsTextSpan();
  InitDefaultsClassificationCategory();
  InitDefaultsAnalyzeSentimentRequest();
  InitDefaultsAnalyzeSentimentResponse();
  InitDefaultsAnalyzeEntitySentimentRequest();
  InitDefaultsAnalyzeEntitySentimentResponse();
  InitDefaultsAnalyzeEntitiesRequest();
  InitDefaultsAnalyzeEntitiesResponse();
  InitDefaultsAnalyzeSyntaxRequest();
  InitDefaultsAnalyzeSyntaxResponse();
  InitDefaultsClassifyTextRequest();
  InitDefaultsClassifyTextResponse();
  InitDefaultsAnnotateTextRequest_Features();
  InitDefaultsAnnotateTextRequest();
  InitDefaultsAnnotateTextResponse();
}
}  // namespace protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto
namespace google {
namespace cloud {
namespace language {
namespace v1beta2 {
class AnalyzeEntitiesRequest;
class AnalyzeEntitiesRequestDefaultTypeInternal;
extern AnalyzeEntitiesRequestDefaultTypeInternal _AnalyzeEntitiesRequest_default_instance_;
class AnalyzeEntitiesResponse;
class AnalyzeEntitiesResponseDefaultTypeInternal;
extern AnalyzeEntitiesResponseDefaultTypeInternal _AnalyzeEntitiesResponse_default_instance_;
class AnalyzeEntitySentimentRequest;
class AnalyzeEntitySentimentRequestDefaultTypeInternal;
extern AnalyzeEntitySentimentRequestDefaultTypeInternal _AnalyzeEntitySentimentRequest_default_instance_;
class AnalyzeEntitySentimentResponse;
class AnalyzeEntitySentimentResponseDefaultTypeInternal;
extern AnalyzeEntitySentimentResponseDefaultTypeInternal _AnalyzeEntitySentimentResponse_default_instance_;
class AnalyzeSentimentRequest;
class AnalyzeSentimentRequestDefaultTypeInternal;
extern AnalyzeSentimentRequestDefaultTypeInternal _AnalyzeSentimentRequest_default_instance_;
class AnalyzeSentimentResponse;
class AnalyzeSentimentResponseDefaultTypeInternal;
extern AnalyzeSentimentResponseDefaultTypeInternal _AnalyzeSentimentResponse_default_instance_;
class AnalyzeSyntaxRequest;
class AnalyzeSyntaxRequestDefaultTypeInternal;
extern AnalyzeSyntaxRequestDefaultTypeInternal _AnalyzeSyntaxRequest_default_instance_;
class AnalyzeSyntaxResponse;
class AnalyzeSyntaxResponseDefaultTypeInternal;
extern AnalyzeSyntaxResponseDefaultTypeInternal _AnalyzeSyntaxResponse_default_instance_;
class AnnotateTextRequest;
class AnnotateTextRequestDefaultTypeInternal;
extern AnnotateTextRequestDefaultTypeInternal _AnnotateTextRequest_default_instance_;
class AnnotateTextRequest_Features;
class AnnotateTextRequest_FeaturesDefaultTypeInternal;
extern AnnotateTextRequest_FeaturesDefaultTypeInternal _AnnotateTextRequest_Features_default_instance_;
class AnnotateTextResponse;
class AnnotateTextResponseDefaultTypeInternal;
extern AnnotateTextResponseDefaultTypeInternal _AnnotateTextResponse_default_instance_;
class ClassificationCategory;
class ClassificationCategoryDefaultTypeInternal;
extern ClassificationCategoryDefaultTypeInternal _ClassificationCategory_default_instance_;
class ClassifyTextRequest;
class ClassifyTextRequestDefaultTypeInternal;
extern ClassifyTextRequestDefaultTypeInternal _ClassifyTextRequest_default_instance_;
class ClassifyTextResponse;
class ClassifyTextResponseDefaultTypeInternal;
extern ClassifyTextResponseDefaultTypeInternal _ClassifyTextResponse_default_instance_;
class DependencyEdge;
class DependencyEdgeDefaultTypeInternal;
extern DependencyEdgeDefaultTypeInternal _DependencyEdge_default_instance_;
class Document;
class DocumentDefaultTypeInternal;
extern DocumentDefaultTypeInternal _Document_default_instance_;
class Entity;
class EntityDefaultTypeInternal;
extern EntityDefaultTypeInternal _Entity_default_instance_;
class EntityMention;
class EntityMentionDefaultTypeInternal;
extern EntityMentionDefaultTypeInternal _EntityMention_default_instance_;
class Entity_MetadataEntry_DoNotUse;
class Entity_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Entity_MetadataEntry_DoNotUseDefaultTypeInternal _Entity_MetadataEntry_DoNotUse_default_instance_;
class PartOfSpeech;
class PartOfSpeechDefaultTypeInternal;
extern PartOfSpeechDefaultTypeInternal _PartOfSpeech_default_instance_;
class Sentence;
class SentenceDefaultTypeInternal;
extern SentenceDefaultTypeInternal _Sentence_default_instance_;
class Sentiment;
class SentimentDefaultTypeInternal;
extern SentimentDefaultTypeInternal _Sentiment_default_instance_;
class TextSpan;
class TextSpanDefaultTypeInternal;
extern TextSpanDefaultTypeInternal _TextSpan_default_instance_;
class Token;
class TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
}  // namespace v1beta2
}  // namespace language
}  // namespace cloud
}  // namespace google
namespace google {
namespace cloud {
namespace language {
namespace v1beta2 {

enum Document_Type {
  Document_Type_TYPE_UNSPECIFIED = 0,
  Document_Type_PLAIN_TEXT = 1,
  Document_Type_HTML = 2,
  Document_Type_Document_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Document_Type_Document_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Document_Type_IsValid(int value);
const Document_Type Document_Type_Type_MIN = Document_Type_TYPE_UNSPECIFIED;
const Document_Type Document_Type_Type_MAX = Document_Type_HTML;
const int Document_Type_Type_ARRAYSIZE = Document_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Document_Type_descriptor();
inline const ::std::string& Document_Type_Name(Document_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Document_Type_descriptor(), value);
}
inline bool Document_Type_Parse(
    const ::std::string& name, Document_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Document_Type>(
    Document_Type_descriptor(), name, value);
}
enum Entity_Type {
  Entity_Type_UNKNOWN = 0,
  Entity_Type_PERSON = 1,
  Entity_Type_LOCATION = 2,
  Entity_Type_ORGANIZATION = 3,
  Entity_Type_EVENT = 4,
  Entity_Type_WORK_OF_ART = 5,
  Entity_Type_CONSUMER_GOOD = 6,
  Entity_Type_OTHER = 7,
  Entity_Type_Entity_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Entity_Type_Entity_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Entity_Type_IsValid(int value);
const Entity_Type Entity_Type_Type_MIN = Entity_Type_UNKNOWN;
const Entity_Type Entity_Type_Type_MAX = Entity_Type_OTHER;
const int Entity_Type_Type_ARRAYSIZE = Entity_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Entity_Type_descriptor();
inline const ::std::string& Entity_Type_Name(Entity_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Entity_Type_descriptor(), value);
}
inline bool Entity_Type_Parse(
    const ::std::string& name, Entity_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Entity_Type>(
    Entity_Type_descriptor(), name, value);
}
enum PartOfSpeech_Tag {
  PartOfSpeech_Tag_UNKNOWN = 0,
  PartOfSpeech_Tag_ADJ = 1,
  PartOfSpeech_Tag_ADP = 2,
  PartOfSpeech_Tag_ADV = 3,
  PartOfSpeech_Tag_CONJ = 4,
  PartOfSpeech_Tag_DET = 5,
  PartOfSpeech_Tag_NOUN = 6,
  PartOfSpeech_Tag_NUM = 7,
  PartOfSpeech_Tag_PRON = 8,
  PartOfSpeech_Tag_PRT = 9,
  PartOfSpeech_Tag_PUNCT = 10,
  PartOfSpeech_Tag_VERB = 11,
  PartOfSpeech_Tag_X = 12,
  PartOfSpeech_Tag_AFFIX = 13,
  PartOfSpeech_Tag_PartOfSpeech_Tag_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Tag_PartOfSpeech_Tag_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Tag_IsValid(int value);
const PartOfSpeech_Tag PartOfSpeech_Tag_Tag_MIN = PartOfSpeech_Tag_UNKNOWN;
const PartOfSpeech_Tag PartOfSpeech_Tag_Tag_MAX = PartOfSpeech_Tag_AFFIX;
const int PartOfSpeech_Tag_Tag_ARRAYSIZE = PartOfSpeech_Tag_Tag_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Tag_descriptor();
inline const ::std::string& PartOfSpeech_Tag_Name(PartOfSpeech_Tag value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Tag_descriptor(), value);
}
inline bool PartOfSpeech_Tag_Parse(
    const ::std::string& name, PartOfSpeech_Tag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Tag>(
    PartOfSpeech_Tag_descriptor(), name, value);
}
enum PartOfSpeech_Aspect {
  PartOfSpeech_Aspect_ASPECT_UNKNOWN = 0,
  PartOfSpeech_Aspect_PERFECTIVE = 1,
  PartOfSpeech_Aspect_IMPERFECTIVE = 2,
  PartOfSpeech_Aspect_PROGRESSIVE = 3,
  PartOfSpeech_Aspect_PartOfSpeech_Aspect_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Aspect_PartOfSpeech_Aspect_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Aspect_IsValid(int value);
const PartOfSpeech_Aspect PartOfSpeech_Aspect_Aspect_MIN = PartOfSpeech_Aspect_ASPECT_UNKNOWN;
const PartOfSpeech_Aspect PartOfSpeech_Aspect_Aspect_MAX = PartOfSpeech_Aspect_PROGRESSIVE;
const int PartOfSpeech_Aspect_Aspect_ARRAYSIZE = PartOfSpeech_Aspect_Aspect_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Aspect_descriptor();
inline const ::std::string& PartOfSpeech_Aspect_Name(PartOfSpeech_Aspect value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Aspect_descriptor(), value);
}
inline bool PartOfSpeech_Aspect_Parse(
    const ::std::string& name, PartOfSpeech_Aspect* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Aspect>(
    PartOfSpeech_Aspect_descriptor(), name, value);
}
enum PartOfSpeech_Case {
  PartOfSpeech_Case_CASE_UNKNOWN = 0,
  PartOfSpeech_Case_ACCUSATIVE = 1,
  PartOfSpeech_Case_ADVERBIAL = 2,
  PartOfSpeech_Case_COMPLEMENTIVE = 3,
  PartOfSpeech_Case_DATIVE = 4,
  PartOfSpeech_Case_GENITIVE = 5,
  PartOfSpeech_Case_INSTRUMENTAL = 6,
  PartOfSpeech_Case_LOCATIVE = 7,
  PartOfSpeech_Case_NOMINATIVE = 8,
  PartOfSpeech_Case_OBLIQUE = 9,
  PartOfSpeech_Case_PARTITIVE = 10,
  PartOfSpeech_Case_PREPOSITIONAL = 11,
  PartOfSpeech_Case_REFLEXIVE_CASE = 12,
  PartOfSpeech_Case_RELATIVE_CASE = 13,
  PartOfSpeech_Case_VOCATIVE = 14,
  PartOfSpeech_Case_PartOfSpeech_Case_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Case_PartOfSpeech_Case_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Case_IsValid(int value);
const PartOfSpeech_Case PartOfSpeech_Case_Case_MIN = PartOfSpeech_Case_CASE_UNKNOWN;
const PartOfSpeech_Case PartOfSpeech_Case_Case_MAX = PartOfSpeech_Case_VOCATIVE;
const int PartOfSpeech_Case_Case_ARRAYSIZE = PartOfSpeech_Case_Case_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Case_descriptor();
inline const ::std::string& PartOfSpeech_Case_Name(PartOfSpeech_Case value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Case_descriptor(), value);
}
inline bool PartOfSpeech_Case_Parse(
    const ::std::string& name, PartOfSpeech_Case* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Case>(
    PartOfSpeech_Case_descriptor(), name, value);
}
enum PartOfSpeech_Form {
  PartOfSpeech_Form_FORM_UNKNOWN = 0,
  PartOfSpeech_Form_ADNOMIAL = 1,
  PartOfSpeech_Form_AUXILIARY = 2,
  PartOfSpeech_Form_COMPLEMENTIZER = 3,
  PartOfSpeech_Form_FINAL_ENDING = 4,
  PartOfSpeech_Form_GERUND = 5,
  PartOfSpeech_Form_REALIS = 6,
  PartOfSpeech_Form_IRREALIS = 7,
  PartOfSpeech_Form_SHORT = 8,
  PartOfSpeech_Form_LONG = 9,
  PartOfSpeech_Form_ORDER = 10,
  PartOfSpeech_Form_SPECIFIC = 11,
  PartOfSpeech_Form_PartOfSpeech_Form_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Form_PartOfSpeech_Form_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Form_IsValid(int value);
const PartOfSpeech_Form PartOfSpeech_Form_Form_MIN = PartOfSpeech_Form_FORM_UNKNOWN;
const PartOfSpeech_Form PartOfSpeech_Form_Form_MAX = PartOfSpeech_Form_SPECIFIC;
const int PartOfSpeech_Form_Form_ARRAYSIZE = PartOfSpeech_Form_Form_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Form_descriptor();
inline const ::std::string& PartOfSpeech_Form_Name(PartOfSpeech_Form value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Form_descriptor(), value);
}
inline bool PartOfSpeech_Form_Parse(
    const ::std::string& name, PartOfSpeech_Form* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Form>(
    PartOfSpeech_Form_descriptor(), name, value);
}
enum PartOfSpeech_Gender {
  PartOfSpeech_Gender_GENDER_UNKNOWN = 0,
  PartOfSpeech_Gender_FEMININE = 1,
  PartOfSpeech_Gender_MASCULINE = 2,
  PartOfSpeech_Gender_NEUTER = 3,
  PartOfSpeech_Gender_PartOfSpeech_Gender_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Gender_PartOfSpeech_Gender_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Gender_IsValid(int value);
const PartOfSpeech_Gender PartOfSpeech_Gender_Gender_MIN = PartOfSpeech_Gender_GENDER_UNKNOWN;
const PartOfSpeech_Gender PartOfSpeech_Gender_Gender_MAX = PartOfSpeech_Gender_NEUTER;
const int PartOfSpeech_Gender_Gender_ARRAYSIZE = PartOfSpeech_Gender_Gender_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Gender_descriptor();
inline const ::std::string& PartOfSpeech_Gender_Name(PartOfSpeech_Gender value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Gender_descriptor(), value);
}
inline bool PartOfSpeech_Gender_Parse(
    const ::std::string& name, PartOfSpeech_Gender* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Gender>(
    PartOfSpeech_Gender_descriptor(), name, value);
}
enum PartOfSpeech_Mood {
  PartOfSpeech_Mood_MOOD_UNKNOWN = 0,
  PartOfSpeech_Mood_CONDITIONAL_MOOD = 1,
  PartOfSpeech_Mood_IMPERATIVE = 2,
  PartOfSpeech_Mood_INDICATIVE = 3,
  PartOfSpeech_Mood_INTERROGATIVE = 4,
  PartOfSpeech_Mood_JUSSIVE = 5,
  PartOfSpeech_Mood_SUBJUNCTIVE = 6,
  PartOfSpeech_Mood_PartOfSpeech_Mood_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Mood_PartOfSpeech_Mood_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Mood_IsValid(int value);
const PartOfSpeech_Mood PartOfSpeech_Mood_Mood_MIN = PartOfSpeech_Mood_MOOD_UNKNOWN;
const PartOfSpeech_Mood PartOfSpeech_Mood_Mood_MAX = PartOfSpeech_Mood_SUBJUNCTIVE;
const int PartOfSpeech_Mood_Mood_ARRAYSIZE = PartOfSpeech_Mood_Mood_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Mood_descriptor();
inline const ::std::string& PartOfSpeech_Mood_Name(PartOfSpeech_Mood value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Mood_descriptor(), value);
}
inline bool PartOfSpeech_Mood_Parse(
    const ::std::string& name, PartOfSpeech_Mood* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Mood>(
    PartOfSpeech_Mood_descriptor(), name, value);
}
enum PartOfSpeech_Number {
  PartOfSpeech_Number_NUMBER_UNKNOWN = 0,
  PartOfSpeech_Number_SINGULAR = 1,
  PartOfSpeech_Number_PLURAL = 2,
  PartOfSpeech_Number_DUAL = 3,
  PartOfSpeech_Number_PartOfSpeech_Number_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Number_PartOfSpeech_Number_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Number_IsValid(int value);
const PartOfSpeech_Number PartOfSpeech_Number_Number_MIN = PartOfSpeech_Number_NUMBER_UNKNOWN;
const PartOfSpeech_Number PartOfSpeech_Number_Number_MAX = PartOfSpeech_Number_DUAL;
const int PartOfSpeech_Number_Number_ARRAYSIZE = PartOfSpeech_Number_Number_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Number_descriptor();
inline const ::std::string& PartOfSpeech_Number_Name(PartOfSpeech_Number value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Number_descriptor(), value);
}
inline bool PartOfSpeech_Number_Parse(
    const ::std::string& name, PartOfSpeech_Number* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Number>(
    PartOfSpeech_Number_descriptor(), name, value);
}
enum PartOfSpeech_Person {
  PartOfSpeech_Person_PERSON_UNKNOWN = 0,
  PartOfSpeech_Person_FIRST = 1,
  PartOfSpeech_Person_SECOND = 2,
  PartOfSpeech_Person_THIRD = 3,
  PartOfSpeech_Person_REFLEXIVE_PERSON = 4,
  PartOfSpeech_Person_PartOfSpeech_Person_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Person_PartOfSpeech_Person_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Person_IsValid(int value);
const PartOfSpeech_Person PartOfSpeech_Person_Person_MIN = PartOfSpeech_Person_PERSON_UNKNOWN;
const PartOfSpeech_Person PartOfSpeech_Person_Person_MAX = PartOfSpeech_Person_REFLEXIVE_PERSON;
const int PartOfSpeech_Person_Person_ARRAYSIZE = PartOfSpeech_Person_Person_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Person_descriptor();
inline const ::std::string& PartOfSpeech_Person_Name(PartOfSpeech_Person value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Person_descriptor(), value);
}
inline bool PartOfSpeech_Person_Parse(
    const ::std::string& name, PartOfSpeech_Person* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Person>(
    PartOfSpeech_Person_descriptor(), name, value);
}
enum PartOfSpeech_Proper {
  PartOfSpeech_Proper_PROPER_UNKNOWN = 0,
  PartOfSpeech_Proper_PROPER = 1,
  PartOfSpeech_Proper_NOT_PROPER = 2,
  PartOfSpeech_Proper_PartOfSpeech_Proper_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Proper_PartOfSpeech_Proper_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Proper_IsValid(int value);
const PartOfSpeech_Proper PartOfSpeech_Proper_Proper_MIN = PartOfSpeech_Proper_PROPER_UNKNOWN;
const PartOfSpeech_Proper PartOfSpeech_Proper_Proper_MAX = PartOfSpeech_Proper_NOT_PROPER;
const int PartOfSpeech_Proper_Proper_ARRAYSIZE = PartOfSpeech_Proper_Proper_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Proper_descriptor();
inline const ::std::string& PartOfSpeech_Proper_Name(PartOfSpeech_Proper value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Proper_descriptor(), value);
}
inline bool PartOfSpeech_Proper_Parse(
    const ::std::string& name, PartOfSpeech_Proper* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Proper>(
    PartOfSpeech_Proper_descriptor(), name, value);
}
enum PartOfSpeech_Reciprocity {
  PartOfSpeech_Reciprocity_RECIPROCITY_UNKNOWN = 0,
  PartOfSpeech_Reciprocity_RECIPROCAL = 1,
  PartOfSpeech_Reciprocity_NON_RECIPROCAL = 2,
  PartOfSpeech_Reciprocity_PartOfSpeech_Reciprocity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Reciprocity_PartOfSpeech_Reciprocity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Reciprocity_IsValid(int value);
const PartOfSpeech_Reciprocity PartOfSpeech_Reciprocity_Reciprocity_MIN = PartOfSpeech_Reciprocity_RECIPROCITY_UNKNOWN;
const PartOfSpeech_Reciprocity PartOfSpeech_Reciprocity_Reciprocity_MAX = PartOfSpeech_Reciprocity_NON_RECIPROCAL;
const int PartOfSpeech_Reciprocity_Reciprocity_ARRAYSIZE = PartOfSpeech_Reciprocity_Reciprocity_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Reciprocity_descriptor();
inline const ::std::string& PartOfSpeech_Reciprocity_Name(PartOfSpeech_Reciprocity value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Reciprocity_descriptor(), value);
}
inline bool PartOfSpeech_Reciprocity_Parse(
    const ::std::string& name, PartOfSpeech_Reciprocity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Reciprocity>(
    PartOfSpeech_Reciprocity_descriptor(), name, value);
}
enum PartOfSpeech_Tense {
  PartOfSpeech_Tense_TENSE_UNKNOWN = 0,
  PartOfSpeech_Tense_CONDITIONAL_TENSE = 1,
  PartOfSpeech_Tense_FUTURE = 2,
  PartOfSpeech_Tense_PAST = 3,
  PartOfSpeech_Tense_PRESENT = 4,
  PartOfSpeech_Tense_IMPERFECT = 5,
  PartOfSpeech_Tense_PLUPERFECT = 6,
  PartOfSpeech_Tense_PartOfSpeech_Tense_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Tense_PartOfSpeech_Tense_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Tense_IsValid(int value);
const PartOfSpeech_Tense PartOfSpeech_Tense_Tense_MIN = PartOfSpeech_Tense_TENSE_UNKNOWN;
const PartOfSpeech_Tense PartOfSpeech_Tense_Tense_MAX = PartOfSpeech_Tense_PLUPERFECT;
const int PartOfSpeech_Tense_Tense_ARRAYSIZE = PartOfSpeech_Tense_Tense_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Tense_descriptor();
inline const ::std::string& PartOfSpeech_Tense_Name(PartOfSpeech_Tense value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Tense_descriptor(), value);
}
inline bool PartOfSpeech_Tense_Parse(
    const ::std::string& name, PartOfSpeech_Tense* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Tense>(
    PartOfSpeech_Tense_descriptor(), name, value);
}
enum PartOfSpeech_Voice {
  PartOfSpeech_Voice_VOICE_UNKNOWN = 0,
  PartOfSpeech_Voice_ACTIVE = 1,
  PartOfSpeech_Voice_CAUSATIVE = 2,
  PartOfSpeech_Voice_PASSIVE = 3,
  PartOfSpeech_Voice_PartOfSpeech_Voice_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PartOfSpeech_Voice_PartOfSpeech_Voice_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PartOfSpeech_Voice_IsValid(int value);
const PartOfSpeech_Voice PartOfSpeech_Voice_Voice_MIN = PartOfSpeech_Voice_VOICE_UNKNOWN;
const PartOfSpeech_Voice PartOfSpeech_Voice_Voice_MAX = PartOfSpeech_Voice_PASSIVE;
const int PartOfSpeech_Voice_Voice_ARRAYSIZE = PartOfSpeech_Voice_Voice_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartOfSpeech_Voice_descriptor();
inline const ::std::string& PartOfSpeech_Voice_Name(PartOfSpeech_Voice value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartOfSpeech_Voice_descriptor(), value);
}
inline bool PartOfSpeech_Voice_Parse(
    const ::std::string& name, PartOfSpeech_Voice* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartOfSpeech_Voice>(
    PartOfSpeech_Voice_descriptor(), name, value);
}
enum DependencyEdge_Label {
  DependencyEdge_Label_UNKNOWN = 0,
  DependencyEdge_Label_ABBREV = 1,
  DependencyEdge_Label_ACOMP = 2,
  DependencyEdge_Label_ADVCL = 3,
  DependencyEdge_Label_ADVMOD = 4,
  DependencyEdge_Label_AMOD = 5,
  DependencyEdge_Label_APPOS = 6,
  DependencyEdge_Label_ATTR = 7,
  DependencyEdge_Label_AUX = 8,
  DependencyEdge_Label_AUXPASS = 9,
  DependencyEdge_Label_CC = 10,
  DependencyEdge_Label_CCOMP = 11,
  DependencyEdge_Label_CONJ = 12,
  DependencyEdge_Label_CSUBJ = 13,
  DependencyEdge_Label_CSUBJPASS = 14,
  DependencyEdge_Label_DEP = 15,
  DependencyEdge_Label_DET = 16,
  DependencyEdge_Label_DISCOURSE = 17,
  DependencyEdge_Label_DOBJ = 18,
  DependencyEdge_Label_EXPL = 19,
  DependencyEdge_Label_GOESWITH = 20,
  DependencyEdge_Label_IOBJ = 21,
  DependencyEdge_Label_MARK = 22,
  DependencyEdge_Label_MWE = 23,
  DependencyEdge_Label_MWV = 24,
  DependencyEdge_Label_NEG = 25,
  DependencyEdge_Label_NN = 26,
  DependencyEdge_Label_NPADVMOD = 27,
  DependencyEdge_Label_NSUBJ = 28,
  DependencyEdge_Label_NSUBJPASS = 29,
  DependencyEdge_Label_NUM = 30,
  DependencyEdge_Label_NUMBER = 31,
  DependencyEdge_Label_P = 32,
  DependencyEdge_Label_PARATAXIS = 33,
  DependencyEdge_Label_PARTMOD = 34,
  DependencyEdge_Label_PCOMP = 35,
  DependencyEdge_Label_POBJ = 36,
  DependencyEdge_Label_POSS = 37,
  DependencyEdge_Label_POSTNEG = 38,
  DependencyEdge_Label_PRECOMP = 39,
  DependencyEdge_Label_PRECONJ = 40,
  DependencyEdge_Label_PREDET = 41,
  DependencyEdge_Label_PREF = 42,
  DependencyEdge_Label_PREP = 43,
  DependencyEdge_Label_PRONL = 44,
  DependencyEdge_Label_PRT = 45,
  DependencyEdge_Label_PS = 46,
  DependencyEdge_Label_QUANTMOD = 47,
  DependencyEdge_Label_RCMOD = 48,
  DependencyEdge_Label_RCMODREL = 49,
  DependencyEdge_Label_RDROP = 50,
  DependencyEdge_Label_REF = 51,
  DependencyEdge_Label_REMNANT = 52,
  DependencyEdge_Label_REPARANDUM = 53,
  DependencyEdge_Label_ROOT = 54,
  DependencyEdge_Label_SNUM = 55,
  DependencyEdge_Label_SUFF = 56,
  DependencyEdge_Label_TMOD = 57,
  DependencyEdge_Label_TOPIC = 58,
  DependencyEdge_Label_VMOD = 59,
  DependencyEdge_Label_VOCATIVE = 60,
  DependencyEdge_Label_XCOMP = 61,
  DependencyEdge_Label_SUFFIX = 62,
  DependencyEdge_Label_TITLE = 63,
  DependencyEdge_Label_ADVPHMOD = 64,
  DependencyEdge_Label_AUXCAUS = 65,
  DependencyEdge_Label_AUXVV = 66,
  DependencyEdge_Label_DTMOD = 67,
  DependencyEdge_Label_FOREIGN = 68,
  DependencyEdge_Label_KW = 69,
  DependencyEdge_Label_LIST = 70,
  DependencyEdge_Label_NOMC = 71,
  DependencyEdge_Label_NOMCSUBJ = 72,
  DependencyEdge_Label_NOMCSUBJPASS = 73,
  DependencyEdge_Label_NUMC = 74,
  DependencyEdge_Label_COP = 75,
  DependencyEdge_Label_DISLOCATED = 76,
  DependencyEdge_Label_ASP = 77,
  DependencyEdge_Label_GMOD = 78,
  DependencyEdge_Label_GOBJ = 79,
  DependencyEdge_Label_INFMOD = 80,
  DependencyEdge_Label_MES = 81,
  DependencyEdge_Label_NCOMP = 82,
  DependencyEdge_Label_DependencyEdge_Label_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DependencyEdge_Label_DependencyEdge_Label_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DependencyEdge_Label_IsValid(int value);
const DependencyEdge_Label DependencyEdge_Label_Label_MIN = DependencyEdge_Label_UNKNOWN;
const DependencyEdge_Label DependencyEdge_Label_Label_MAX = DependencyEdge_Label_NCOMP;
const int DependencyEdge_Label_Label_ARRAYSIZE = DependencyEdge_Label_Label_MAX + 1;

const ::google::protobuf::EnumDescriptor* DependencyEdge_Label_descriptor();
inline const ::std::string& DependencyEdge_Label_Name(DependencyEdge_Label value) {
  return ::google::protobuf::internal::NameOfEnum(
    DependencyEdge_Label_descriptor(), value);
}
inline bool DependencyEdge_Label_Parse(
    const ::std::string& name, DependencyEdge_Label* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DependencyEdge_Label>(
    DependencyEdge_Label_descriptor(), name, value);
}
enum EntityMention_Type {
  EntityMention_Type_TYPE_UNKNOWN = 0,
  EntityMention_Type_PROPER = 1,
  EntityMention_Type_COMMON = 2,
  EntityMention_Type_EntityMention_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EntityMention_Type_EntityMention_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EntityMention_Type_IsValid(int value);
const EntityMention_Type EntityMention_Type_Type_MIN = EntityMention_Type_TYPE_UNKNOWN;
const EntityMention_Type EntityMention_Type_Type_MAX = EntityMention_Type_COMMON;
const int EntityMention_Type_Type_ARRAYSIZE = EntityMention_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityMention_Type_descriptor();
inline const ::std::string& EntityMention_Type_Name(EntityMention_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityMention_Type_descriptor(), value);
}
inline bool EntityMention_Type_Parse(
    const ::std::string& name, EntityMention_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityMention_Type>(
    EntityMention_Type_descriptor(), name, value);
}
enum EncodingType {
  NONE = 0,
  UTF8 = 1,
  UTF16 = 2,
  UTF32 = 3,
  EncodingType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EncodingType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EncodingType_IsValid(int value);
const EncodingType EncodingType_MIN = NONE;
const EncodingType EncodingType_MAX = UTF32;
const int EncodingType_ARRAYSIZE = EncodingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EncodingType_descriptor();
inline const ::std::string& EncodingType_Name(EncodingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EncodingType_descriptor(), value);
}
inline bool EncodingType_Parse(
    const ::std::string& name, EncodingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncodingType>(
    EncodingType_descriptor(), name, value);
}
// ===================================================================

class Document : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.Document) */ {
 public:
  Document();
  virtual ~Document();

  Document(const Document& from);

  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Document(Document&& from) noexcept
    : Document() {
    *this = ::std::move(from);
  }

  inline Document& operator=(Document&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Document& default_instance();

  enum SourceCase {
    kContent = 2,
    kGcsContentUri = 3,
    SOURCE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Document* internal_default_instance() {
    return reinterpret_cast<const Document*>(
               &_Document_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Document* other);
  friend void swap(Document& a, Document& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Document* New() const PROTOBUF_FINAL { return New(NULL); }

  Document* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Document& from);
  void MergeFrom(const Document& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Document* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Document_Type Type;
  static const Type TYPE_UNSPECIFIED =
    Document_Type_TYPE_UNSPECIFIED;
  static const Type PLAIN_TEXT =
    Document_Type_PLAIN_TEXT;
  static const Type HTML =
    Document_Type_HTML;
  static inline bool Type_IsValid(int value) {
    return Document_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Document_Type_Type_MIN;
  static const Type Type_MAX =
    Document_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Document_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Document_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Document_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Document_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string language = 4;
  void clear_language();
  static const int kLanguageFieldNumber = 4;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // .google.cloud.language.v1beta2.Document.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::cloud::language::v1beta2::Document_Type type() const;
  void set_type(::google::cloud::language::v1beta2::Document_Type value);

  // string content = 2;
  private:
  bool has_content() const;
  public:
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // string gcs_content_uri = 3;
  private:
  bool has_gcs_content_uri() const;
  public:
  void clear_gcs_content_uri();
  static const int kGcsContentUriFieldNumber = 3;
  const ::std::string& gcs_content_uri() const;
  void set_gcs_content_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_gcs_content_uri(::std::string&& value);
  #endif
  void set_gcs_content_uri(const char* value);
  void set_gcs_content_uri(const char* value, size_t size);
  ::std::string* mutable_gcs_content_uri();
  ::std::string* release_gcs_content_uri();
  void set_allocated_gcs_content_uri(::std::string* gcs_content_uri);

  SourceCase source_case() const;
  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.Document)
 private:
  void set_has_content();
  void set_has_gcs_content_uri();

  inline bool has_source() const;
  void clear_source();
  inline void clear_has_source();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  int type_;
  union SourceUnion {
    SourceUnion() {}
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::google::protobuf::internal::ArenaStringPtr gcs_content_uri_;
  } source_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsDocumentImpl();
};
// -------------------------------------------------------------------

class Sentence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.Sentence) */ {
 public:
  Sentence();
  virtual ~Sentence();

  Sentence(const Sentence& from);

  inline Sentence& operator=(const Sentence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sentence(Sentence&& from) noexcept
    : Sentence() {
    *this = ::std::move(from);
  }

  inline Sentence& operator=(Sentence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sentence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sentence* internal_default_instance() {
    return reinterpret_cast<const Sentence*>(
               &_Sentence_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Sentence* other);
  friend void swap(Sentence& a, Sentence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sentence* New() const PROTOBUF_FINAL { return New(NULL); }

  Sentence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Sentence& from);
  void MergeFrom(const Sentence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Sentence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.cloud.language.v1beta2.TextSpan text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::google::cloud::language::v1beta2::TextSpan& text() const;
  ::google::cloud::language::v1beta2::TextSpan* release_text();
  ::google::cloud::language::v1beta2::TextSpan* mutable_text();
  void set_allocated_text(::google::cloud::language::v1beta2::TextSpan* text);

  // .google.cloud.language.v1beta2.Sentiment sentiment = 2;
  bool has_sentiment() const;
  void clear_sentiment();
  static const int kSentimentFieldNumber = 2;
  const ::google::cloud::language::v1beta2::Sentiment& sentiment() const;
  ::google::cloud::language::v1beta2::Sentiment* release_sentiment();
  ::google::cloud::language::v1beta2::Sentiment* mutable_sentiment();
  void set_allocated_sentiment(::google::cloud::language::v1beta2::Sentiment* sentiment);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.Sentence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::cloud::language::v1beta2::TextSpan* text_;
  ::google::cloud::language::v1beta2::Sentiment* sentiment_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsSentenceImpl();
};
// -------------------------------------------------------------------

class Entity_MetadataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Entity_MetadataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Entity_MetadataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Entity_MetadataEntry_DoNotUse();
  Entity_MetadataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Entity_MetadataEntry_DoNotUse& other);
  static const Entity_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Entity_MetadataEntry_DoNotUse*>(&_Entity_MetadataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.Entity) */ {
 public:
  Entity();
  virtual ~Entity();

  Entity(const Entity& from);

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Entity(Entity&& from) noexcept
    : Entity() {
    *this = ::std::move(from);
  }

  inline Entity& operator=(Entity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Entity* internal_default_instance() {
    return reinterpret_cast<const Entity*>(
               &_Entity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Entity* other);
  friend void swap(Entity& a, Entity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Entity* New() const PROTOBUF_FINAL { return New(NULL); }

  Entity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Entity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  typedef Entity_Type Type;
  static const Type UNKNOWN =
    Entity_Type_UNKNOWN;
  static const Type PERSON =
    Entity_Type_PERSON;
  static const Type LOCATION =
    Entity_Type_LOCATION;
  static const Type ORGANIZATION =
    Entity_Type_ORGANIZATION;
  static const Type EVENT =
    Entity_Type_EVENT;
  static const Type WORK_OF_ART =
    Entity_Type_WORK_OF_ART;
  static const Type CONSUMER_GOOD =
    Entity_Type_CONSUMER_GOOD;
  static const Type OTHER =
    Entity_Type_OTHER;
  static inline bool Type_IsValid(int value) {
    return Entity_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Entity_Type_Type_MIN;
  static const Type Type_MAX =
    Entity_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Entity_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Entity_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Entity_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Entity_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // map<string, string> metadata = 3;
  int metadata_size() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      metadata() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_metadata();

  // repeated .google.cloud.language.v1beta2.EntityMention mentions = 5;
  int mentions_size() const;
  void clear_mentions();
  static const int kMentionsFieldNumber = 5;
  const ::google::cloud::language::v1beta2::EntityMention& mentions(int index) const;
  ::google::cloud::language::v1beta2::EntityMention* mutable_mentions(int index);
  ::google::cloud::language::v1beta2::EntityMention* add_mentions();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::EntityMention >*
      mutable_mentions();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::EntityMention >&
      mentions() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .google.cloud.language.v1beta2.Sentiment sentiment = 6;
  bool has_sentiment() const;
  void clear_sentiment();
  static const int kSentimentFieldNumber = 6;
  const ::google::cloud::language::v1beta2::Sentiment& sentiment() const;
  ::google::cloud::language::v1beta2::Sentiment* release_sentiment();
  ::google::cloud::language::v1beta2::Sentiment* mutable_sentiment();
  void set_allocated_sentiment(::google::cloud::language::v1beta2::Sentiment* sentiment);

  // .google.cloud.language.v1beta2.Entity.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::cloud::language::v1beta2::Entity_Type type() const;
  void set_type(::google::cloud::language::v1beta2::Entity_Type value);

  // float salience = 4;
  void clear_salience();
  static const int kSalienceFieldNumber = 4;
  float salience() const;
  void set_salience(float value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.Entity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Entity_MetadataEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::EntityMention > mentions_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::cloud::language::v1beta2::Sentiment* sentiment_;
  int type_;
  float salience_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsEntityImpl();
};
// -------------------------------------------------------------------

class Token : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.Token) */ {
 public:
  Token();
  virtual ~Token();

  Token(const Token& from);

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(Token&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Token& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Token* other);
  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Token* New() const PROTOBUF_FINAL { return New(NULL); }

  Token* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Token* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string lemma = 4;
  void clear_lemma();
  static const int kLemmaFieldNumber = 4;
  const ::std::string& lemma() const;
  void set_lemma(const ::std::string& value);
  #if LANG_CXX11
  void set_lemma(::std::string&& value);
  #endif
  void set_lemma(const char* value);
  void set_lemma(const char* value, size_t size);
  ::std::string* mutable_lemma();
  ::std::string* release_lemma();
  void set_allocated_lemma(::std::string* lemma);

  // .google.cloud.language.v1beta2.TextSpan text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::google::cloud::language::v1beta2::TextSpan& text() const;
  ::google::cloud::language::v1beta2::TextSpan* release_text();
  ::google::cloud::language::v1beta2::TextSpan* mutable_text();
  void set_allocated_text(::google::cloud::language::v1beta2::TextSpan* text);

  // .google.cloud.language.v1beta2.PartOfSpeech part_of_speech = 2;
  bool has_part_of_speech() const;
  void clear_part_of_speech();
  static const int kPartOfSpeechFieldNumber = 2;
  const ::google::cloud::language::v1beta2::PartOfSpeech& part_of_speech() const;
  ::google::cloud::language::v1beta2::PartOfSpeech* release_part_of_speech();
  ::google::cloud::language::v1beta2::PartOfSpeech* mutable_part_of_speech();
  void set_allocated_part_of_speech(::google::cloud::language::v1beta2::PartOfSpeech* part_of_speech);

  // .google.cloud.language.v1beta2.DependencyEdge dependency_edge = 3;
  bool has_dependency_edge() const;
  void clear_dependency_edge();
  static const int kDependencyEdgeFieldNumber = 3;
  const ::google::cloud::language::v1beta2::DependencyEdge& dependency_edge() const;
  ::google::cloud::language::v1beta2::DependencyEdge* release_dependency_edge();
  ::google::cloud::language::v1beta2::DependencyEdge* mutable_dependency_edge();
  void set_allocated_dependency_edge(::google::cloud::language::v1beta2::DependencyEdge* dependency_edge);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.Token)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr lemma_;
  ::google::cloud::language::v1beta2::TextSpan* text_;
  ::google::cloud::language::v1beta2::PartOfSpeech* part_of_speech_;
  ::google::cloud::language::v1beta2::DependencyEdge* dependency_edge_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsTokenImpl();
};
// -------------------------------------------------------------------

class Sentiment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.Sentiment) */ {
 public:
  Sentiment();
  virtual ~Sentiment();

  Sentiment(const Sentiment& from);

  inline Sentiment& operator=(const Sentiment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sentiment(Sentiment&& from) noexcept
    : Sentiment() {
    *this = ::std::move(from);
  }

  inline Sentiment& operator=(Sentiment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sentiment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sentiment* internal_default_instance() {
    return reinterpret_cast<const Sentiment*>(
               &_Sentiment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Sentiment* other);
  friend void swap(Sentiment& a, Sentiment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sentiment* New() const PROTOBUF_FINAL { return New(NULL); }

  Sentiment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Sentiment& from);
  void MergeFrom(const Sentiment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Sentiment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float magnitude = 2;
  void clear_magnitude();
  static const int kMagnitudeFieldNumber = 2;
  float magnitude() const;
  void set_magnitude(float value);

  // float score = 3;
  void clear_score();
  static const int kScoreFieldNumber = 3;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.Sentiment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float magnitude_;
  float score_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsSentimentImpl();
};
// -------------------------------------------------------------------

class PartOfSpeech : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.PartOfSpeech) */ {
 public:
  PartOfSpeech();
  virtual ~PartOfSpeech();

  PartOfSpeech(const PartOfSpeech& from);

  inline PartOfSpeech& operator=(const PartOfSpeech& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartOfSpeech(PartOfSpeech&& from) noexcept
    : PartOfSpeech() {
    *this = ::std::move(from);
  }

  inline PartOfSpeech& operator=(PartOfSpeech&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartOfSpeech& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartOfSpeech* internal_default_instance() {
    return reinterpret_cast<const PartOfSpeech*>(
               &_PartOfSpeech_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(PartOfSpeech* other);
  friend void swap(PartOfSpeech& a, PartOfSpeech& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartOfSpeech* New() const PROTOBUF_FINAL { return New(NULL); }

  PartOfSpeech* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartOfSpeech& from);
  void MergeFrom(const PartOfSpeech& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartOfSpeech* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PartOfSpeech_Tag Tag;
  static const Tag UNKNOWN =
    PartOfSpeech_Tag_UNKNOWN;
  static const Tag ADJ =
    PartOfSpeech_Tag_ADJ;
  static const Tag ADP =
    PartOfSpeech_Tag_ADP;
  static const Tag ADV =
    PartOfSpeech_Tag_ADV;
  static const Tag CONJ =
    PartOfSpeech_Tag_CONJ;
  static const Tag DET =
    PartOfSpeech_Tag_DET;
  static const Tag NOUN =
    PartOfSpeech_Tag_NOUN;
  static const Tag NUM =
    PartOfSpeech_Tag_NUM;
  static const Tag PRON =
    PartOfSpeech_Tag_PRON;
  static const Tag PRT =
    PartOfSpeech_Tag_PRT;
  static const Tag PUNCT =
    PartOfSpeech_Tag_PUNCT;
  static const Tag VERB =
    PartOfSpeech_Tag_VERB;
  static const Tag X =
    PartOfSpeech_Tag_X;
  static const Tag AFFIX =
    PartOfSpeech_Tag_AFFIX;
  static inline bool Tag_IsValid(int value) {
    return PartOfSpeech_Tag_IsValid(value);
  }
  static const Tag Tag_MIN =
    PartOfSpeech_Tag_Tag_MIN;
  static const Tag Tag_MAX =
    PartOfSpeech_Tag_Tag_MAX;
  static const int Tag_ARRAYSIZE =
    PartOfSpeech_Tag_Tag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Tag_descriptor() {
    return PartOfSpeech_Tag_descriptor();
  }
  static inline const ::std::string& Tag_Name(Tag value) {
    return PartOfSpeech_Tag_Name(value);
  }
  static inline bool Tag_Parse(const ::std::string& name,
      Tag* value) {
    return PartOfSpeech_Tag_Parse(name, value);
  }

  typedef PartOfSpeech_Aspect Aspect;
  static const Aspect ASPECT_UNKNOWN =
    PartOfSpeech_Aspect_ASPECT_UNKNOWN;
  static const Aspect PERFECTIVE =
    PartOfSpeech_Aspect_PERFECTIVE;
  static const Aspect IMPERFECTIVE =
    PartOfSpeech_Aspect_IMPERFECTIVE;
  static const Aspect PROGRESSIVE =
    PartOfSpeech_Aspect_PROGRESSIVE;
  static inline bool Aspect_IsValid(int value) {
    return PartOfSpeech_Aspect_IsValid(value);
  }
  static const Aspect Aspect_MIN =
    PartOfSpeech_Aspect_Aspect_MIN;
  static const Aspect Aspect_MAX =
    PartOfSpeech_Aspect_Aspect_MAX;
  static const int Aspect_ARRAYSIZE =
    PartOfSpeech_Aspect_Aspect_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Aspect_descriptor() {
    return PartOfSpeech_Aspect_descriptor();
  }
  static inline const ::std::string& Aspect_Name(Aspect value) {
    return PartOfSpeech_Aspect_Name(value);
  }
  static inline bool Aspect_Parse(const ::std::string& name,
      Aspect* value) {
    return PartOfSpeech_Aspect_Parse(name, value);
  }

  typedef PartOfSpeech_Case Case;
  static const Case CASE_UNKNOWN =
    PartOfSpeech_Case_CASE_UNKNOWN;
  static const Case ACCUSATIVE =
    PartOfSpeech_Case_ACCUSATIVE;
  static const Case ADVERBIAL =
    PartOfSpeech_Case_ADVERBIAL;
  static const Case COMPLEMENTIVE =
    PartOfSpeech_Case_COMPLEMENTIVE;
  static const Case DATIVE =
    PartOfSpeech_Case_DATIVE;
  static const Case GENITIVE =
    PartOfSpeech_Case_GENITIVE;
  static const Case INSTRUMENTAL =
    PartOfSpeech_Case_INSTRUMENTAL;
  static const Case LOCATIVE =
    PartOfSpeech_Case_LOCATIVE;
  static const Case NOMINATIVE =
    PartOfSpeech_Case_NOMINATIVE;
  static const Case OBLIQUE =
    PartOfSpeech_Case_OBLIQUE;
  static const Case PARTITIVE =
    PartOfSpeech_Case_PARTITIVE;
  static const Case PREPOSITIONAL =
    PartOfSpeech_Case_PREPOSITIONAL;
  static const Case REFLEXIVE_CASE =
    PartOfSpeech_Case_REFLEXIVE_CASE;
  static const Case RELATIVE_CASE =
    PartOfSpeech_Case_RELATIVE_CASE;
  static const Case VOCATIVE =
    PartOfSpeech_Case_VOCATIVE;
  static inline bool Case_IsValid(int value) {
    return PartOfSpeech_Case_IsValid(value);
  }
  static const Case Case_MIN =
    PartOfSpeech_Case_Case_MIN;
  static const Case Case_MAX =
    PartOfSpeech_Case_Case_MAX;
  static const int Case_ARRAYSIZE =
    PartOfSpeech_Case_Case_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Case_descriptor() {
    return PartOfSpeech_Case_descriptor();
  }
  static inline const ::std::string& Case_Name(Case value) {
    return PartOfSpeech_Case_Name(value);
  }
  static inline bool Case_Parse(const ::std::string& name,
      Case* value) {
    return PartOfSpeech_Case_Parse(name, value);
  }

  typedef PartOfSpeech_Form Form;
  static const Form FORM_UNKNOWN =
    PartOfSpeech_Form_FORM_UNKNOWN;
  static const Form ADNOMIAL =
    PartOfSpeech_Form_ADNOMIAL;
  static const Form AUXILIARY =
    PartOfSpeech_Form_AUXILIARY;
  static const Form COMPLEMENTIZER =
    PartOfSpeech_Form_COMPLEMENTIZER;
  static const Form FINAL_ENDING =
    PartOfSpeech_Form_FINAL_ENDING;
  static const Form GERUND =
    PartOfSpeech_Form_GERUND;
  static const Form REALIS =
    PartOfSpeech_Form_REALIS;
  static const Form IRREALIS =
    PartOfSpeech_Form_IRREALIS;
  static const Form SHORT =
    PartOfSpeech_Form_SHORT;
  static const Form LONG =
    PartOfSpeech_Form_LONG;
  static const Form ORDER =
    PartOfSpeech_Form_ORDER;
  static const Form SPECIFIC =
    PartOfSpeech_Form_SPECIFIC;
  static inline bool Form_IsValid(int value) {
    return PartOfSpeech_Form_IsValid(value);
  }
  static const Form Form_MIN =
    PartOfSpeech_Form_Form_MIN;
  static const Form Form_MAX =
    PartOfSpeech_Form_Form_MAX;
  static const int Form_ARRAYSIZE =
    PartOfSpeech_Form_Form_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Form_descriptor() {
    return PartOfSpeech_Form_descriptor();
  }
  static inline const ::std::string& Form_Name(Form value) {
    return PartOfSpeech_Form_Name(value);
  }
  static inline bool Form_Parse(const ::std::string& name,
      Form* value) {
    return PartOfSpeech_Form_Parse(name, value);
  }

  typedef PartOfSpeech_Gender Gender;
  static const Gender GENDER_UNKNOWN =
    PartOfSpeech_Gender_GENDER_UNKNOWN;
  static const Gender FEMININE =
    PartOfSpeech_Gender_FEMININE;
  static const Gender MASCULINE =
    PartOfSpeech_Gender_MASCULINE;
  static const Gender NEUTER =
    PartOfSpeech_Gender_NEUTER;
  static inline bool Gender_IsValid(int value) {
    return PartOfSpeech_Gender_IsValid(value);
  }
  static const Gender Gender_MIN =
    PartOfSpeech_Gender_Gender_MIN;
  static const Gender Gender_MAX =
    PartOfSpeech_Gender_Gender_MAX;
  static const int Gender_ARRAYSIZE =
    PartOfSpeech_Gender_Gender_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Gender_descriptor() {
    return PartOfSpeech_Gender_descriptor();
  }
  static inline const ::std::string& Gender_Name(Gender value) {
    return PartOfSpeech_Gender_Name(value);
  }
  static inline bool Gender_Parse(const ::std::string& name,
      Gender* value) {
    return PartOfSpeech_Gender_Parse(name, value);
  }

  typedef PartOfSpeech_Mood Mood;
  static const Mood MOOD_UNKNOWN =
    PartOfSpeech_Mood_MOOD_UNKNOWN;
  static const Mood CONDITIONAL_MOOD =
    PartOfSpeech_Mood_CONDITIONAL_MOOD;
  static const Mood IMPERATIVE =
    PartOfSpeech_Mood_IMPERATIVE;
  static const Mood INDICATIVE =
    PartOfSpeech_Mood_INDICATIVE;
  static const Mood INTERROGATIVE =
    PartOfSpeech_Mood_INTERROGATIVE;
  static const Mood JUSSIVE =
    PartOfSpeech_Mood_JUSSIVE;
  static const Mood SUBJUNCTIVE =
    PartOfSpeech_Mood_SUBJUNCTIVE;
  static inline bool Mood_IsValid(int value) {
    return PartOfSpeech_Mood_IsValid(value);
  }
  static const Mood Mood_MIN =
    PartOfSpeech_Mood_Mood_MIN;
  static const Mood Mood_MAX =
    PartOfSpeech_Mood_Mood_MAX;
  static const int Mood_ARRAYSIZE =
    PartOfSpeech_Mood_Mood_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mood_descriptor() {
    return PartOfSpeech_Mood_descriptor();
  }
  static inline const ::std::string& Mood_Name(Mood value) {
    return PartOfSpeech_Mood_Name(value);
  }
  static inline bool Mood_Parse(const ::std::string& name,
      Mood* value) {
    return PartOfSpeech_Mood_Parse(name, value);
  }

  typedef PartOfSpeech_Number Number;
  static const Number NUMBER_UNKNOWN =
    PartOfSpeech_Number_NUMBER_UNKNOWN;
  static const Number SINGULAR =
    PartOfSpeech_Number_SINGULAR;
  static const Number PLURAL =
    PartOfSpeech_Number_PLURAL;
  static const Number DUAL =
    PartOfSpeech_Number_DUAL;
  static inline bool Number_IsValid(int value) {
    return PartOfSpeech_Number_IsValid(value);
  }
  static const Number Number_MIN =
    PartOfSpeech_Number_Number_MIN;
  static const Number Number_MAX =
    PartOfSpeech_Number_Number_MAX;
  static const int Number_ARRAYSIZE =
    PartOfSpeech_Number_Number_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Number_descriptor() {
    return PartOfSpeech_Number_descriptor();
  }
  static inline const ::std::string& Number_Name(Number value) {
    return PartOfSpeech_Number_Name(value);
  }
  static inline bool Number_Parse(const ::std::string& name,
      Number* value) {
    return PartOfSpeech_Number_Parse(name, value);
  }

  typedef PartOfSpeech_Person Person;
  static const Person PERSON_UNKNOWN =
    PartOfSpeech_Person_PERSON_UNKNOWN;
  static const Person FIRST =
    PartOfSpeech_Person_FIRST;
  static const Person SECOND =
    PartOfSpeech_Person_SECOND;
  static const Person THIRD =
    PartOfSpeech_Person_THIRD;
  static const Person REFLEXIVE_PERSON =
    PartOfSpeech_Person_REFLEXIVE_PERSON;
  static inline bool Person_IsValid(int value) {
    return PartOfSpeech_Person_IsValid(value);
  }
  static const Person Person_MIN =
    PartOfSpeech_Person_Person_MIN;
  static const Person Person_MAX =
    PartOfSpeech_Person_Person_MAX;
  static const int Person_ARRAYSIZE =
    PartOfSpeech_Person_Person_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Person_descriptor() {
    return PartOfSpeech_Person_descriptor();
  }
  static inline const ::std::string& Person_Name(Person value) {
    return PartOfSpeech_Person_Name(value);
  }
  static inline bool Person_Parse(const ::std::string& name,
      Person* value) {
    return PartOfSpeech_Person_Parse(name, value);
  }

  typedef PartOfSpeech_Proper Proper;
  static const Proper PROPER_UNKNOWN =
    PartOfSpeech_Proper_PROPER_UNKNOWN;
  static const Proper PROPER =
    PartOfSpeech_Proper_PROPER;
  static const Proper NOT_PROPER =
    PartOfSpeech_Proper_NOT_PROPER;
  static inline bool Proper_IsValid(int value) {
    return PartOfSpeech_Proper_IsValid(value);
  }
  static const Proper Proper_MIN =
    PartOfSpeech_Proper_Proper_MIN;
  static const Proper Proper_MAX =
    PartOfSpeech_Proper_Proper_MAX;
  static const int Proper_ARRAYSIZE =
    PartOfSpeech_Proper_Proper_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Proper_descriptor() {
    return PartOfSpeech_Proper_descriptor();
  }
  static inline const ::std::string& Proper_Name(Proper value) {
    return PartOfSpeech_Proper_Name(value);
  }
  static inline bool Proper_Parse(const ::std::string& name,
      Proper* value) {
    return PartOfSpeech_Proper_Parse(name, value);
  }

  typedef PartOfSpeech_Reciprocity Reciprocity;
  static const Reciprocity RECIPROCITY_UNKNOWN =
    PartOfSpeech_Reciprocity_RECIPROCITY_UNKNOWN;
  static const Reciprocity RECIPROCAL =
    PartOfSpeech_Reciprocity_RECIPROCAL;
  static const Reciprocity NON_RECIPROCAL =
    PartOfSpeech_Reciprocity_NON_RECIPROCAL;
  static inline bool Reciprocity_IsValid(int value) {
    return PartOfSpeech_Reciprocity_IsValid(value);
  }
  static const Reciprocity Reciprocity_MIN =
    PartOfSpeech_Reciprocity_Reciprocity_MIN;
  static const Reciprocity Reciprocity_MAX =
    PartOfSpeech_Reciprocity_Reciprocity_MAX;
  static const int Reciprocity_ARRAYSIZE =
    PartOfSpeech_Reciprocity_Reciprocity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Reciprocity_descriptor() {
    return PartOfSpeech_Reciprocity_descriptor();
  }
  static inline const ::std::string& Reciprocity_Name(Reciprocity value) {
    return PartOfSpeech_Reciprocity_Name(value);
  }
  static inline bool Reciprocity_Parse(const ::std::string& name,
      Reciprocity* value) {
    return PartOfSpeech_Reciprocity_Parse(name, value);
  }

  typedef PartOfSpeech_Tense Tense;
  static const Tense TENSE_UNKNOWN =
    PartOfSpeech_Tense_TENSE_UNKNOWN;
  static const Tense CONDITIONAL_TENSE =
    PartOfSpeech_Tense_CONDITIONAL_TENSE;
  static const Tense FUTURE =
    PartOfSpeech_Tense_FUTURE;
  static const Tense PAST =
    PartOfSpeech_Tense_PAST;
  static const Tense PRESENT =
    PartOfSpeech_Tense_PRESENT;
  static const Tense IMPERFECT =
    PartOfSpeech_Tense_IMPERFECT;
  static const Tense PLUPERFECT =
    PartOfSpeech_Tense_PLUPERFECT;
  static inline bool Tense_IsValid(int value) {
    return PartOfSpeech_Tense_IsValid(value);
  }
  static const Tense Tense_MIN =
    PartOfSpeech_Tense_Tense_MIN;
  static const Tense Tense_MAX =
    PartOfSpeech_Tense_Tense_MAX;
  static const int Tense_ARRAYSIZE =
    PartOfSpeech_Tense_Tense_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Tense_descriptor() {
    return PartOfSpeech_Tense_descriptor();
  }
  static inline const ::std::string& Tense_Name(Tense value) {
    return PartOfSpeech_Tense_Name(value);
  }
  static inline bool Tense_Parse(const ::std::string& name,
      Tense* value) {
    return PartOfSpeech_Tense_Parse(name, value);
  }

  typedef PartOfSpeech_Voice Voice;
  static const Voice VOICE_UNKNOWN =
    PartOfSpeech_Voice_VOICE_UNKNOWN;
  static const Voice ACTIVE =
    PartOfSpeech_Voice_ACTIVE;
  static const Voice CAUSATIVE =
    PartOfSpeech_Voice_CAUSATIVE;
  static const Voice PASSIVE =
    PartOfSpeech_Voice_PASSIVE;
  static inline bool Voice_IsValid(int value) {
    return PartOfSpeech_Voice_IsValid(value);
  }
  static const Voice Voice_MIN =
    PartOfSpeech_Voice_Voice_MIN;
  static const Voice Voice_MAX =
    PartOfSpeech_Voice_Voice_MAX;
  static const int Voice_ARRAYSIZE =
    PartOfSpeech_Voice_Voice_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Voice_descriptor() {
    return PartOfSpeech_Voice_descriptor();
  }
  static inline const ::std::string& Voice_Name(Voice value) {
    return PartOfSpeech_Voice_Name(value);
  }
  static inline bool Voice_Parse(const ::std::string& name,
      Voice* value) {
    return PartOfSpeech_Voice_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.cloud.language.v1beta2.PartOfSpeech.Tag tag = 1;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::cloud::language::v1beta2::PartOfSpeech_Tag tag() const;
  void set_tag(::google::cloud::language::v1beta2::PartOfSpeech_Tag value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Aspect aspect = 2;
  void clear_aspect();
  static const int kAspectFieldNumber = 2;
  ::google::cloud::language::v1beta2::PartOfSpeech_Aspect aspect() const;
  void set_aspect(::google::cloud::language::v1beta2::PartOfSpeech_Aspect value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Case case = 3;
  void clear_case_();
  static const int kCaseFieldNumber = 3;
  ::google::cloud::language::v1beta2::PartOfSpeech_Case case_() const;
  void set_case_(::google::cloud::language::v1beta2::PartOfSpeech_Case value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Form form = 4;
  void clear_form();
  static const int kFormFieldNumber = 4;
  ::google::cloud::language::v1beta2::PartOfSpeech_Form form() const;
  void set_form(::google::cloud::language::v1beta2::PartOfSpeech_Form value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Gender gender = 5;
  void clear_gender();
  static const int kGenderFieldNumber = 5;
  ::google::cloud::language::v1beta2::PartOfSpeech_Gender gender() const;
  void set_gender(::google::cloud::language::v1beta2::PartOfSpeech_Gender value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Mood mood = 6;
  void clear_mood();
  static const int kMoodFieldNumber = 6;
  ::google::cloud::language::v1beta2::PartOfSpeech_Mood mood() const;
  void set_mood(::google::cloud::language::v1beta2::PartOfSpeech_Mood value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Number number = 7;
  void clear_number();
  static const int kNumberFieldNumber = 7;
  ::google::cloud::language::v1beta2::PartOfSpeech_Number number() const;
  void set_number(::google::cloud::language::v1beta2::PartOfSpeech_Number value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Person person = 8;
  void clear_person();
  static const int kPersonFieldNumber = 8;
  ::google::cloud::language::v1beta2::PartOfSpeech_Person person() const;
  void set_person(::google::cloud::language::v1beta2::PartOfSpeech_Person value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Proper proper = 9;
  void clear_proper();
  static const int kProperFieldNumber = 9;
  ::google::cloud::language::v1beta2::PartOfSpeech_Proper proper() const;
  void set_proper(::google::cloud::language::v1beta2::PartOfSpeech_Proper value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Reciprocity reciprocity = 10;
  void clear_reciprocity();
  static const int kReciprocityFieldNumber = 10;
  ::google::cloud::language::v1beta2::PartOfSpeech_Reciprocity reciprocity() const;
  void set_reciprocity(::google::cloud::language::v1beta2::PartOfSpeech_Reciprocity value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Tense tense = 11;
  void clear_tense();
  static const int kTenseFieldNumber = 11;
  ::google::cloud::language::v1beta2::PartOfSpeech_Tense tense() const;
  void set_tense(::google::cloud::language::v1beta2::PartOfSpeech_Tense value);

  // .google.cloud.language.v1beta2.PartOfSpeech.Voice voice = 12;
  void clear_voice();
  static const int kVoiceFieldNumber = 12;
  ::google::cloud::language::v1beta2::PartOfSpeech_Voice voice() const;
  void set_voice(::google::cloud::language::v1beta2::PartOfSpeech_Voice value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.PartOfSpeech)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int tag_;
  int aspect_;
  int case__;
  int form_;
  int gender_;
  int mood_;
  int number_;
  int person_;
  int proper_;
  int reciprocity_;
  int tense_;
  int voice_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsPartOfSpeechImpl();
};
// -------------------------------------------------------------------

class DependencyEdge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.DependencyEdge) */ {
 public:
  DependencyEdge();
  virtual ~DependencyEdge();

  DependencyEdge(const DependencyEdge& from);

  inline DependencyEdge& operator=(const DependencyEdge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DependencyEdge(DependencyEdge&& from) noexcept
    : DependencyEdge() {
    *this = ::std::move(from);
  }

  inline DependencyEdge& operator=(DependencyEdge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DependencyEdge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DependencyEdge* internal_default_instance() {
    return reinterpret_cast<const DependencyEdge*>(
               &_DependencyEdge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(DependencyEdge* other);
  friend void swap(DependencyEdge& a, DependencyEdge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DependencyEdge* New() const PROTOBUF_FINAL { return New(NULL); }

  DependencyEdge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DependencyEdge& from);
  void MergeFrom(const DependencyEdge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DependencyEdge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DependencyEdge_Label Label;
  static const Label UNKNOWN =
    DependencyEdge_Label_UNKNOWN;
  static const Label ABBREV =
    DependencyEdge_Label_ABBREV;
  static const Label ACOMP =
    DependencyEdge_Label_ACOMP;
  static const Label ADVCL =
    DependencyEdge_Label_ADVCL;
  static const Label ADVMOD =
    DependencyEdge_Label_ADVMOD;
  static const Label AMOD =
    DependencyEdge_Label_AMOD;
  static const Label APPOS =
    DependencyEdge_Label_APPOS;
  static const Label ATTR =
    DependencyEdge_Label_ATTR;
  static const Label AUX =
    DependencyEdge_Label_AUX;
  static const Label AUXPASS =
    DependencyEdge_Label_AUXPASS;
  static const Label CC =
    DependencyEdge_Label_CC;
  static const Label CCOMP =
    DependencyEdge_Label_CCOMP;
  static const Label CONJ =
    DependencyEdge_Label_CONJ;
  static const Label CSUBJ =
    DependencyEdge_Label_CSUBJ;
  static const Label CSUBJPASS =
    DependencyEdge_Label_CSUBJPASS;
  static const Label DEP =
    DependencyEdge_Label_DEP;
  static const Label DET =
    DependencyEdge_Label_DET;
  static const Label DISCOURSE =
    DependencyEdge_Label_DISCOURSE;
  static const Label DOBJ =
    DependencyEdge_Label_DOBJ;
  static const Label EXPL =
    DependencyEdge_Label_EXPL;
  static const Label GOESWITH =
    DependencyEdge_Label_GOESWITH;
  static const Label IOBJ =
    DependencyEdge_Label_IOBJ;
  static const Label MARK =
    DependencyEdge_Label_MARK;
  static const Label MWE =
    DependencyEdge_Label_MWE;
  static const Label MWV =
    DependencyEdge_Label_MWV;
  static const Label NEG =
    DependencyEdge_Label_NEG;
  static const Label NN =
    DependencyEdge_Label_NN;
  static const Label NPADVMOD =
    DependencyEdge_Label_NPADVMOD;
  static const Label NSUBJ =
    DependencyEdge_Label_NSUBJ;
  static const Label NSUBJPASS =
    DependencyEdge_Label_NSUBJPASS;
  static const Label NUM =
    DependencyEdge_Label_NUM;
  static const Label NUMBER =
    DependencyEdge_Label_NUMBER;
  static const Label P =
    DependencyEdge_Label_P;
  static const Label PARATAXIS =
    DependencyEdge_Label_PARATAXIS;
  static const Label PARTMOD =
    DependencyEdge_Label_PARTMOD;
  static const Label PCOMP =
    DependencyEdge_Label_PCOMP;
  static const Label POBJ =
    DependencyEdge_Label_POBJ;
  static const Label POSS =
    DependencyEdge_Label_POSS;
  static const Label POSTNEG =
    DependencyEdge_Label_POSTNEG;
  static const Label PRECOMP =
    DependencyEdge_Label_PRECOMP;
  static const Label PRECONJ =
    DependencyEdge_Label_PRECONJ;
  static const Label PREDET =
    DependencyEdge_Label_PREDET;
  static const Label PREF =
    DependencyEdge_Label_PREF;
  static const Label PREP =
    DependencyEdge_Label_PREP;
  static const Label PRONL =
    DependencyEdge_Label_PRONL;
  static const Label PRT =
    DependencyEdge_Label_PRT;
  static const Label PS =
    DependencyEdge_Label_PS;
  static const Label QUANTMOD =
    DependencyEdge_Label_QUANTMOD;
  static const Label RCMOD =
    DependencyEdge_Label_RCMOD;
  static const Label RCMODREL =
    DependencyEdge_Label_RCMODREL;
  static const Label RDROP =
    DependencyEdge_Label_RDROP;
  static const Label REF =
    DependencyEdge_Label_REF;
  static const Label REMNANT =
    DependencyEdge_Label_REMNANT;
  static const Label REPARANDUM =
    DependencyEdge_Label_REPARANDUM;
  static const Label ROOT =
    DependencyEdge_Label_ROOT;
  static const Label SNUM =
    DependencyEdge_Label_SNUM;
  static const Label SUFF =
    DependencyEdge_Label_SUFF;
  static const Label TMOD =
    DependencyEdge_Label_TMOD;
  static const Label TOPIC =
    DependencyEdge_Label_TOPIC;
  static const Label VMOD =
    DependencyEdge_Label_VMOD;
  static const Label VOCATIVE =
    DependencyEdge_Label_VOCATIVE;
  static const Label XCOMP =
    DependencyEdge_Label_XCOMP;
  static const Label SUFFIX =
    DependencyEdge_Label_SUFFIX;
  static const Label TITLE =
    DependencyEdge_Label_TITLE;
  static const Label ADVPHMOD =
    DependencyEdge_Label_ADVPHMOD;
  static const Label AUXCAUS =
    DependencyEdge_Label_AUXCAUS;
  static const Label AUXVV =
    DependencyEdge_Label_AUXVV;
  static const Label DTMOD =
    DependencyEdge_Label_DTMOD;
  static const Label FOREIGN =
    DependencyEdge_Label_FOREIGN;
  static const Label KW =
    DependencyEdge_Label_KW;
  static const Label LIST =
    DependencyEdge_Label_LIST;
  static const Label NOMC =
    DependencyEdge_Label_NOMC;
  static const Label NOMCSUBJ =
    DependencyEdge_Label_NOMCSUBJ;
  static const Label NOMCSUBJPASS =
    DependencyEdge_Label_NOMCSUBJPASS;
  static const Label NUMC =
    DependencyEdge_Label_NUMC;
  static const Label COP =
    DependencyEdge_Label_COP;
  static const Label DISLOCATED =
    DependencyEdge_Label_DISLOCATED;
  static const Label ASP =
    DependencyEdge_Label_ASP;
  static const Label GMOD =
    DependencyEdge_Label_GMOD;
  static const Label GOBJ =
    DependencyEdge_Label_GOBJ;
  static const Label INFMOD =
    DependencyEdge_Label_INFMOD;
  static const Label MES =
    DependencyEdge_Label_MES;
  static const Label NCOMP =
    DependencyEdge_Label_NCOMP;
  static inline bool Label_IsValid(int value) {
    return DependencyEdge_Label_IsValid(value);
  }
  static const Label Label_MIN =
    DependencyEdge_Label_Label_MIN;
  static const Label Label_MAX =
    DependencyEdge_Label_Label_MAX;
  static const int Label_ARRAYSIZE =
    DependencyEdge_Label_Label_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Label_descriptor() {
    return DependencyEdge_Label_descriptor();
  }
  static inline const ::std::string& Label_Name(Label value) {
    return DependencyEdge_Label_Name(value);
  }
  static inline bool Label_Parse(const ::std::string& name,
      Label* value) {
    return DependencyEdge_Label_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int32 head_token_index = 1;
  void clear_head_token_index();
  static const int kHeadTokenIndexFieldNumber = 1;
  ::google::protobuf::int32 head_token_index() const;
  void set_head_token_index(::google::protobuf::int32 value);

  // .google.cloud.language.v1beta2.DependencyEdge.Label label = 2;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  ::google::cloud::language::v1beta2::DependencyEdge_Label label() const;
  void set_label(::google::cloud::language::v1beta2::DependencyEdge_Label value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.DependencyEdge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 head_token_index_;
  int label_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsDependencyEdgeImpl();
};
// -------------------------------------------------------------------

class EntityMention : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.EntityMention) */ {
 public:
  EntityMention();
  virtual ~EntityMention();

  EntityMention(const EntityMention& from);

  inline EntityMention& operator=(const EntityMention& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityMention(EntityMention&& from) noexcept
    : EntityMention() {
    *this = ::std::move(from);
  }

  inline EntityMention& operator=(EntityMention&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityMention& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityMention* internal_default_instance() {
    return reinterpret_cast<const EntityMention*>(
               &_EntityMention_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(EntityMention* other);
  friend void swap(EntityMention& a, EntityMention& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityMention* New() const PROTOBUF_FINAL { return New(NULL); }

  EntityMention* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntityMention& from);
  void MergeFrom(const EntityMention& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntityMention* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EntityMention_Type Type;
  static const Type TYPE_UNKNOWN =
    EntityMention_Type_TYPE_UNKNOWN;
  static const Type PROPER =
    EntityMention_Type_PROPER;
  static const Type COMMON =
    EntityMention_Type_COMMON;
  static inline bool Type_IsValid(int value) {
    return EntityMention_Type_IsValid(value);
  }
  static const Type Type_MIN =
    EntityMention_Type_Type_MIN;
  static const Type Type_MAX =
    EntityMention_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    EntityMention_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return EntityMention_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return EntityMention_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return EntityMention_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.cloud.language.v1beta2.TextSpan text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::google::cloud::language::v1beta2::TextSpan& text() const;
  ::google::cloud::language::v1beta2::TextSpan* release_text();
  ::google::cloud::language::v1beta2::TextSpan* mutable_text();
  void set_allocated_text(::google::cloud::language::v1beta2::TextSpan* text);

  // .google.cloud.language.v1beta2.Sentiment sentiment = 3;
  bool has_sentiment() const;
  void clear_sentiment();
  static const int kSentimentFieldNumber = 3;
  const ::google::cloud::language::v1beta2::Sentiment& sentiment() const;
  ::google::cloud::language::v1beta2::Sentiment* release_sentiment();
  ::google::cloud::language::v1beta2::Sentiment* mutable_sentiment();
  void set_allocated_sentiment(::google::cloud::language::v1beta2::Sentiment* sentiment);

  // .google.cloud.language.v1beta2.EntityMention.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::cloud::language::v1beta2::EntityMention_Type type() const;
  void set_type(::google::cloud::language::v1beta2::EntityMention_Type value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.EntityMention)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::cloud::language::v1beta2::TextSpan* text_;
  ::google::cloud::language::v1beta2::Sentiment* sentiment_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsEntityMentionImpl();
};
// -------------------------------------------------------------------

class TextSpan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.TextSpan) */ {
 public:
  TextSpan();
  virtual ~TextSpan();

  TextSpan(const TextSpan& from);

  inline TextSpan& operator=(const TextSpan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextSpan(TextSpan&& from) noexcept
    : TextSpan() {
    *this = ::std::move(from);
  }

  inline TextSpan& operator=(TextSpan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TextSpan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextSpan* internal_default_instance() {
    return reinterpret_cast<const TextSpan*>(
               &_TextSpan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TextSpan* other);
  friend void swap(TextSpan& a, TextSpan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextSpan* New() const PROTOBUF_FINAL { return New(NULL); }

  TextSpan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TextSpan& from);
  void MergeFrom(const TextSpan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TextSpan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // int32 begin_offset = 2;
  void clear_begin_offset();
  static const int kBeginOffsetFieldNumber = 2;
  ::google::protobuf::int32 begin_offset() const;
  void set_begin_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.TextSpan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::int32 begin_offset_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsTextSpanImpl();
};
// -------------------------------------------------------------------

class ClassificationCategory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.ClassificationCategory) */ {
 public:
  ClassificationCategory();
  virtual ~ClassificationCategory();

  ClassificationCategory(const ClassificationCategory& from);

  inline ClassificationCategory& operator=(const ClassificationCategory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClassificationCategory(ClassificationCategory&& from) noexcept
    : ClassificationCategory() {
    *this = ::std::move(from);
  }

  inline ClassificationCategory& operator=(ClassificationCategory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassificationCategory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassificationCategory* internal_default_instance() {
    return reinterpret_cast<const ClassificationCategory*>(
               &_ClassificationCategory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ClassificationCategory* other);
  friend void swap(ClassificationCategory& a, ClassificationCategory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClassificationCategory* New() const PROTOBUF_FINAL { return New(NULL); }

  ClassificationCategory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClassificationCategory& from);
  void MergeFrom(const ClassificationCategory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClassificationCategory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // float confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.ClassificationCategory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  float confidence_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsClassificationCategoryImpl();
};
// -------------------------------------------------------------------

class AnalyzeSentimentRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnalyzeSentimentRequest) */ {
 public:
  AnalyzeSentimentRequest();
  virtual ~AnalyzeSentimentRequest();

  AnalyzeSentimentRequest(const AnalyzeSentimentRequest& from);

  inline AnalyzeSentimentRequest& operator=(const AnalyzeSentimentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeSentimentRequest(AnalyzeSentimentRequest&& from) noexcept
    : AnalyzeSentimentRequest() {
    *this = ::std::move(from);
  }

  inline AnalyzeSentimentRequest& operator=(AnalyzeSentimentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeSentimentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeSentimentRequest* internal_default_instance() {
    return reinterpret_cast<const AnalyzeSentimentRequest*>(
               &_AnalyzeSentimentRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(AnalyzeSentimentRequest* other);
  friend void swap(AnalyzeSentimentRequest& a, AnalyzeSentimentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeSentimentRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeSentimentRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeSentimentRequest& from);
  void MergeFrom(const AnalyzeSentimentRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeSentimentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.cloud.language.v1beta2.Document document = 1;
  bool has_document() const;
  void clear_document();
  static const int kDocumentFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Document& document() const;
  ::google::cloud::language::v1beta2::Document* release_document();
  ::google::cloud::language::v1beta2::Document* mutable_document();
  void set_allocated_document(::google::cloud::language::v1beta2::Document* document);

  // .google.cloud.language.v1beta2.EncodingType encoding_type = 2;
  void clear_encoding_type();
  static const int kEncodingTypeFieldNumber = 2;
  ::google::cloud::language::v1beta2::EncodingType encoding_type() const;
  void set_encoding_type(::google::cloud::language::v1beta2::EncodingType value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnalyzeSentimentRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::cloud::language::v1beta2::Document* document_;
  int encoding_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnalyzeSentimentRequestImpl();
};
// -------------------------------------------------------------------

class AnalyzeSentimentResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnalyzeSentimentResponse) */ {
 public:
  AnalyzeSentimentResponse();
  virtual ~AnalyzeSentimentResponse();

  AnalyzeSentimentResponse(const AnalyzeSentimentResponse& from);

  inline AnalyzeSentimentResponse& operator=(const AnalyzeSentimentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeSentimentResponse(AnalyzeSentimentResponse&& from) noexcept
    : AnalyzeSentimentResponse() {
    *this = ::std::move(from);
  }

  inline AnalyzeSentimentResponse& operator=(AnalyzeSentimentResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeSentimentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeSentimentResponse* internal_default_instance() {
    return reinterpret_cast<const AnalyzeSentimentResponse*>(
               &_AnalyzeSentimentResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(AnalyzeSentimentResponse* other);
  friend void swap(AnalyzeSentimentResponse& a, AnalyzeSentimentResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeSentimentResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeSentimentResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeSentimentResponse& from);
  void MergeFrom(const AnalyzeSentimentResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeSentimentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.cloud.language.v1beta2.Sentence sentences = 3;
  int sentences_size() const;
  void clear_sentences();
  static const int kSentencesFieldNumber = 3;
  const ::google::cloud::language::v1beta2::Sentence& sentences(int index) const;
  ::google::cloud::language::v1beta2::Sentence* mutable_sentences(int index);
  ::google::cloud::language::v1beta2::Sentence* add_sentences();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >*
      mutable_sentences();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >&
      sentences() const;

  // string language = 2;
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // .google.cloud.language.v1beta2.Sentiment document_sentiment = 1;
  bool has_document_sentiment() const;
  void clear_document_sentiment();
  static const int kDocumentSentimentFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Sentiment& document_sentiment() const;
  ::google::cloud::language::v1beta2::Sentiment* release_document_sentiment();
  ::google::cloud::language::v1beta2::Sentiment* mutable_document_sentiment();
  void set_allocated_document_sentiment(::google::cloud::language::v1beta2::Sentiment* document_sentiment);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnalyzeSentimentResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence > sentences_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::cloud::language::v1beta2::Sentiment* document_sentiment_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnalyzeSentimentResponseImpl();
};
// -------------------------------------------------------------------

class AnalyzeEntitySentimentRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnalyzeEntitySentimentRequest) */ {
 public:
  AnalyzeEntitySentimentRequest();
  virtual ~AnalyzeEntitySentimentRequest();

  AnalyzeEntitySentimentRequest(const AnalyzeEntitySentimentRequest& from);

  inline AnalyzeEntitySentimentRequest& operator=(const AnalyzeEntitySentimentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeEntitySentimentRequest(AnalyzeEntitySentimentRequest&& from) noexcept
    : AnalyzeEntitySentimentRequest() {
    *this = ::std::move(from);
  }

  inline AnalyzeEntitySentimentRequest& operator=(AnalyzeEntitySentimentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeEntitySentimentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeEntitySentimentRequest* internal_default_instance() {
    return reinterpret_cast<const AnalyzeEntitySentimentRequest*>(
               &_AnalyzeEntitySentimentRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(AnalyzeEntitySentimentRequest* other);
  friend void swap(AnalyzeEntitySentimentRequest& a, AnalyzeEntitySentimentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeEntitySentimentRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeEntitySentimentRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeEntitySentimentRequest& from);
  void MergeFrom(const AnalyzeEntitySentimentRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeEntitySentimentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.cloud.language.v1beta2.Document document = 1;
  bool has_document() const;
  void clear_document();
  static const int kDocumentFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Document& document() const;
  ::google::cloud::language::v1beta2::Document* release_document();
  ::google::cloud::language::v1beta2::Document* mutable_document();
  void set_allocated_document(::google::cloud::language::v1beta2::Document* document);

  // .google.cloud.language.v1beta2.EncodingType encoding_type = 2;
  void clear_encoding_type();
  static const int kEncodingTypeFieldNumber = 2;
  ::google::cloud::language::v1beta2::EncodingType encoding_type() const;
  void set_encoding_type(::google::cloud::language::v1beta2::EncodingType value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnalyzeEntitySentimentRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::cloud::language::v1beta2::Document* document_;
  int encoding_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnalyzeEntitySentimentRequestImpl();
};
// -------------------------------------------------------------------

class AnalyzeEntitySentimentResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse) */ {
 public:
  AnalyzeEntitySentimentResponse();
  virtual ~AnalyzeEntitySentimentResponse();

  AnalyzeEntitySentimentResponse(const AnalyzeEntitySentimentResponse& from);

  inline AnalyzeEntitySentimentResponse& operator=(const AnalyzeEntitySentimentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeEntitySentimentResponse(AnalyzeEntitySentimentResponse&& from) noexcept
    : AnalyzeEntitySentimentResponse() {
    *this = ::std::move(from);
  }

  inline AnalyzeEntitySentimentResponse& operator=(AnalyzeEntitySentimentResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeEntitySentimentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeEntitySentimentResponse* internal_default_instance() {
    return reinterpret_cast<const AnalyzeEntitySentimentResponse*>(
               &_AnalyzeEntitySentimentResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(AnalyzeEntitySentimentResponse* other);
  friend void swap(AnalyzeEntitySentimentResponse& a, AnalyzeEntitySentimentResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeEntitySentimentResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeEntitySentimentResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeEntitySentimentResponse& from);
  void MergeFrom(const AnalyzeEntitySentimentResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeEntitySentimentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.cloud.language.v1beta2.Entity entities = 1;
  int entities_size() const;
  void clear_entities();
  static const int kEntitiesFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Entity& entities(int index) const;
  ::google::cloud::language::v1beta2::Entity* mutable_entities(int index);
  ::google::cloud::language::v1beta2::Entity* add_entities();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >*
      mutable_entities();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >&
      entities() const;

  // string language = 2;
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity > entities_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnalyzeEntitySentimentResponseImpl();
};
// -------------------------------------------------------------------

class AnalyzeEntitiesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnalyzeEntitiesRequest) */ {
 public:
  AnalyzeEntitiesRequest();
  virtual ~AnalyzeEntitiesRequest();

  AnalyzeEntitiesRequest(const AnalyzeEntitiesRequest& from);

  inline AnalyzeEntitiesRequest& operator=(const AnalyzeEntitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeEntitiesRequest(AnalyzeEntitiesRequest&& from) noexcept
    : AnalyzeEntitiesRequest() {
    *this = ::std::move(from);
  }

  inline AnalyzeEntitiesRequest& operator=(AnalyzeEntitiesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeEntitiesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeEntitiesRequest* internal_default_instance() {
    return reinterpret_cast<const AnalyzeEntitiesRequest*>(
               &_AnalyzeEntitiesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(AnalyzeEntitiesRequest* other);
  friend void swap(AnalyzeEntitiesRequest& a, AnalyzeEntitiesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeEntitiesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeEntitiesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeEntitiesRequest& from);
  void MergeFrom(const AnalyzeEntitiesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeEntitiesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.cloud.language.v1beta2.Document document = 1;
  bool has_document() const;
  void clear_document();
  static const int kDocumentFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Document& document() const;
  ::google::cloud::language::v1beta2::Document* release_document();
  ::google::cloud::language::v1beta2::Document* mutable_document();
  void set_allocated_document(::google::cloud::language::v1beta2::Document* document);

  // .google.cloud.language.v1beta2.EncodingType encoding_type = 2;
  void clear_encoding_type();
  static const int kEncodingTypeFieldNumber = 2;
  ::google::cloud::language::v1beta2::EncodingType encoding_type() const;
  void set_encoding_type(::google::cloud::language::v1beta2::EncodingType value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnalyzeEntitiesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::cloud::language::v1beta2::Document* document_;
  int encoding_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnalyzeEntitiesRequestImpl();
};
// -------------------------------------------------------------------

class AnalyzeEntitiesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnalyzeEntitiesResponse) */ {
 public:
  AnalyzeEntitiesResponse();
  virtual ~AnalyzeEntitiesResponse();

  AnalyzeEntitiesResponse(const AnalyzeEntitiesResponse& from);

  inline AnalyzeEntitiesResponse& operator=(const AnalyzeEntitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeEntitiesResponse(AnalyzeEntitiesResponse&& from) noexcept
    : AnalyzeEntitiesResponse() {
    *this = ::std::move(from);
  }

  inline AnalyzeEntitiesResponse& operator=(AnalyzeEntitiesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeEntitiesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeEntitiesResponse* internal_default_instance() {
    return reinterpret_cast<const AnalyzeEntitiesResponse*>(
               &_AnalyzeEntitiesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(AnalyzeEntitiesResponse* other);
  friend void swap(AnalyzeEntitiesResponse& a, AnalyzeEntitiesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeEntitiesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeEntitiesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeEntitiesResponse& from);
  void MergeFrom(const AnalyzeEntitiesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeEntitiesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.cloud.language.v1beta2.Entity entities = 1;
  int entities_size() const;
  void clear_entities();
  static const int kEntitiesFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Entity& entities(int index) const;
  ::google::cloud::language::v1beta2::Entity* mutable_entities(int index);
  ::google::cloud::language::v1beta2::Entity* add_entities();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >*
      mutable_entities();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >&
      entities() const;

  // string language = 2;
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnalyzeEntitiesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity > entities_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnalyzeEntitiesResponseImpl();
};
// -------------------------------------------------------------------

class AnalyzeSyntaxRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnalyzeSyntaxRequest) */ {
 public:
  AnalyzeSyntaxRequest();
  virtual ~AnalyzeSyntaxRequest();

  AnalyzeSyntaxRequest(const AnalyzeSyntaxRequest& from);

  inline AnalyzeSyntaxRequest& operator=(const AnalyzeSyntaxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeSyntaxRequest(AnalyzeSyntaxRequest&& from) noexcept
    : AnalyzeSyntaxRequest() {
    *this = ::std::move(from);
  }

  inline AnalyzeSyntaxRequest& operator=(AnalyzeSyntaxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeSyntaxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeSyntaxRequest* internal_default_instance() {
    return reinterpret_cast<const AnalyzeSyntaxRequest*>(
               &_AnalyzeSyntaxRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(AnalyzeSyntaxRequest* other);
  friend void swap(AnalyzeSyntaxRequest& a, AnalyzeSyntaxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeSyntaxRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeSyntaxRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeSyntaxRequest& from);
  void MergeFrom(const AnalyzeSyntaxRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeSyntaxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.cloud.language.v1beta2.Document document = 1;
  bool has_document() const;
  void clear_document();
  static const int kDocumentFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Document& document() const;
  ::google::cloud::language::v1beta2::Document* release_document();
  ::google::cloud::language::v1beta2::Document* mutable_document();
  void set_allocated_document(::google::cloud::language::v1beta2::Document* document);

  // .google.cloud.language.v1beta2.EncodingType encoding_type = 2;
  void clear_encoding_type();
  static const int kEncodingTypeFieldNumber = 2;
  ::google::cloud::language::v1beta2::EncodingType encoding_type() const;
  void set_encoding_type(::google::cloud::language::v1beta2::EncodingType value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnalyzeSyntaxRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::cloud::language::v1beta2::Document* document_;
  int encoding_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnalyzeSyntaxRequestImpl();
};
// -------------------------------------------------------------------

class AnalyzeSyntaxResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnalyzeSyntaxResponse) */ {
 public:
  AnalyzeSyntaxResponse();
  virtual ~AnalyzeSyntaxResponse();

  AnalyzeSyntaxResponse(const AnalyzeSyntaxResponse& from);

  inline AnalyzeSyntaxResponse& operator=(const AnalyzeSyntaxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeSyntaxResponse(AnalyzeSyntaxResponse&& from) noexcept
    : AnalyzeSyntaxResponse() {
    *this = ::std::move(from);
  }

  inline AnalyzeSyntaxResponse& operator=(AnalyzeSyntaxResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeSyntaxResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeSyntaxResponse* internal_default_instance() {
    return reinterpret_cast<const AnalyzeSyntaxResponse*>(
               &_AnalyzeSyntaxResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(AnalyzeSyntaxResponse* other);
  friend void swap(AnalyzeSyntaxResponse& a, AnalyzeSyntaxResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeSyntaxResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeSyntaxResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeSyntaxResponse& from);
  void MergeFrom(const AnalyzeSyntaxResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeSyntaxResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.cloud.language.v1beta2.Sentence sentences = 1;
  int sentences_size() const;
  void clear_sentences();
  static const int kSentencesFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Sentence& sentences(int index) const;
  ::google::cloud::language::v1beta2::Sentence* mutable_sentences(int index);
  ::google::cloud::language::v1beta2::Sentence* add_sentences();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >*
      mutable_sentences();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >&
      sentences() const;

  // repeated .google.cloud.language.v1beta2.Token tokens = 2;
  int tokens_size() const;
  void clear_tokens();
  static const int kTokensFieldNumber = 2;
  const ::google::cloud::language::v1beta2::Token& tokens(int index) const;
  ::google::cloud::language::v1beta2::Token* mutable_tokens(int index);
  ::google::cloud::language::v1beta2::Token* add_tokens();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token >*
      mutable_tokens();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token >&
      tokens() const;

  // string language = 3;
  void clear_language();
  static const int kLanguageFieldNumber = 3;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnalyzeSyntaxResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence > sentences_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token > tokens_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnalyzeSyntaxResponseImpl();
};
// -------------------------------------------------------------------

class ClassifyTextRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.ClassifyTextRequest) */ {
 public:
  ClassifyTextRequest();
  virtual ~ClassifyTextRequest();

  ClassifyTextRequest(const ClassifyTextRequest& from);

  inline ClassifyTextRequest& operator=(const ClassifyTextRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClassifyTextRequest(ClassifyTextRequest&& from) noexcept
    : ClassifyTextRequest() {
    *this = ::std::move(from);
  }

  inline ClassifyTextRequest& operator=(ClassifyTextRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassifyTextRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassifyTextRequest* internal_default_instance() {
    return reinterpret_cast<const ClassifyTextRequest*>(
               &_ClassifyTextRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(ClassifyTextRequest* other);
  friend void swap(ClassifyTextRequest& a, ClassifyTextRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClassifyTextRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ClassifyTextRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClassifyTextRequest& from);
  void MergeFrom(const ClassifyTextRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClassifyTextRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.cloud.language.v1beta2.Document document = 1;
  bool has_document() const;
  void clear_document();
  static const int kDocumentFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Document& document() const;
  ::google::cloud::language::v1beta2::Document* release_document();
  ::google::cloud::language::v1beta2::Document* mutable_document();
  void set_allocated_document(::google::cloud::language::v1beta2::Document* document);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.ClassifyTextRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::cloud::language::v1beta2::Document* document_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsClassifyTextRequestImpl();
};
// -------------------------------------------------------------------

class ClassifyTextResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.ClassifyTextResponse) */ {
 public:
  ClassifyTextResponse();
  virtual ~ClassifyTextResponse();

  ClassifyTextResponse(const ClassifyTextResponse& from);

  inline ClassifyTextResponse& operator=(const ClassifyTextResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClassifyTextResponse(ClassifyTextResponse&& from) noexcept
    : ClassifyTextResponse() {
    *this = ::std::move(from);
  }

  inline ClassifyTextResponse& operator=(ClassifyTextResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClassifyTextResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClassifyTextResponse* internal_default_instance() {
    return reinterpret_cast<const ClassifyTextResponse*>(
               &_ClassifyTextResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(ClassifyTextResponse* other);
  friend void swap(ClassifyTextResponse& a, ClassifyTextResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClassifyTextResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ClassifyTextResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClassifyTextResponse& from);
  void MergeFrom(const ClassifyTextResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClassifyTextResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.cloud.language.v1beta2.ClassificationCategory categories = 1;
  int categories_size() const;
  void clear_categories();
  static const int kCategoriesFieldNumber = 1;
  const ::google::cloud::language::v1beta2::ClassificationCategory& categories(int index) const;
  ::google::cloud::language::v1beta2::ClassificationCategory* mutable_categories(int index);
  ::google::cloud::language::v1beta2::ClassificationCategory* add_categories();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory >*
      mutable_categories();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory >&
      categories() const;

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.ClassifyTextResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory > categories_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsClassifyTextResponseImpl();
};
// -------------------------------------------------------------------

class AnnotateTextRequest_Features : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnnotateTextRequest.Features) */ {
 public:
  AnnotateTextRequest_Features();
  virtual ~AnnotateTextRequest_Features();

  AnnotateTextRequest_Features(const AnnotateTextRequest_Features& from);

  inline AnnotateTextRequest_Features& operator=(const AnnotateTextRequest_Features& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnnotateTextRequest_Features(AnnotateTextRequest_Features&& from) noexcept
    : AnnotateTextRequest_Features() {
    *this = ::std::move(from);
  }

  inline AnnotateTextRequest_Features& operator=(AnnotateTextRequest_Features&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnnotateTextRequest_Features& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnnotateTextRequest_Features* internal_default_instance() {
    return reinterpret_cast<const AnnotateTextRequest_Features*>(
               &_AnnotateTextRequest_Features_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(AnnotateTextRequest_Features* other);
  friend void swap(AnnotateTextRequest_Features& a, AnnotateTextRequest_Features& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnnotateTextRequest_Features* New() const PROTOBUF_FINAL { return New(NULL); }

  AnnotateTextRequest_Features* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnnotateTextRequest_Features& from);
  void MergeFrom(const AnnotateTextRequest_Features& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnnotateTextRequest_Features* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool extract_syntax = 1;
  void clear_extract_syntax();
  static const int kExtractSyntaxFieldNumber = 1;
  bool extract_syntax() const;
  void set_extract_syntax(bool value);

  // bool extract_entities = 2;
  void clear_extract_entities();
  static const int kExtractEntitiesFieldNumber = 2;
  bool extract_entities() const;
  void set_extract_entities(bool value);

  // bool extract_document_sentiment = 3;
  void clear_extract_document_sentiment();
  static const int kExtractDocumentSentimentFieldNumber = 3;
  bool extract_document_sentiment() const;
  void set_extract_document_sentiment(bool value);

  // bool extract_entity_sentiment = 4;
  void clear_extract_entity_sentiment();
  static const int kExtractEntitySentimentFieldNumber = 4;
  bool extract_entity_sentiment() const;
  void set_extract_entity_sentiment(bool value);

  // bool classify_text = 6;
  void clear_classify_text();
  static const int kClassifyTextFieldNumber = 6;
  bool classify_text() const;
  void set_classify_text(bool value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnnotateTextRequest.Features)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool extract_syntax_;
  bool extract_entities_;
  bool extract_document_sentiment_;
  bool extract_entity_sentiment_;
  bool classify_text_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnnotateTextRequest_FeaturesImpl();
};
// -------------------------------------------------------------------

class AnnotateTextRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnnotateTextRequest) */ {
 public:
  AnnotateTextRequest();
  virtual ~AnnotateTextRequest();

  AnnotateTextRequest(const AnnotateTextRequest& from);

  inline AnnotateTextRequest& operator=(const AnnotateTextRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnnotateTextRequest(AnnotateTextRequest&& from) noexcept
    : AnnotateTextRequest() {
    *this = ::std::move(from);
  }

  inline AnnotateTextRequest& operator=(AnnotateTextRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnnotateTextRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnnotateTextRequest* internal_default_instance() {
    return reinterpret_cast<const AnnotateTextRequest*>(
               &_AnnotateTextRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(AnnotateTextRequest* other);
  friend void swap(AnnotateTextRequest& a, AnnotateTextRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnnotateTextRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AnnotateTextRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnnotateTextRequest& from);
  void MergeFrom(const AnnotateTextRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnnotateTextRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AnnotateTextRequest_Features Features;

  // accessors -------------------------------------------------------

  // .google.cloud.language.v1beta2.Document document = 1;
  bool has_document() const;
  void clear_document();
  static const int kDocumentFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Document& document() const;
  ::google::cloud::language::v1beta2::Document* release_document();
  ::google::cloud::language::v1beta2::Document* mutable_document();
  void set_allocated_document(::google::cloud::language::v1beta2::Document* document);

  // .google.cloud.language.v1beta2.AnnotateTextRequest.Features features = 2;
  bool has_features() const;
  void clear_features();
  static const int kFeaturesFieldNumber = 2;
  const ::google::cloud::language::v1beta2::AnnotateTextRequest_Features& features() const;
  ::google::cloud::language::v1beta2::AnnotateTextRequest_Features* release_features();
  ::google::cloud::language::v1beta2::AnnotateTextRequest_Features* mutable_features();
  void set_allocated_features(::google::cloud::language::v1beta2::AnnotateTextRequest_Features* features);

  // .google.cloud.language.v1beta2.EncodingType encoding_type = 3;
  void clear_encoding_type();
  static const int kEncodingTypeFieldNumber = 3;
  ::google::cloud::language::v1beta2::EncodingType encoding_type() const;
  void set_encoding_type(::google::cloud::language::v1beta2::EncodingType value);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnnotateTextRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::cloud::language::v1beta2::Document* document_;
  ::google::cloud::language::v1beta2::AnnotateTextRequest_Features* features_;
  int encoding_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnnotateTextRequestImpl();
};
// -------------------------------------------------------------------

class AnnotateTextResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:google.cloud.language.v1beta2.AnnotateTextResponse) */ {
 public:
  AnnotateTextResponse();
  virtual ~AnnotateTextResponse();

  AnnotateTextResponse(const AnnotateTextResponse& from);

  inline AnnotateTextResponse& operator=(const AnnotateTextResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnnotateTextResponse(AnnotateTextResponse&& from) noexcept
    : AnnotateTextResponse() {
    *this = ::std::move(from);
  }

  inline AnnotateTextResponse& operator=(AnnotateTextResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AnnotateTextResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnnotateTextResponse* internal_default_instance() {
    return reinterpret_cast<const AnnotateTextResponse*>(
               &_AnnotateTextResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(AnnotateTextResponse* other);
  friend void swap(AnnotateTextResponse& a, AnnotateTextResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnnotateTextResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AnnotateTextResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnnotateTextResponse& from);
  void MergeFrom(const AnnotateTextResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnnotateTextResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.cloud.language.v1beta2.Sentence sentences = 1;
  int sentences_size() const;
  void clear_sentences();
  static const int kSentencesFieldNumber = 1;
  const ::google::cloud::language::v1beta2::Sentence& sentences(int index) const;
  ::google::cloud::language::v1beta2::Sentence* mutable_sentences(int index);
  ::google::cloud::language::v1beta2::Sentence* add_sentences();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >*
      mutable_sentences();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >&
      sentences() const;

  // repeated .google.cloud.language.v1beta2.Token tokens = 2;
  int tokens_size() const;
  void clear_tokens();
  static const int kTokensFieldNumber = 2;
  const ::google::cloud::language::v1beta2::Token& tokens(int index) const;
  ::google::cloud::language::v1beta2::Token* mutable_tokens(int index);
  ::google::cloud::language::v1beta2::Token* add_tokens();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token >*
      mutable_tokens();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token >&
      tokens() const;

  // repeated .google.cloud.language.v1beta2.Entity entities = 3;
  int entities_size() const;
  void clear_entities();
  static const int kEntitiesFieldNumber = 3;
  const ::google::cloud::language::v1beta2::Entity& entities(int index) const;
  ::google::cloud::language::v1beta2::Entity* mutable_entities(int index);
  ::google::cloud::language::v1beta2::Entity* add_entities();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >*
      mutable_entities();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >&
      entities() const;

  // repeated .google.cloud.language.v1beta2.ClassificationCategory categories = 6;
  int categories_size() const;
  void clear_categories();
  static const int kCategoriesFieldNumber = 6;
  const ::google::cloud::language::v1beta2::ClassificationCategory& categories(int index) const;
  ::google::cloud::language::v1beta2::ClassificationCategory* mutable_categories(int index);
  ::google::cloud::language::v1beta2::ClassificationCategory* add_categories();
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory >*
      mutable_categories();
  const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory >&
      categories() const;

  // string language = 5;
  void clear_language();
  static const int kLanguageFieldNumber = 5;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // .google.cloud.language.v1beta2.Sentiment document_sentiment = 4;
  bool has_document_sentiment() const;
  void clear_document_sentiment();
  static const int kDocumentSentimentFieldNumber = 4;
  const ::google::cloud::language::v1beta2::Sentiment& document_sentiment() const;
  ::google::cloud::language::v1beta2::Sentiment* release_document_sentiment();
  ::google::cloud::language::v1beta2::Sentiment* mutable_document_sentiment();
  void set_allocated_document_sentiment(::google::cloud::language::v1beta2::Sentiment* document_sentiment);

  // @@protoc_insertion_point(class_scope:google.cloud.language.v1beta2.AnnotateTextResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence > sentences_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token > tokens_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity > entities_;
  ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory > categories_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::cloud::language::v1beta2::Sentiment* document_sentiment_;
  mutable int _cached_size_;
  friend struct ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::TableStruct;
  friend void ::protobuf_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto::InitDefaultsAnnotateTextResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Document

// .google.cloud.language.v1beta2.Document.Type type = 1;
inline void Document::clear_type() {
  type_ = 0;
}
inline ::google::cloud::language::v1beta2::Document_Type Document::type() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Document.type)
  return static_cast< ::google::cloud::language::v1beta2::Document_Type >(type_);
}
inline void Document::set_type(::google::cloud::language::v1beta2::Document_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Document.type)
}

// string content = 2;
inline bool Document::has_content() const {
  return source_case() == kContent;
}
inline void Document::set_has_content() {
  _oneof_case_[0] = kContent;
}
inline void Document::clear_content() {
  if (has_content()) {
    source_.content_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_source();
  }
}
inline const ::std::string& Document::content() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Document.content)
  if (has_content()) {
    return source_.content_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Document::set_content(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Document.content)
  if (!has_content()) {
    clear_source();
    set_has_content();
    source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Document.content)
}
#if LANG_CXX11
inline void Document::set_content(::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Document.content)
  if (!has_content()) {
    clear_source();
    set_has_content();
    source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.Document.content)
}
#endif
inline void Document::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_content()) {
    clear_source();
    set_has_content();
    source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.Document.content)
}
inline void Document::set_content(const char* value, size_t size) {
  if (!has_content()) {
    clear_source();
    set_has_content();
    source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.Document.content)
}
inline ::std::string* Document::mutable_content() {
  if (!has_content()) {
    clear_source();
    set_has_content();
    source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Document.content)
  return source_.content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Document::release_content() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Document.content)
  if (has_content()) {
    clear_has_source();
    return source_.content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Document::set_allocated_content(::std::string* content) {
  if (!has_content()) {
    source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_source();
  if (content != NULL) {
    set_has_content();
    source_.content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        content);
  }
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Document.content)
}

// string gcs_content_uri = 3;
inline bool Document::has_gcs_content_uri() const {
  return source_case() == kGcsContentUri;
}
inline void Document::set_has_gcs_content_uri() {
  _oneof_case_[0] = kGcsContentUri;
}
inline void Document::clear_gcs_content_uri() {
  if (has_gcs_content_uri()) {
    source_.gcs_content_uri_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_source();
  }
}
inline const ::std::string& Document::gcs_content_uri() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Document.gcs_content_uri)
  if (has_gcs_content_uri()) {
    return source_.gcs_content_uri_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Document::set_gcs_content_uri(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Document.gcs_content_uri)
  if (!has_gcs_content_uri()) {
    clear_source();
    set_has_gcs_content_uri();
    source_.gcs_content_uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.gcs_content_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Document.gcs_content_uri)
}
#if LANG_CXX11
inline void Document::set_gcs_content_uri(::std::string&& value) {
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Document.gcs_content_uri)
  if (!has_gcs_content_uri()) {
    clear_source();
    set_has_gcs_content_uri();
    source_.gcs_content_uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.gcs_content_uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.Document.gcs_content_uri)
}
#endif
inline void Document::set_gcs_content_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_gcs_content_uri()) {
    clear_source();
    set_has_gcs_content_uri();
    source_.gcs_content_uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.gcs_content_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.Document.gcs_content_uri)
}
inline void Document::set_gcs_content_uri(const char* value, size_t size) {
  if (!has_gcs_content_uri()) {
    clear_source();
    set_has_gcs_content_uri();
    source_.gcs_content_uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  source_.gcs_content_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.Document.gcs_content_uri)
}
inline ::std::string* Document::mutable_gcs_content_uri() {
  if (!has_gcs_content_uri()) {
    clear_source();
    set_has_gcs_content_uri();
    source_.gcs_content_uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Document.gcs_content_uri)
  return source_.gcs_content_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Document::release_gcs_content_uri() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Document.gcs_content_uri)
  if (has_gcs_content_uri()) {
    clear_has_source();
    return source_.gcs_content_uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Document::set_allocated_gcs_content_uri(::std::string* gcs_content_uri) {
  if (!has_gcs_content_uri()) {
    source_.gcs_content_uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_source();
  if (gcs_content_uri != NULL) {
    set_has_gcs_content_uri();
    source_.gcs_content_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        gcs_content_uri);
  }
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Document.gcs_content_uri)
}

// string language = 4;
inline void Document::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Document::language() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Document.language)
  return language_.GetNoArena();
}
inline void Document::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Document.language)
}
#if LANG_CXX11
inline void Document::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.Document.language)
}
#endif
inline void Document::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.Document.language)
}
inline void Document::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.Document.language)
}
inline ::std::string* Document::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Document.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Document::release_language() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Document.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Document::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Document.language)
}

inline bool Document::has_source() const {
  return source_case() != SOURCE_NOT_SET;
}
inline void Document::clear_has_source() {
  _oneof_case_[0] = SOURCE_NOT_SET;
}
inline Document::SourceCase Document::source_case() const {
  return Document::SourceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Sentence

// .google.cloud.language.v1beta2.TextSpan text = 1;
inline bool Sentence::has_text() const {
  return this != internal_default_instance() && text_ != NULL;
}
inline void Sentence::clear_text() {
  if (GetArenaNoVirtual() == NULL && text_ != NULL) {
    delete text_;
  }
  text_ = NULL;
}
inline const ::google::cloud::language::v1beta2::TextSpan& Sentence::text() const {
  const ::google::cloud::language::v1beta2::TextSpan* p = text_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Sentence.text)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::TextSpan*>(
      &::google::cloud::language::v1beta2::_TextSpan_default_instance_);
}
inline ::google::cloud::language::v1beta2::TextSpan* Sentence::release_text() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Sentence.text)
  
  ::google::cloud::language::v1beta2::TextSpan* temp = text_;
  text_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::TextSpan* Sentence::mutable_text() {
  
  if (text_ == NULL) {
    text_ = new ::google::cloud::language::v1beta2::TextSpan;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Sentence.text)
  return text_;
}
inline void Sentence::set_allocated_text(::google::cloud::language::v1beta2::TextSpan* text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete text_;
  }
  if (text) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    
  } else {
    
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Sentence.text)
}

// .google.cloud.language.v1beta2.Sentiment sentiment = 2;
inline bool Sentence::has_sentiment() const {
  return this != internal_default_instance() && sentiment_ != NULL;
}
inline void Sentence::clear_sentiment() {
  if (GetArenaNoVirtual() == NULL && sentiment_ != NULL) {
    delete sentiment_;
  }
  sentiment_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Sentiment& Sentence::sentiment() const {
  const ::google::cloud::language::v1beta2::Sentiment* p = sentiment_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Sentence.sentiment)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Sentiment*>(
      &::google::cloud::language::v1beta2::_Sentiment_default_instance_);
}
inline ::google::cloud::language::v1beta2::Sentiment* Sentence::release_sentiment() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Sentence.sentiment)
  
  ::google::cloud::language::v1beta2::Sentiment* temp = sentiment_;
  sentiment_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Sentiment* Sentence::mutable_sentiment() {
  
  if (sentiment_ == NULL) {
    sentiment_ = new ::google::cloud::language::v1beta2::Sentiment;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Sentence.sentiment)
  return sentiment_;
}
inline void Sentence::set_allocated_sentiment(::google::cloud::language::v1beta2::Sentiment* sentiment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sentiment_;
  }
  if (sentiment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sentiment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sentiment, submessage_arena);
    }
    
  } else {
    
  }
  sentiment_ = sentiment;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Sentence.sentiment)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Entity

// string name = 1;
inline void Entity::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Entity::name() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Entity.name)
  return name_.GetNoArena();
}
inline void Entity::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Entity.name)
}
#if LANG_CXX11
inline void Entity::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.Entity.name)
}
#endif
inline void Entity::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.Entity.name)
}
inline void Entity::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.Entity.name)
}
inline ::std::string* Entity::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Entity.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entity::release_name() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Entity.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entity::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Entity.name)
}

// .google.cloud.language.v1beta2.Entity.Type type = 2;
inline void Entity::clear_type() {
  type_ = 0;
}
inline ::google::cloud::language::v1beta2::Entity_Type Entity::type() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Entity.type)
  return static_cast< ::google::cloud::language::v1beta2::Entity_Type >(type_);
}
inline void Entity::set_type(::google::cloud::language::v1beta2::Entity_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Entity.type)
}

// map<string, string> metadata = 3;
inline int Entity::metadata_size() const {
  return metadata_.size();
}
inline void Entity::clear_metadata() {
  metadata_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Entity::metadata() const {
  // @@protoc_insertion_point(field_map:google.cloud.language.v1beta2.Entity.metadata)
  return metadata_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Entity::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:google.cloud.language.v1beta2.Entity.metadata)
  return metadata_.MutableMap();
}

// float salience = 4;
inline void Entity::clear_salience() {
  salience_ = 0;
}
inline float Entity::salience() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Entity.salience)
  return salience_;
}
inline void Entity::set_salience(float value) {
  
  salience_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Entity.salience)
}

// repeated .google.cloud.language.v1beta2.EntityMention mentions = 5;
inline int Entity::mentions_size() const {
  return mentions_.size();
}
inline void Entity::clear_mentions() {
  mentions_.Clear();
}
inline const ::google::cloud::language::v1beta2::EntityMention& Entity::mentions(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Entity.mentions)
  return mentions_.Get(index);
}
inline ::google::cloud::language::v1beta2::EntityMention* Entity::mutable_mentions(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Entity.mentions)
  return mentions_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::EntityMention* Entity::add_mentions() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.Entity.mentions)
  return mentions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::EntityMention >*
Entity::mutable_mentions() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.Entity.mentions)
  return &mentions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::EntityMention >&
Entity::mentions() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.Entity.mentions)
  return mentions_;
}

// .google.cloud.language.v1beta2.Sentiment sentiment = 6;
inline bool Entity::has_sentiment() const {
  return this != internal_default_instance() && sentiment_ != NULL;
}
inline void Entity::clear_sentiment() {
  if (GetArenaNoVirtual() == NULL && sentiment_ != NULL) {
    delete sentiment_;
  }
  sentiment_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Sentiment& Entity::sentiment() const {
  const ::google::cloud::language::v1beta2::Sentiment* p = sentiment_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Entity.sentiment)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Sentiment*>(
      &::google::cloud::language::v1beta2::_Sentiment_default_instance_);
}
inline ::google::cloud::language::v1beta2::Sentiment* Entity::release_sentiment() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Entity.sentiment)
  
  ::google::cloud::language::v1beta2::Sentiment* temp = sentiment_;
  sentiment_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Sentiment* Entity::mutable_sentiment() {
  
  if (sentiment_ == NULL) {
    sentiment_ = new ::google::cloud::language::v1beta2::Sentiment;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Entity.sentiment)
  return sentiment_;
}
inline void Entity::set_allocated_sentiment(::google::cloud::language::v1beta2::Sentiment* sentiment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sentiment_;
  }
  if (sentiment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sentiment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sentiment, submessage_arena);
    }
    
  } else {
    
  }
  sentiment_ = sentiment;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Entity.sentiment)
}

// -------------------------------------------------------------------

// Token

// .google.cloud.language.v1beta2.TextSpan text = 1;
inline bool Token::has_text() const {
  return this != internal_default_instance() && text_ != NULL;
}
inline void Token::clear_text() {
  if (GetArenaNoVirtual() == NULL && text_ != NULL) {
    delete text_;
  }
  text_ = NULL;
}
inline const ::google::cloud::language::v1beta2::TextSpan& Token::text() const {
  const ::google::cloud::language::v1beta2::TextSpan* p = text_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Token.text)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::TextSpan*>(
      &::google::cloud::language::v1beta2::_TextSpan_default_instance_);
}
inline ::google::cloud::language::v1beta2::TextSpan* Token::release_text() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Token.text)
  
  ::google::cloud::language::v1beta2::TextSpan* temp = text_;
  text_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::TextSpan* Token::mutable_text() {
  
  if (text_ == NULL) {
    text_ = new ::google::cloud::language::v1beta2::TextSpan;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Token.text)
  return text_;
}
inline void Token::set_allocated_text(::google::cloud::language::v1beta2::TextSpan* text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete text_;
  }
  if (text) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    
  } else {
    
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Token.text)
}

// .google.cloud.language.v1beta2.PartOfSpeech part_of_speech = 2;
inline bool Token::has_part_of_speech() const {
  return this != internal_default_instance() && part_of_speech_ != NULL;
}
inline void Token::clear_part_of_speech() {
  if (GetArenaNoVirtual() == NULL && part_of_speech_ != NULL) {
    delete part_of_speech_;
  }
  part_of_speech_ = NULL;
}
inline const ::google::cloud::language::v1beta2::PartOfSpeech& Token::part_of_speech() const {
  const ::google::cloud::language::v1beta2::PartOfSpeech* p = part_of_speech_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Token.part_of_speech)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::PartOfSpeech*>(
      &::google::cloud::language::v1beta2::_PartOfSpeech_default_instance_);
}
inline ::google::cloud::language::v1beta2::PartOfSpeech* Token::release_part_of_speech() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Token.part_of_speech)
  
  ::google::cloud::language::v1beta2::PartOfSpeech* temp = part_of_speech_;
  part_of_speech_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech* Token::mutable_part_of_speech() {
  
  if (part_of_speech_ == NULL) {
    part_of_speech_ = new ::google::cloud::language::v1beta2::PartOfSpeech;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Token.part_of_speech)
  return part_of_speech_;
}
inline void Token::set_allocated_part_of_speech(::google::cloud::language::v1beta2::PartOfSpeech* part_of_speech) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete part_of_speech_;
  }
  if (part_of_speech) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      part_of_speech = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, part_of_speech, submessage_arena);
    }
    
  } else {
    
  }
  part_of_speech_ = part_of_speech;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Token.part_of_speech)
}

// .google.cloud.language.v1beta2.DependencyEdge dependency_edge = 3;
inline bool Token::has_dependency_edge() const {
  return this != internal_default_instance() && dependency_edge_ != NULL;
}
inline void Token::clear_dependency_edge() {
  if (GetArenaNoVirtual() == NULL && dependency_edge_ != NULL) {
    delete dependency_edge_;
  }
  dependency_edge_ = NULL;
}
inline const ::google::cloud::language::v1beta2::DependencyEdge& Token::dependency_edge() const {
  const ::google::cloud::language::v1beta2::DependencyEdge* p = dependency_edge_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Token.dependency_edge)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::DependencyEdge*>(
      &::google::cloud::language::v1beta2::_DependencyEdge_default_instance_);
}
inline ::google::cloud::language::v1beta2::DependencyEdge* Token::release_dependency_edge() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Token.dependency_edge)
  
  ::google::cloud::language::v1beta2::DependencyEdge* temp = dependency_edge_;
  dependency_edge_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::DependencyEdge* Token::mutable_dependency_edge() {
  
  if (dependency_edge_ == NULL) {
    dependency_edge_ = new ::google::cloud::language::v1beta2::DependencyEdge;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Token.dependency_edge)
  return dependency_edge_;
}
inline void Token::set_allocated_dependency_edge(::google::cloud::language::v1beta2::DependencyEdge* dependency_edge) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dependency_edge_;
  }
  if (dependency_edge) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dependency_edge = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dependency_edge, submessage_arena);
    }
    
  } else {
    
  }
  dependency_edge_ = dependency_edge;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Token.dependency_edge)
}

// string lemma = 4;
inline void Token::clear_lemma() {
  lemma_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Token::lemma() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Token.lemma)
  return lemma_.GetNoArena();
}
inline void Token::set_lemma(const ::std::string& value) {
  
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Token.lemma)
}
#if LANG_CXX11
inline void Token::set_lemma(::std::string&& value) {
  
  lemma_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.Token.lemma)
}
#endif
inline void Token::set_lemma(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.Token.lemma)
}
inline void Token::set_lemma(const char* value, size_t size) {
  
  lemma_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.Token.lemma)
}
inline ::std::string* Token::mutable_lemma() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.Token.lemma)
  return lemma_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Token::release_lemma() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.Token.lemma)
  
  return lemma_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_lemma(::std::string* lemma) {
  if (lemma != NULL) {
    
  } else {
    
  }
  lemma_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lemma);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.Token.lemma)
}

// -------------------------------------------------------------------

// Sentiment

// float magnitude = 2;
inline void Sentiment::clear_magnitude() {
  magnitude_ = 0;
}
inline float Sentiment::magnitude() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Sentiment.magnitude)
  return magnitude_;
}
inline void Sentiment::set_magnitude(float value) {
  
  magnitude_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Sentiment.magnitude)
}

// float score = 3;
inline void Sentiment::clear_score() {
  score_ = 0;
}
inline float Sentiment::score() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.Sentiment.score)
  return score_;
}
inline void Sentiment::set_score(float value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.Sentiment.score)
}

// -------------------------------------------------------------------

// PartOfSpeech

// .google.cloud.language.v1beta2.PartOfSpeech.Tag tag = 1;
inline void PartOfSpeech::clear_tag() {
  tag_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Tag PartOfSpeech::tag() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.tag)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Tag >(tag_);
}
inline void PartOfSpeech::set_tag(::google::cloud::language::v1beta2::PartOfSpeech_Tag value) {
  
  tag_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.tag)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Aspect aspect = 2;
inline void PartOfSpeech::clear_aspect() {
  aspect_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Aspect PartOfSpeech::aspect() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.aspect)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Aspect >(aspect_);
}
inline void PartOfSpeech::set_aspect(::google::cloud::language::v1beta2::PartOfSpeech_Aspect value) {
  
  aspect_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.aspect)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Case case = 3;
inline void PartOfSpeech::clear_case_() {
  case__ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Case PartOfSpeech::case_() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.case)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Case >(case__);
}
inline void PartOfSpeech::set_case_(::google::cloud::language::v1beta2::PartOfSpeech_Case value) {
  
  case__ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.case)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Form form = 4;
inline void PartOfSpeech::clear_form() {
  form_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Form PartOfSpeech::form() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.form)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Form >(form_);
}
inline void PartOfSpeech::set_form(::google::cloud::language::v1beta2::PartOfSpeech_Form value) {
  
  form_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.form)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Gender gender = 5;
inline void PartOfSpeech::clear_gender() {
  gender_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Gender PartOfSpeech::gender() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.gender)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Gender >(gender_);
}
inline void PartOfSpeech::set_gender(::google::cloud::language::v1beta2::PartOfSpeech_Gender value) {
  
  gender_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.gender)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Mood mood = 6;
inline void PartOfSpeech::clear_mood() {
  mood_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Mood PartOfSpeech::mood() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.mood)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Mood >(mood_);
}
inline void PartOfSpeech::set_mood(::google::cloud::language::v1beta2::PartOfSpeech_Mood value) {
  
  mood_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.mood)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Number number = 7;
inline void PartOfSpeech::clear_number() {
  number_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Number PartOfSpeech::number() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.number)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Number >(number_);
}
inline void PartOfSpeech::set_number(::google::cloud::language::v1beta2::PartOfSpeech_Number value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.number)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Person person = 8;
inline void PartOfSpeech::clear_person() {
  person_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Person PartOfSpeech::person() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.person)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Person >(person_);
}
inline void PartOfSpeech::set_person(::google::cloud::language::v1beta2::PartOfSpeech_Person value) {
  
  person_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.person)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Proper proper = 9;
inline void PartOfSpeech::clear_proper() {
  proper_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Proper PartOfSpeech::proper() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.proper)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Proper >(proper_);
}
inline void PartOfSpeech::set_proper(::google::cloud::language::v1beta2::PartOfSpeech_Proper value) {
  
  proper_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.proper)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Reciprocity reciprocity = 10;
inline void PartOfSpeech::clear_reciprocity() {
  reciprocity_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Reciprocity PartOfSpeech::reciprocity() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.reciprocity)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Reciprocity >(reciprocity_);
}
inline void PartOfSpeech::set_reciprocity(::google::cloud::language::v1beta2::PartOfSpeech_Reciprocity value) {
  
  reciprocity_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.reciprocity)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Tense tense = 11;
inline void PartOfSpeech::clear_tense() {
  tense_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Tense PartOfSpeech::tense() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.tense)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Tense >(tense_);
}
inline void PartOfSpeech::set_tense(::google::cloud::language::v1beta2::PartOfSpeech_Tense value) {
  
  tense_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.tense)
}

// .google.cloud.language.v1beta2.PartOfSpeech.Voice voice = 12;
inline void PartOfSpeech::clear_voice() {
  voice_ = 0;
}
inline ::google::cloud::language::v1beta2::PartOfSpeech_Voice PartOfSpeech::voice() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.PartOfSpeech.voice)
  return static_cast< ::google::cloud::language::v1beta2::PartOfSpeech_Voice >(voice_);
}
inline void PartOfSpeech::set_voice(::google::cloud::language::v1beta2::PartOfSpeech_Voice value) {
  
  voice_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.PartOfSpeech.voice)
}

// -------------------------------------------------------------------

// DependencyEdge

// int32 head_token_index = 1;
inline void DependencyEdge::clear_head_token_index() {
  head_token_index_ = 0;
}
inline ::google::protobuf::int32 DependencyEdge::head_token_index() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.DependencyEdge.head_token_index)
  return head_token_index_;
}
inline void DependencyEdge::set_head_token_index(::google::protobuf::int32 value) {
  
  head_token_index_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.DependencyEdge.head_token_index)
}

// .google.cloud.language.v1beta2.DependencyEdge.Label label = 2;
inline void DependencyEdge::clear_label() {
  label_ = 0;
}
inline ::google::cloud::language::v1beta2::DependencyEdge_Label DependencyEdge::label() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.DependencyEdge.label)
  return static_cast< ::google::cloud::language::v1beta2::DependencyEdge_Label >(label_);
}
inline void DependencyEdge::set_label(::google::cloud::language::v1beta2::DependencyEdge_Label value) {
  
  label_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.DependencyEdge.label)
}

// -------------------------------------------------------------------

// EntityMention

// .google.cloud.language.v1beta2.TextSpan text = 1;
inline bool EntityMention::has_text() const {
  return this != internal_default_instance() && text_ != NULL;
}
inline void EntityMention::clear_text() {
  if (GetArenaNoVirtual() == NULL && text_ != NULL) {
    delete text_;
  }
  text_ = NULL;
}
inline const ::google::cloud::language::v1beta2::TextSpan& EntityMention::text() const {
  const ::google::cloud::language::v1beta2::TextSpan* p = text_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.EntityMention.text)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::TextSpan*>(
      &::google::cloud::language::v1beta2::_TextSpan_default_instance_);
}
inline ::google::cloud::language::v1beta2::TextSpan* EntityMention::release_text() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.EntityMention.text)
  
  ::google::cloud::language::v1beta2::TextSpan* temp = text_;
  text_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::TextSpan* EntityMention::mutable_text() {
  
  if (text_ == NULL) {
    text_ = new ::google::cloud::language::v1beta2::TextSpan;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.EntityMention.text)
  return text_;
}
inline void EntityMention::set_allocated_text(::google::cloud::language::v1beta2::TextSpan* text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete text_;
  }
  if (text) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    
  } else {
    
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.EntityMention.text)
}

// .google.cloud.language.v1beta2.EntityMention.Type type = 2;
inline void EntityMention::clear_type() {
  type_ = 0;
}
inline ::google::cloud::language::v1beta2::EntityMention_Type EntityMention::type() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.EntityMention.type)
  return static_cast< ::google::cloud::language::v1beta2::EntityMention_Type >(type_);
}
inline void EntityMention::set_type(::google::cloud::language::v1beta2::EntityMention_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.EntityMention.type)
}

// .google.cloud.language.v1beta2.Sentiment sentiment = 3;
inline bool EntityMention::has_sentiment() const {
  return this != internal_default_instance() && sentiment_ != NULL;
}
inline void EntityMention::clear_sentiment() {
  if (GetArenaNoVirtual() == NULL && sentiment_ != NULL) {
    delete sentiment_;
  }
  sentiment_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Sentiment& EntityMention::sentiment() const {
  const ::google::cloud::language::v1beta2::Sentiment* p = sentiment_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.EntityMention.sentiment)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Sentiment*>(
      &::google::cloud::language::v1beta2::_Sentiment_default_instance_);
}
inline ::google::cloud::language::v1beta2::Sentiment* EntityMention::release_sentiment() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.EntityMention.sentiment)
  
  ::google::cloud::language::v1beta2::Sentiment* temp = sentiment_;
  sentiment_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Sentiment* EntityMention::mutable_sentiment() {
  
  if (sentiment_ == NULL) {
    sentiment_ = new ::google::cloud::language::v1beta2::Sentiment;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.EntityMention.sentiment)
  return sentiment_;
}
inline void EntityMention::set_allocated_sentiment(::google::cloud::language::v1beta2::Sentiment* sentiment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sentiment_;
  }
  if (sentiment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sentiment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sentiment, submessage_arena);
    }
    
  } else {
    
  }
  sentiment_ = sentiment;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.EntityMention.sentiment)
}

// -------------------------------------------------------------------

// TextSpan

// string content = 1;
inline void TextSpan::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextSpan::content() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.TextSpan.content)
  return content_.GetNoArena();
}
inline void TextSpan::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.TextSpan.content)
}
#if LANG_CXX11
inline void TextSpan::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.TextSpan.content)
}
#endif
inline void TextSpan::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.TextSpan.content)
}
inline void TextSpan::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.TextSpan.content)
}
inline ::std::string* TextSpan::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.TextSpan.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextSpan::release_content() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.TextSpan.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSpan::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.TextSpan.content)
}

// int32 begin_offset = 2;
inline void TextSpan::clear_begin_offset() {
  begin_offset_ = 0;
}
inline ::google::protobuf::int32 TextSpan::begin_offset() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.TextSpan.begin_offset)
  return begin_offset_;
}
inline void TextSpan::set_begin_offset(::google::protobuf::int32 value) {
  
  begin_offset_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.TextSpan.begin_offset)
}

// -------------------------------------------------------------------

// ClassificationCategory

// string name = 1;
inline void ClassificationCategory::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClassificationCategory::name() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.ClassificationCategory.name)
  return name_.GetNoArena();
}
inline void ClassificationCategory::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.ClassificationCategory.name)
}
#if LANG_CXX11
inline void ClassificationCategory::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.ClassificationCategory.name)
}
#endif
inline void ClassificationCategory::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.ClassificationCategory.name)
}
inline void ClassificationCategory::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.ClassificationCategory.name)
}
inline ::std::string* ClassificationCategory::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.ClassificationCategory.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClassificationCategory::release_name() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.ClassificationCategory.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClassificationCategory::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.ClassificationCategory.name)
}

// float confidence = 2;
inline void ClassificationCategory::clear_confidence() {
  confidence_ = 0;
}
inline float ClassificationCategory::confidence() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.ClassificationCategory.confidence)
  return confidence_;
}
inline void ClassificationCategory::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.ClassificationCategory.confidence)
}

// -------------------------------------------------------------------

// AnalyzeSentimentRequest

// .google.cloud.language.v1beta2.Document document = 1;
inline bool AnalyzeSentimentRequest::has_document() const {
  return this != internal_default_instance() && document_ != NULL;
}
inline void AnalyzeSentimentRequest::clear_document() {
  if (GetArenaNoVirtual() == NULL && document_ != NULL) {
    delete document_;
  }
  document_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Document& AnalyzeSentimentRequest::document() const {
  const ::google::cloud::language::v1beta2::Document* p = document_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSentimentRequest.document)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Document*>(
      &::google::cloud::language::v1beta2::_Document_default_instance_);
}
inline ::google::cloud::language::v1beta2::Document* AnalyzeSentimentRequest::release_document() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnalyzeSentimentRequest.document)
  
  ::google::cloud::language::v1beta2::Document* temp = document_;
  document_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Document* AnalyzeSentimentRequest::mutable_document() {
  
  if (document_ == NULL) {
    document_ = new ::google::cloud::language::v1beta2::Document;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeSentimentRequest.document)
  return document_;
}
inline void AnalyzeSentimentRequest::set_allocated_document(::google::cloud::language::v1beta2::Document* document) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete document_;
  }
  if (document) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      document = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnalyzeSentimentRequest.document)
}

// .google.cloud.language.v1beta2.EncodingType encoding_type = 2;
inline void AnalyzeSentimentRequest::clear_encoding_type() {
  encoding_type_ = 0;
}
inline ::google::cloud::language::v1beta2::EncodingType AnalyzeSentimentRequest::encoding_type() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSentimentRequest.encoding_type)
  return static_cast< ::google::cloud::language::v1beta2::EncodingType >(encoding_type_);
}
inline void AnalyzeSentimentRequest::set_encoding_type(::google::cloud::language::v1beta2::EncodingType value) {
  
  encoding_type_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnalyzeSentimentRequest.encoding_type)
}

// -------------------------------------------------------------------

// AnalyzeSentimentResponse

// .google.cloud.language.v1beta2.Sentiment document_sentiment = 1;
inline bool AnalyzeSentimentResponse::has_document_sentiment() const {
  return this != internal_default_instance() && document_sentiment_ != NULL;
}
inline void AnalyzeSentimentResponse::clear_document_sentiment() {
  if (GetArenaNoVirtual() == NULL && document_sentiment_ != NULL) {
    delete document_sentiment_;
  }
  document_sentiment_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Sentiment& AnalyzeSentimentResponse::document_sentiment() const {
  const ::google::cloud::language::v1beta2::Sentiment* p = document_sentiment_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSentimentResponse.document_sentiment)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Sentiment*>(
      &::google::cloud::language::v1beta2::_Sentiment_default_instance_);
}
inline ::google::cloud::language::v1beta2::Sentiment* AnalyzeSentimentResponse::release_document_sentiment() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnalyzeSentimentResponse.document_sentiment)
  
  ::google::cloud::language::v1beta2::Sentiment* temp = document_sentiment_;
  document_sentiment_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Sentiment* AnalyzeSentimentResponse::mutable_document_sentiment() {
  
  if (document_sentiment_ == NULL) {
    document_sentiment_ = new ::google::cloud::language::v1beta2::Sentiment;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeSentimentResponse.document_sentiment)
  return document_sentiment_;
}
inline void AnalyzeSentimentResponse::set_allocated_document_sentiment(::google::cloud::language::v1beta2::Sentiment* document_sentiment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete document_sentiment_;
  }
  if (document_sentiment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      document_sentiment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, document_sentiment, submessage_arena);
    }
    
  } else {
    
  }
  document_sentiment_ = document_sentiment;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnalyzeSentimentResponse.document_sentiment)
}

// string language = 2;
inline void AnalyzeSentimentResponse::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnalyzeSentimentResponse::language() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSentimentResponse.language)
  return language_.GetNoArena();
}
inline void AnalyzeSentimentResponse::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnalyzeSentimentResponse.language)
}
#if LANG_CXX11
inline void AnalyzeSentimentResponse::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.AnalyzeSentimentResponse.language)
}
#endif
inline void AnalyzeSentimentResponse::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.AnalyzeSentimentResponse.language)
}
inline void AnalyzeSentimentResponse::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.AnalyzeSentimentResponse.language)
}
inline ::std::string* AnalyzeSentimentResponse::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeSentimentResponse.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalyzeSentimentResponse::release_language() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnalyzeSentimentResponse.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalyzeSentimentResponse::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnalyzeSentimentResponse.language)
}

// repeated .google.cloud.language.v1beta2.Sentence sentences = 3;
inline int AnalyzeSentimentResponse::sentences_size() const {
  return sentences_.size();
}
inline void AnalyzeSentimentResponse::clear_sentences() {
  sentences_.Clear();
}
inline const ::google::cloud::language::v1beta2::Sentence& AnalyzeSentimentResponse::sentences(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSentimentResponse.sentences)
  return sentences_.Get(index);
}
inline ::google::cloud::language::v1beta2::Sentence* AnalyzeSentimentResponse::mutable_sentences(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeSentimentResponse.sentences)
  return sentences_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::Sentence* AnalyzeSentimentResponse::add_sentences() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.AnalyzeSentimentResponse.sentences)
  return sentences_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >*
AnalyzeSentimentResponse::mutable_sentences() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.AnalyzeSentimentResponse.sentences)
  return &sentences_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >&
AnalyzeSentimentResponse::sentences() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.AnalyzeSentimentResponse.sentences)
  return sentences_;
}

// -------------------------------------------------------------------

// AnalyzeEntitySentimentRequest

// .google.cloud.language.v1beta2.Document document = 1;
inline bool AnalyzeEntitySentimentRequest::has_document() const {
  return this != internal_default_instance() && document_ != NULL;
}
inline void AnalyzeEntitySentimentRequest::clear_document() {
  if (GetArenaNoVirtual() == NULL && document_ != NULL) {
    delete document_;
  }
  document_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Document& AnalyzeEntitySentimentRequest::document() const {
  const ::google::cloud::language::v1beta2::Document* p = document_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeEntitySentimentRequest.document)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Document*>(
      &::google::cloud::language::v1beta2::_Document_default_instance_);
}
inline ::google::cloud::language::v1beta2::Document* AnalyzeEntitySentimentRequest::release_document() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnalyzeEntitySentimentRequest.document)
  
  ::google::cloud::language::v1beta2::Document* temp = document_;
  document_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Document* AnalyzeEntitySentimentRequest::mutable_document() {
  
  if (document_ == NULL) {
    document_ = new ::google::cloud::language::v1beta2::Document;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeEntitySentimentRequest.document)
  return document_;
}
inline void AnalyzeEntitySentimentRequest::set_allocated_document(::google::cloud::language::v1beta2::Document* document) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete document_;
  }
  if (document) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      document = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnalyzeEntitySentimentRequest.document)
}

// .google.cloud.language.v1beta2.EncodingType encoding_type = 2;
inline void AnalyzeEntitySentimentRequest::clear_encoding_type() {
  encoding_type_ = 0;
}
inline ::google::cloud::language::v1beta2::EncodingType AnalyzeEntitySentimentRequest::encoding_type() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeEntitySentimentRequest.encoding_type)
  return static_cast< ::google::cloud::language::v1beta2::EncodingType >(encoding_type_);
}
inline void AnalyzeEntitySentimentRequest::set_encoding_type(::google::cloud::language::v1beta2::EncodingType value) {
  
  encoding_type_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnalyzeEntitySentimentRequest.encoding_type)
}

// -------------------------------------------------------------------

// AnalyzeEntitySentimentResponse

// repeated .google.cloud.language.v1beta2.Entity entities = 1;
inline int AnalyzeEntitySentimentResponse::entities_size() const {
  return entities_.size();
}
inline void AnalyzeEntitySentimentResponse::clear_entities() {
  entities_.Clear();
}
inline const ::google::cloud::language::v1beta2::Entity& AnalyzeEntitySentimentResponse::entities(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.entities)
  return entities_.Get(index);
}
inline ::google::cloud::language::v1beta2::Entity* AnalyzeEntitySentimentResponse::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.entities)
  return entities_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::Entity* AnalyzeEntitySentimentResponse::add_entities() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.entities)
  return entities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >*
AnalyzeEntitySentimentResponse::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.entities)
  return &entities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >&
AnalyzeEntitySentimentResponse::entities() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.entities)
  return entities_;
}

// string language = 2;
inline void AnalyzeEntitySentimentResponse::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnalyzeEntitySentimentResponse::language() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.language)
  return language_.GetNoArena();
}
inline void AnalyzeEntitySentimentResponse::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.language)
}
#if LANG_CXX11
inline void AnalyzeEntitySentimentResponse::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.language)
}
#endif
inline void AnalyzeEntitySentimentResponse::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.language)
}
inline void AnalyzeEntitySentimentResponse::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.language)
}
inline ::std::string* AnalyzeEntitySentimentResponse::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalyzeEntitySentimentResponse::release_language() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalyzeEntitySentimentResponse::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnalyzeEntitySentimentResponse.language)
}

// -------------------------------------------------------------------

// AnalyzeEntitiesRequest

// .google.cloud.language.v1beta2.Document document = 1;
inline bool AnalyzeEntitiesRequest::has_document() const {
  return this != internal_default_instance() && document_ != NULL;
}
inline void AnalyzeEntitiesRequest::clear_document() {
  if (GetArenaNoVirtual() == NULL && document_ != NULL) {
    delete document_;
  }
  document_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Document& AnalyzeEntitiesRequest::document() const {
  const ::google::cloud::language::v1beta2::Document* p = document_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeEntitiesRequest.document)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Document*>(
      &::google::cloud::language::v1beta2::_Document_default_instance_);
}
inline ::google::cloud::language::v1beta2::Document* AnalyzeEntitiesRequest::release_document() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnalyzeEntitiesRequest.document)
  
  ::google::cloud::language::v1beta2::Document* temp = document_;
  document_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Document* AnalyzeEntitiesRequest::mutable_document() {
  
  if (document_ == NULL) {
    document_ = new ::google::cloud::language::v1beta2::Document;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeEntitiesRequest.document)
  return document_;
}
inline void AnalyzeEntitiesRequest::set_allocated_document(::google::cloud::language::v1beta2::Document* document) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete document_;
  }
  if (document) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      document = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnalyzeEntitiesRequest.document)
}

// .google.cloud.language.v1beta2.EncodingType encoding_type = 2;
inline void AnalyzeEntitiesRequest::clear_encoding_type() {
  encoding_type_ = 0;
}
inline ::google::cloud::language::v1beta2::EncodingType AnalyzeEntitiesRequest::encoding_type() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeEntitiesRequest.encoding_type)
  return static_cast< ::google::cloud::language::v1beta2::EncodingType >(encoding_type_);
}
inline void AnalyzeEntitiesRequest::set_encoding_type(::google::cloud::language::v1beta2::EncodingType value) {
  
  encoding_type_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnalyzeEntitiesRequest.encoding_type)
}

// -------------------------------------------------------------------

// AnalyzeEntitiesResponse

// repeated .google.cloud.language.v1beta2.Entity entities = 1;
inline int AnalyzeEntitiesResponse::entities_size() const {
  return entities_.size();
}
inline void AnalyzeEntitiesResponse::clear_entities() {
  entities_.Clear();
}
inline const ::google::cloud::language::v1beta2::Entity& AnalyzeEntitiesResponse::entities(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.entities)
  return entities_.Get(index);
}
inline ::google::cloud::language::v1beta2::Entity* AnalyzeEntitiesResponse::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.entities)
  return entities_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::Entity* AnalyzeEntitiesResponse::add_entities() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.entities)
  return entities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >*
AnalyzeEntitiesResponse::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.entities)
  return &entities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >&
AnalyzeEntitiesResponse::entities() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.entities)
  return entities_;
}

// string language = 2;
inline void AnalyzeEntitiesResponse::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnalyzeEntitiesResponse::language() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.language)
  return language_.GetNoArena();
}
inline void AnalyzeEntitiesResponse::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.language)
}
#if LANG_CXX11
inline void AnalyzeEntitiesResponse::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.language)
}
#endif
inline void AnalyzeEntitiesResponse::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.language)
}
inline void AnalyzeEntitiesResponse::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.language)
}
inline ::std::string* AnalyzeEntitiesResponse::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalyzeEntitiesResponse::release_language() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalyzeEntitiesResponse::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnalyzeEntitiesResponse.language)
}

// -------------------------------------------------------------------

// AnalyzeSyntaxRequest

// .google.cloud.language.v1beta2.Document document = 1;
inline bool AnalyzeSyntaxRequest::has_document() const {
  return this != internal_default_instance() && document_ != NULL;
}
inline void AnalyzeSyntaxRequest::clear_document() {
  if (GetArenaNoVirtual() == NULL && document_ != NULL) {
    delete document_;
  }
  document_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Document& AnalyzeSyntaxRequest::document() const {
  const ::google::cloud::language::v1beta2::Document* p = document_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSyntaxRequest.document)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Document*>(
      &::google::cloud::language::v1beta2::_Document_default_instance_);
}
inline ::google::cloud::language::v1beta2::Document* AnalyzeSyntaxRequest::release_document() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnalyzeSyntaxRequest.document)
  
  ::google::cloud::language::v1beta2::Document* temp = document_;
  document_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Document* AnalyzeSyntaxRequest::mutable_document() {
  
  if (document_ == NULL) {
    document_ = new ::google::cloud::language::v1beta2::Document;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeSyntaxRequest.document)
  return document_;
}
inline void AnalyzeSyntaxRequest::set_allocated_document(::google::cloud::language::v1beta2::Document* document) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete document_;
  }
  if (document) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      document = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnalyzeSyntaxRequest.document)
}

// .google.cloud.language.v1beta2.EncodingType encoding_type = 2;
inline void AnalyzeSyntaxRequest::clear_encoding_type() {
  encoding_type_ = 0;
}
inline ::google::cloud::language::v1beta2::EncodingType AnalyzeSyntaxRequest::encoding_type() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSyntaxRequest.encoding_type)
  return static_cast< ::google::cloud::language::v1beta2::EncodingType >(encoding_type_);
}
inline void AnalyzeSyntaxRequest::set_encoding_type(::google::cloud::language::v1beta2::EncodingType value) {
  
  encoding_type_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnalyzeSyntaxRequest.encoding_type)
}

// -------------------------------------------------------------------

// AnalyzeSyntaxResponse

// repeated .google.cloud.language.v1beta2.Sentence sentences = 1;
inline int AnalyzeSyntaxResponse::sentences_size() const {
  return sentences_.size();
}
inline void AnalyzeSyntaxResponse::clear_sentences() {
  sentences_.Clear();
}
inline const ::google::cloud::language::v1beta2::Sentence& AnalyzeSyntaxResponse::sentences(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.sentences)
  return sentences_.Get(index);
}
inline ::google::cloud::language::v1beta2::Sentence* AnalyzeSyntaxResponse::mutable_sentences(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.sentences)
  return sentences_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::Sentence* AnalyzeSyntaxResponse::add_sentences() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.sentences)
  return sentences_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >*
AnalyzeSyntaxResponse::mutable_sentences() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.sentences)
  return &sentences_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >&
AnalyzeSyntaxResponse::sentences() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.sentences)
  return sentences_;
}

// repeated .google.cloud.language.v1beta2.Token tokens = 2;
inline int AnalyzeSyntaxResponse::tokens_size() const {
  return tokens_.size();
}
inline void AnalyzeSyntaxResponse::clear_tokens() {
  tokens_.Clear();
}
inline const ::google::cloud::language::v1beta2::Token& AnalyzeSyntaxResponse::tokens(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.tokens)
  return tokens_.Get(index);
}
inline ::google::cloud::language::v1beta2::Token* AnalyzeSyntaxResponse::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.tokens)
  return tokens_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::Token* AnalyzeSyntaxResponse::add_tokens() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.tokens)
  return tokens_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token >*
AnalyzeSyntaxResponse::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.tokens)
  return &tokens_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token >&
AnalyzeSyntaxResponse::tokens() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.tokens)
  return tokens_;
}

// string language = 3;
inline void AnalyzeSyntaxResponse::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnalyzeSyntaxResponse::language() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.language)
  return language_.GetNoArena();
}
inline void AnalyzeSyntaxResponse::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.language)
}
#if LANG_CXX11
inline void AnalyzeSyntaxResponse::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.language)
}
#endif
inline void AnalyzeSyntaxResponse::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.language)
}
inline void AnalyzeSyntaxResponse::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.language)
}
inline ::std::string* AnalyzeSyntaxResponse::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalyzeSyntaxResponse::release_language() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalyzeSyntaxResponse::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnalyzeSyntaxResponse.language)
}

// -------------------------------------------------------------------

// ClassifyTextRequest

// .google.cloud.language.v1beta2.Document document = 1;
inline bool ClassifyTextRequest::has_document() const {
  return this != internal_default_instance() && document_ != NULL;
}
inline void ClassifyTextRequest::clear_document() {
  if (GetArenaNoVirtual() == NULL && document_ != NULL) {
    delete document_;
  }
  document_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Document& ClassifyTextRequest::document() const {
  const ::google::cloud::language::v1beta2::Document* p = document_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.ClassifyTextRequest.document)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Document*>(
      &::google::cloud::language::v1beta2::_Document_default_instance_);
}
inline ::google::cloud::language::v1beta2::Document* ClassifyTextRequest::release_document() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.ClassifyTextRequest.document)
  
  ::google::cloud::language::v1beta2::Document* temp = document_;
  document_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Document* ClassifyTextRequest::mutable_document() {
  
  if (document_ == NULL) {
    document_ = new ::google::cloud::language::v1beta2::Document;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.ClassifyTextRequest.document)
  return document_;
}
inline void ClassifyTextRequest::set_allocated_document(::google::cloud::language::v1beta2::Document* document) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete document_;
  }
  if (document) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      document = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.ClassifyTextRequest.document)
}

// -------------------------------------------------------------------

// ClassifyTextResponse

// repeated .google.cloud.language.v1beta2.ClassificationCategory categories = 1;
inline int ClassifyTextResponse::categories_size() const {
  return categories_.size();
}
inline void ClassifyTextResponse::clear_categories() {
  categories_.Clear();
}
inline const ::google::cloud::language::v1beta2::ClassificationCategory& ClassifyTextResponse::categories(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.ClassifyTextResponse.categories)
  return categories_.Get(index);
}
inline ::google::cloud::language::v1beta2::ClassificationCategory* ClassifyTextResponse::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.ClassifyTextResponse.categories)
  return categories_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::ClassificationCategory* ClassifyTextResponse::add_categories() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.ClassifyTextResponse.categories)
  return categories_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory >*
ClassifyTextResponse::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.ClassifyTextResponse.categories)
  return &categories_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory >&
ClassifyTextResponse::categories() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.ClassifyTextResponse.categories)
  return categories_;
}

// -------------------------------------------------------------------

// AnnotateTextRequest_Features

// bool extract_syntax = 1;
inline void AnnotateTextRequest_Features::clear_extract_syntax() {
  extract_syntax_ = false;
}
inline bool AnnotateTextRequest_Features::extract_syntax() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextRequest.Features.extract_syntax)
  return extract_syntax_;
}
inline void AnnotateTextRequest_Features::set_extract_syntax(bool value) {
  
  extract_syntax_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnnotateTextRequest.Features.extract_syntax)
}

// bool extract_entities = 2;
inline void AnnotateTextRequest_Features::clear_extract_entities() {
  extract_entities_ = false;
}
inline bool AnnotateTextRequest_Features::extract_entities() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextRequest.Features.extract_entities)
  return extract_entities_;
}
inline void AnnotateTextRequest_Features::set_extract_entities(bool value) {
  
  extract_entities_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnnotateTextRequest.Features.extract_entities)
}

// bool extract_document_sentiment = 3;
inline void AnnotateTextRequest_Features::clear_extract_document_sentiment() {
  extract_document_sentiment_ = false;
}
inline bool AnnotateTextRequest_Features::extract_document_sentiment() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextRequest.Features.extract_document_sentiment)
  return extract_document_sentiment_;
}
inline void AnnotateTextRequest_Features::set_extract_document_sentiment(bool value) {
  
  extract_document_sentiment_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnnotateTextRequest.Features.extract_document_sentiment)
}

// bool extract_entity_sentiment = 4;
inline void AnnotateTextRequest_Features::clear_extract_entity_sentiment() {
  extract_entity_sentiment_ = false;
}
inline bool AnnotateTextRequest_Features::extract_entity_sentiment() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextRequest.Features.extract_entity_sentiment)
  return extract_entity_sentiment_;
}
inline void AnnotateTextRequest_Features::set_extract_entity_sentiment(bool value) {
  
  extract_entity_sentiment_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnnotateTextRequest.Features.extract_entity_sentiment)
}

// bool classify_text = 6;
inline void AnnotateTextRequest_Features::clear_classify_text() {
  classify_text_ = false;
}
inline bool AnnotateTextRequest_Features::classify_text() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextRequest.Features.classify_text)
  return classify_text_;
}
inline void AnnotateTextRequest_Features::set_classify_text(bool value) {
  
  classify_text_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnnotateTextRequest.Features.classify_text)
}

// -------------------------------------------------------------------

// AnnotateTextRequest

// .google.cloud.language.v1beta2.Document document = 1;
inline bool AnnotateTextRequest::has_document() const {
  return this != internal_default_instance() && document_ != NULL;
}
inline void AnnotateTextRequest::clear_document() {
  if (GetArenaNoVirtual() == NULL && document_ != NULL) {
    delete document_;
  }
  document_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Document& AnnotateTextRequest::document() const {
  const ::google::cloud::language::v1beta2::Document* p = document_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextRequest.document)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Document*>(
      &::google::cloud::language::v1beta2::_Document_default_instance_);
}
inline ::google::cloud::language::v1beta2::Document* AnnotateTextRequest::release_document() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnnotateTextRequest.document)
  
  ::google::cloud::language::v1beta2::Document* temp = document_;
  document_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Document* AnnotateTextRequest::mutable_document() {
  
  if (document_ == NULL) {
    document_ = new ::google::cloud::language::v1beta2::Document;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnnotateTextRequest.document)
  return document_;
}
inline void AnnotateTextRequest::set_allocated_document(::google::cloud::language::v1beta2::Document* document) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete document_;
  }
  if (document) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      document = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnnotateTextRequest.document)
}

// .google.cloud.language.v1beta2.AnnotateTextRequest.Features features = 2;
inline bool AnnotateTextRequest::has_features() const {
  return this != internal_default_instance() && features_ != NULL;
}
inline void AnnotateTextRequest::clear_features() {
  if (GetArenaNoVirtual() == NULL && features_ != NULL) {
    delete features_;
  }
  features_ = NULL;
}
inline const ::google::cloud::language::v1beta2::AnnotateTextRequest_Features& AnnotateTextRequest::features() const {
  const ::google::cloud::language::v1beta2::AnnotateTextRequest_Features* p = features_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextRequest.features)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::AnnotateTextRequest_Features*>(
      &::google::cloud::language::v1beta2::_AnnotateTextRequest_Features_default_instance_);
}
inline ::google::cloud::language::v1beta2::AnnotateTextRequest_Features* AnnotateTextRequest::release_features() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnnotateTextRequest.features)
  
  ::google::cloud::language::v1beta2::AnnotateTextRequest_Features* temp = features_;
  features_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::AnnotateTextRequest_Features* AnnotateTextRequest::mutable_features() {
  
  if (features_ == NULL) {
    features_ = new ::google::cloud::language::v1beta2::AnnotateTextRequest_Features;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnnotateTextRequest.features)
  return features_;
}
inline void AnnotateTextRequest::set_allocated_features(::google::cloud::language::v1beta2::AnnotateTextRequest_Features* features) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete features_;
  }
  if (features) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      features = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, features, submessage_arena);
    }
    
  } else {
    
  }
  features_ = features;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnnotateTextRequest.features)
}

// .google.cloud.language.v1beta2.EncodingType encoding_type = 3;
inline void AnnotateTextRequest::clear_encoding_type() {
  encoding_type_ = 0;
}
inline ::google::cloud::language::v1beta2::EncodingType AnnotateTextRequest::encoding_type() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextRequest.encoding_type)
  return static_cast< ::google::cloud::language::v1beta2::EncodingType >(encoding_type_);
}
inline void AnnotateTextRequest::set_encoding_type(::google::cloud::language::v1beta2::EncodingType value) {
  
  encoding_type_ = value;
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnnotateTextRequest.encoding_type)
}

// -------------------------------------------------------------------

// AnnotateTextResponse

// repeated .google.cloud.language.v1beta2.Sentence sentences = 1;
inline int AnnotateTextResponse::sentences_size() const {
  return sentences_.size();
}
inline void AnnotateTextResponse::clear_sentences() {
  sentences_.Clear();
}
inline const ::google::cloud::language::v1beta2::Sentence& AnnotateTextResponse::sentences(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextResponse.sentences)
  return sentences_.Get(index);
}
inline ::google::cloud::language::v1beta2::Sentence* AnnotateTextResponse::mutable_sentences(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnnotateTextResponse.sentences)
  return sentences_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::Sentence* AnnotateTextResponse::add_sentences() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.AnnotateTextResponse.sentences)
  return sentences_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >*
AnnotateTextResponse::mutable_sentences() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.AnnotateTextResponse.sentences)
  return &sentences_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Sentence >&
AnnotateTextResponse::sentences() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.AnnotateTextResponse.sentences)
  return sentences_;
}

// repeated .google.cloud.language.v1beta2.Token tokens = 2;
inline int AnnotateTextResponse::tokens_size() const {
  return tokens_.size();
}
inline void AnnotateTextResponse::clear_tokens() {
  tokens_.Clear();
}
inline const ::google::cloud::language::v1beta2::Token& AnnotateTextResponse::tokens(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextResponse.tokens)
  return tokens_.Get(index);
}
inline ::google::cloud::language::v1beta2::Token* AnnotateTextResponse::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnnotateTextResponse.tokens)
  return tokens_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::Token* AnnotateTextResponse::add_tokens() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.AnnotateTextResponse.tokens)
  return tokens_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token >*
AnnotateTextResponse::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.AnnotateTextResponse.tokens)
  return &tokens_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Token >&
AnnotateTextResponse::tokens() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.AnnotateTextResponse.tokens)
  return tokens_;
}

// repeated .google.cloud.language.v1beta2.Entity entities = 3;
inline int AnnotateTextResponse::entities_size() const {
  return entities_.size();
}
inline void AnnotateTextResponse::clear_entities() {
  entities_.Clear();
}
inline const ::google::cloud::language::v1beta2::Entity& AnnotateTextResponse::entities(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextResponse.entities)
  return entities_.Get(index);
}
inline ::google::cloud::language::v1beta2::Entity* AnnotateTextResponse::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnnotateTextResponse.entities)
  return entities_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::Entity* AnnotateTextResponse::add_entities() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.AnnotateTextResponse.entities)
  return entities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >*
AnnotateTextResponse::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.AnnotateTextResponse.entities)
  return &entities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::Entity >&
AnnotateTextResponse::entities() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.AnnotateTextResponse.entities)
  return entities_;
}

// .google.cloud.language.v1beta2.Sentiment document_sentiment = 4;
inline bool AnnotateTextResponse::has_document_sentiment() const {
  return this != internal_default_instance() && document_sentiment_ != NULL;
}
inline void AnnotateTextResponse::clear_document_sentiment() {
  if (GetArenaNoVirtual() == NULL && document_sentiment_ != NULL) {
    delete document_sentiment_;
  }
  document_sentiment_ = NULL;
}
inline const ::google::cloud::language::v1beta2::Sentiment& AnnotateTextResponse::document_sentiment() const {
  const ::google::cloud::language::v1beta2::Sentiment* p = document_sentiment_;
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextResponse.document_sentiment)
  return p != NULL ? *p : *reinterpret_cast<const ::google::cloud::language::v1beta2::Sentiment*>(
      &::google::cloud::language::v1beta2::_Sentiment_default_instance_);
}
inline ::google::cloud::language::v1beta2::Sentiment* AnnotateTextResponse::release_document_sentiment() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnnotateTextResponse.document_sentiment)
  
  ::google::cloud::language::v1beta2::Sentiment* temp = document_sentiment_;
  document_sentiment_ = NULL;
  return temp;
}
inline ::google::cloud::language::v1beta2::Sentiment* AnnotateTextResponse::mutable_document_sentiment() {
  
  if (document_sentiment_ == NULL) {
    document_sentiment_ = new ::google::cloud::language::v1beta2::Sentiment;
  }
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnnotateTextResponse.document_sentiment)
  return document_sentiment_;
}
inline void AnnotateTextResponse::set_allocated_document_sentiment(::google::cloud::language::v1beta2::Sentiment* document_sentiment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete document_sentiment_;
  }
  if (document_sentiment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      document_sentiment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, document_sentiment, submessage_arena);
    }
    
  } else {
    
  }
  document_sentiment_ = document_sentiment;
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnnotateTextResponse.document_sentiment)
}

// string language = 5;
inline void AnnotateTextResponse::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnnotateTextResponse::language() const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextResponse.language)
  return language_.GetNoArena();
}
inline void AnnotateTextResponse::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:google.cloud.language.v1beta2.AnnotateTextResponse.language)
}
#if LANG_CXX11
inline void AnnotateTextResponse::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:google.cloud.language.v1beta2.AnnotateTextResponse.language)
}
#endif
inline void AnnotateTextResponse::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:google.cloud.language.v1beta2.AnnotateTextResponse.language)
}
inline void AnnotateTextResponse::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:google.cloud.language.v1beta2.AnnotateTextResponse.language)
}
inline ::std::string* AnnotateTextResponse::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnnotateTextResponse.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnnotateTextResponse::release_language() {
  // @@protoc_insertion_point(field_release:google.cloud.language.v1beta2.AnnotateTextResponse.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnnotateTextResponse::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:google.cloud.language.v1beta2.AnnotateTextResponse.language)
}

// repeated .google.cloud.language.v1beta2.ClassificationCategory categories = 6;
inline int AnnotateTextResponse::categories_size() const {
  return categories_.size();
}
inline void AnnotateTextResponse::clear_categories() {
  categories_.Clear();
}
inline const ::google::cloud::language::v1beta2::ClassificationCategory& AnnotateTextResponse::categories(int index) const {
  // @@protoc_insertion_point(field_get:google.cloud.language.v1beta2.AnnotateTextResponse.categories)
  return categories_.Get(index);
}
inline ::google::cloud::language::v1beta2::ClassificationCategory* AnnotateTextResponse::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:google.cloud.language.v1beta2.AnnotateTextResponse.categories)
  return categories_.Mutable(index);
}
inline ::google::cloud::language::v1beta2::ClassificationCategory* AnnotateTextResponse::add_categories() {
  // @@protoc_insertion_point(field_add:google.cloud.language.v1beta2.AnnotateTextResponse.categories)
  return categories_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory >*
AnnotateTextResponse::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:google.cloud.language.v1beta2.AnnotateTextResponse.categories)
  return &categories_;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::cloud::language::v1beta2::ClassificationCategory >&
AnnotateTextResponse::categories() const {
  // @@protoc_insertion_point(field_list:google.cloud.language.v1beta2.AnnotateTextResponse.categories)
  return categories_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1beta2
}  // namespace language
}  // namespace cloud
}  // namespace google

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::google::cloud::language::v1beta2::Document_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::Document_Type>() {
  return ::google::cloud::language::v1beta2::Document_Type_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::Entity_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::Entity_Type>() {
  return ::google::cloud::language::v1beta2::Entity_Type_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Tag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Tag>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Tag_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Aspect> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Aspect>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Aspect_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Case> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Case>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Case_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Form> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Form>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Form_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Gender> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Gender>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Gender_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Mood> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Mood>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Mood_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Number> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Number>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Number_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Person> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Person>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Person_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Proper> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Proper>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Proper_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Reciprocity> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Reciprocity>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Reciprocity_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Tense> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Tense>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Tense_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::PartOfSpeech_Voice> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::PartOfSpeech_Voice>() {
  return ::google::cloud::language::v1beta2::PartOfSpeech_Voice_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::DependencyEdge_Label> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::DependencyEdge_Label>() {
  return ::google::cloud::language::v1beta2::DependencyEdge_Label_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::EntityMention_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::EntityMention_Type>() {
  return ::google::cloud::language::v1beta2::EntityMention_Type_descriptor();
}
template <> struct is_proto_enum< ::google::cloud::language::v1beta2::EncodingType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::google::cloud::language::v1beta2::EncodingType>() {
  return ::google::cloud::language::v1beta2::EncodingType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_google_2fcloud_2flanguage_2fv1beta2_2flanguage_5fservice_2eproto__INCLUDED
